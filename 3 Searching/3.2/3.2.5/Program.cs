namespace _3._2._5
{
    class Program
    {
        static void Main(string[] args)
        {
            // 显然我们希望在二叉树的键和查找频率之间找到一个平衡。
            // 我们将 BST 的每个结点对应的路径长度乘上查找频率（权重），
            // 然后加起来得到 BST 的总查找开销。
            // 总查找开销最小的树叫做最优化二叉搜索树，即 Optimal BST。
            // 根据 BST 的性质我们不难得到，Optimal BST 的所有子树也都是 Optimal BST。
            // 于是这个问题就可以分解成子问题一步步解决。
            // 一棵二叉树的查找开销可以写成这样的形式：
            // 左子树的开销 + 右子树的开销 + 所有结点的权重之和
            // （注意子树高度是整棵树的高度减一）
            // 由于 BST 是有序的，我们先将 n 个键值从小到大排序。
            // 对于大小为 1 的子树，总共有 n 种可能性，就是每个结点本身，
            // 对于大小为 2 的子树，总共有 n-1 种键值选择，
            // （第一个和第二个，第二个和第三个，第三个和第四个，以此类推）
            // 每种键值选择又有两种根结点的选择方法，取开销较小的那个，
            // 对于大小为 3 的子树，总共有 n-2 种键值选择，
            // 每种键值选择都有三种根结点的选择方法，根据公式可以算出开销，同样取开销较小的那个。
            // 一直到大小为 n 的树，算得最小开销之后，依次选择每一级中开销最小的根结点，组成 Optimal BST
            // 
            // 举个例子：
            // 键值  1 2 3 4 
            // 频率  4 1 2 1
            // 
            // s=1 (1,1) (2,2) (3,3) (4,4)
            //       4     1     2     1
            // s=2   (1,2)     (2,3)    (3,4)
            //      0+1+5=6   1+0+3=4  1+0+3=4    min(左子树+右子树+总和)
            // s=3       (1,3)             (2,4)
            //       0+(2,3)+7=11    (2,2)+(4,4)+7=9
            // s=4                (1,4)
            //              (1,2)+(4,4)+10=17
            //
            //                   3
            //                 /   \
            //                1     4
            //                 \
            //                  2
        }
    }
}
