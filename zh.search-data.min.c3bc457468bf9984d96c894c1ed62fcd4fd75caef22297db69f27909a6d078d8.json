[{"id":0,"href":"/1-1-1/","title":"1.1.1","section":"帮助","content":"1.1.1 #  解答 #  a.7\nb.200.0000002\nc.True\n代码 #  static void Main(string[] args) { int a = (0 + 15) / 2; double b = 2.0e-6 * 100000000.1; bool c = true \u0026amp;\u0026amp; false || true \u0026amp;\u0026amp; true; Console.WriteLine($\u0026#34;a.{a}\u0026#34;); Console.WriteLine($\u0026#34;b.{b}\u0026#34;); Console.WriteLine($\u0026#34;c.{c}\u0026#34;); } "},{"id":1,"href":"/1-1-2/","title":"1.1.2","section":"帮助","content":"1.1.2 #  解答 #     Name Type Value     a System.Double 1.618   b System.Double 10   c System.Boolean True   d System.String 33    代码 #  static void Main(string[] args) { //var 变量名 = 初始值 根据初始值自动判断变量类型  var a = (1 + 2.236) / 2; var b = 1 + 2 + 3 + 4.0; var c = 4.1 \u0026gt;= 4; var d = 1 + 2 + \u0026#34;3\u0026#34;; //Console.WriteLine 向控制台输出一行  //变量名.GetType() 返回变量类型  //Type.ToString() 将类型名转换为字符串  Console.WriteLine(\u0026#34;\\tName\\tType \\tValue\u0026#34;); Console.WriteLine($\u0026#34;\\ta\\t{a.GetType().ToString()}\\t{a}\u0026#34;); Console.WriteLine($\u0026#34;\\tb\\t{b.GetType().ToString()}\\t{b}\u0026#34;); Console.WriteLine($\u0026#34;\\tc\\t{c.GetType().ToString()}\\t{c}\u0026#34;); Console.WriteLine($\u0026#34;\\td\\t{d.GetType().ToString()}\\t{d}\u0026#34;); } "},{"id":2,"href":"/1-1-3/","title":"1.1.3","section":"帮助","content":"1.1.3 #  解答 #  简单的 if 判断即可。\n代码 #  static void Main(string[] args) { //Console.ReadLine() 从控制台读入一整行（返回int）  //string.Split(char) 根据提供的分隔符将字符串分割，返回字符串数组  //Int32.Parse(string) 将字符串转换为相应的整型数据  string input = Console.ReadLine(); int a = Int32.Parse(input.Split(\u0026#39; \u0026#39;)[0]); int b = Int32.Parse(input.Split(\u0026#39; \u0026#39;)[1]); int c = Int32.Parse(input.Split(\u0026#39; \u0026#39;)[2]); //Console.WriteLine() 向控制台输出一行  if (a == b \u0026amp;\u0026amp; b == c) { Console.WriteLine(\u0026#34;equal\u0026#34;); } else { Console.WriteLine(\u0026#34;not equal\u0026#34;); } } "},{"id":3,"href":"/1-1-4/","title":"1.1.4","section":"帮助","content":"1.1.4 #  解答 #  a. if 后跟 then 的语法不能在 C# 中使用。\nb. if 后的判断语句需要在括号内。\nc. 正确，只有一条语句时大括号可以省略。\nd. c = 0 后缺少分号。\n代码 #  static void Main(string[] args) { int a = 1; int b = 2; int c = 0; //if (a \u0026gt; b) then c = 0;  //if 后不能跟 then  //if a \u0026gt; b { c = 0; }  //if后必须跟括号  if (a \u0026gt; b) c = 0; //正确  //if (a \u0026gt; b) c = 0 else b = 0;  //c = 0后缺少分号  } "},{"id":4,"href":"/1-1-5/","title":"1.1.5","section":"帮助","content":"1.1.5 #  解答 #  比较简单，直接判断即可。\n代码 #  static void Main(string[] args) { //修改这两个值进行测试  double x = 0.05; double y = 0.01; if (x \u0026gt; 0 \u0026amp;\u0026amp; x \u0026lt; 1 \u0026amp;\u0026amp; y \u0026gt; 0 \u0026amp;\u0026amp; y \u0026lt; 1) { Console.WriteLine(\u0026#34;true\u0026#34;); } else { Console.WriteLine(\u0026#34;false\u0026#34;); } } "},{"id":5,"href":"/1-1-6/","title":"1.1.6","section":"帮助","content":"1.1.6 #  解答 #  输出斐波那契数列。\n将书中的代码直接实现即可。\n代码 #  //输出斐波那契数列 static void Main(string[] args) { int f = 0; int g = 1; for (int i = 0; i \u0026lt;= 15; i++) { //Console.WriteLine与StdOut.println功能相同  //实现向控制台输出一行  Console.WriteLine(f); f = f + g; g = f - g; } } "},{"id":6,"href":"/1-1-7/","title":"1.1.7","section":"帮助","content":"1.1.7 #  解答 #  同上题，直接实现即可。\na\n3.00009\ndouble计算存在误差，并不精确。\nb\n499500\n1000 + 999 + 998……\nc\n10000\n1000 * 10，外层循环的结束条件为 $2^i \u0026gt;1000$\n代码 #  private static void a() { Console.WriteLine(\u0026#34;a\u0026#34;); double t = 9.0; while (Math.Abs(t - 9.0 / t) \u0026gt; .001) { t = (9.0 / t + t) / 2.0; } Console.Write($\u0026#34;{t:N5}\\n\u0026#34;);//:N5代表保留5位小数，同理可使用N1、N2…… } private static void b() { Console.WriteLine(\u0026#34;\\nb\u0026#34;); int sum = 0; for (int i = 1; i \u0026lt; 1000; i++) { for (int j = 0; j \u0026lt; i; j++) { sum++; } } Console.WriteLine(sum); } private static void c() { Console.WriteLine(\u0026#34;\\nc\u0026#34;); int sum = 0; for (int i = 1; i \u0026lt; 1000; i *= 2) { for (int j = 0; j \u0026lt; 1000; j++) { sum++; } } Console.WriteLine(sum); } static void Main(string[] args) { //a double 计算存在误差  a(); //b 1000+999+998……  b(); //c 由于2^10 = 1024 \u0026gt; 1000，最终sum = 1000 * 10 = 10000  c(); } "},{"id":7,"href":"/1-1-8/","title":"1.1.8","section":"帮助","content":"1.1.8 #  解答 #  b\n197\ne\n代码 #  static void Main(string[] args) { Console.WriteLine(\u0026#39;b\u0026#39;); Console.WriteLine(\u0026#39;b\u0026#39; + \u0026#39;c\u0026#39;); //char 被隐式转为为 int 类型，取 ascii 码  Console.WriteLine((char)(\u0026#39;a\u0026#39; + 4)); //强制转换后，ascii 码被转换为相应的字符 } "},{"id":8,"href":"/1-1-9/","title":"1.1.9","section":"帮助","content":"1.1.9 #  解答 #  有两种方法，要么直接调用库函数，要么用书中给出的代码转换。\n代码 #  static void Main(string[] args) { int N = 4; //1.直接转换 Convert.ToString(int, int) 第一个为要转换的数，第二个为要转换的进制  Console.WriteLine($\u0026#34;{Convert.ToString(N, 2)}\u0026#34;); //2.转换为二进制数  string s = \u0026#34;\u0026#34;; for (int n = N; n \u0026gt; 0; n /= 2) { s = (n % 2) + s; } Console.WriteLine(s); } "},{"id":9,"href":"/1-1-10/","title":"1.1.10","section":"帮助","content":"1.1.10 #  解答 #  变量使用前需要先赋值。\n代码 #  static void Main(string[] args) { int[] a; for (int i = 0; i \u0026lt; 10; i++) { a[i] = i * i; //不允许使用未赋值的局部变量  } } "},{"id":10,"href":"/1-1-11/","title":"1.1.11","section":"帮助","content":"1.1.11 #  解答 #  注意，二维数组 bool[M, N] 代表 M 行 N 列的布尔数组。\n使用二重循环即可实现。\n输出使用制表符 ’\\t’ 作为分隔。\n代码 #  static void PrintArray2D(bool[,] array) { int rows = array.GetLength(0);//获取行数  int columns = array.GetLength(1);//获取列数  //输出列号  for (int i = 0; i \u0026lt; columns; i++) { Console.Write($\u0026#34;\\t{i + 1}\u0026#34;); } Console.Write(\u0026#34;\\n\u0026#34;); for (int i = 0; i \u0026lt; rows; i++) { //输出行号  Console.Write($\u0026#34;{i + 1}\u0026#34;); for (int j = 0; j \u0026lt; columns; j++) { if (array[i, j]) { Console.Write($\u0026#34;\\t*\u0026#34;); } else { Console.Write($\u0026#34;\\t \u0026#34;); } } Console.Write(\u0026#34;\\n\u0026#34;); } } "},{"id":11,"href":"/1-1-12/","title":"1.1.12","section":"帮助","content":"1.1.12 #  解答 #  第一个循环初始化数组{9, 8, 7, 6, 5, 4, 3, 2, 1, 0}\n第二个循环用相应位置的值作为下标取值，例如：a[0] = a[a[0]] = a[9] = 0\n最后结果为：0,1,2,3,4,4,3,2,1,0\n代码 #  static void Main(string[] args) { int[] a = new int[10]; for (int i = 0; i \u0026lt; 10; i++) { a[i] = 9 - i; } //a[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}  for (int i = 0; i \u0026lt; 10; i++) { a[i] = a[a[i]]; } //a[0] = a[9] = 0; a[1] = a[8] = 1; a[2] = a[7] = 2;......  for (int i = 0; i \u0026lt; 10; i++) { Console.WriteLine(a[i]); } } "},{"id":12,"href":"/1-1-13/","title":"1.1.13","section":"帮助","content":"1.1.13 #  解答 #  转置输出只需要在二重循环的时候将行、列输出顺序取反即可。\n代码 #  static void Main(string[] args) { int M = 2; int N = 3; int[,] array = new int[M, N]; //新建一个二维数组  for (int i = 0; i \u0026lt; M; i++) { for (int j = 0; j \u0026lt; N; j++) { array[i, j] = i + j; } } Console.WriteLine(\u0026#34;Origin\u0026#34;); PrintArray2D(array, M, N); Console.WriteLine(\u0026#34;Transposed\u0026#34;); PrintArrayTranspose2D(array, M, N); } //转置输出 private static void PrintArrayTranspose2D(int[,] array, int rows, int columns) { //交换行、列输出顺序  for (int i = 0; i \u0026lt; columns; i++) { for (int j = 0; j \u0026lt; rows; j++) { Console.Write($\u0026#34;\\t{array[j, i]}\u0026#34;); } Console.Write(\u0026#34;\\n\u0026#34;); } } //正常输出 private static void PrintArray2D(int[,] array, int rows, int columns) { for (int i = 0; i \u0026lt; rows; i++) { for (int j = 0; j \u0026lt; columns; j++) { Console.Write($\u0026#34;\\t{array[i, j]}\u0026#34;); } Console.Write(\u0026#34;\\n\u0026#34;); } } "},{"id":13,"href":"/1-1-14/","title":"1.1.14","section":"帮助","content":"1.1.14 #  解答 #  简单使用 log 的定义逼近即可。\n代码 #  static void Main(string[] args) { int N = 9; Console.WriteLine($\u0026#34;{ lg(N)}\u0026#34;); } //利用循环逼近 N，得到 log2(N) 的值 static int lg(int N) { int baseNumber = 2; int pow = 1; int sum = 2; for (pow = 1; sum \u0026lt; N; ++pow) { sum *= baseNumber; } return pow - 1; } "},{"id":14,"href":"/1-1-15/","title":"1.1.15","section":"帮助","content":"1.1.15 #  解答 #  利用二重循环，查找每个值在数组中出现的次数。\n代码 #  static void Main(string[] args) { int[] a = new int[10]; int M = 10; for (int i = 0; i \u0026lt; 10; ++i) { a[i] = i; } int[] result = Histogram(a, M); Console.WriteLine($\u0026#34;a.length: {a.Length}\u0026#34;); Console.WriteLine($\u0026#34;sum of result array: {result.Sum()}\u0026#34;); } static int[] Histogram(int[] a, int M) { int[] result = new int[M]; for (int i = 0; i \u0026lt; M; ++i) { //初始化  result[i] = 0; //遍历数组，计算数组中值为 i 的元素个数  for (int j = 0; j \u0026lt; a.Length; ++j) { if (a[j] == i) //值为 i 的元素  { result[i]++; } } } return result; } "},{"id":15,"href":"/1-1-16/","title":"1.1.16","section":"帮助","content":"1.1.16 #  解答 #  填入代码测试即可。\n用字符串拼接的方式展示递归。\n类似于这个：\n代码 #  static void Main(string[] args) { int[] a = new int[10]; int M = 10; for (int i = 0; i \u0026lt; 10; ++i) { a[i] = i; } int[] result = Histogram(a, M); Console.WriteLine($\u0026#34;a.length: {a.Length}\u0026#34;); Console.WriteLine($\u0026#34;sum of result array: {result.Sum()}\u0026#34;); } static int[] Histogram(int[] a, int M) { int[] result = new int[M]; for (int i = 0; i \u0026lt; M; ++i) { //初始化  result[i] = 0; //遍历数组，计算数组中值为 i 的元素个数  for (int j = 0; j \u0026lt; a.Length; ++j) { if (a[j] == i) //值为 i 的元素  { result[i]++; } } } return result; } "},{"id":16,"href":"/1-1-17/","title":"1.1.17","section":"帮助","content":"1.1.17 #  解答 #  书中已经给出了解释。\n递归时结束条件必须放在递归语句的前面，否则会不断展开而无法结束。\n代码 #  static void Main(string[] args) { Console.WriteLine($\u0026#34;{exR2(6)}\u0026#34;);//抛出 StackOverflow Exception } public static string exR2(int n) { string s = exR2(n - 3) + n + exR2(n - 2) + n;//运行到 exR2 即展开，不会再运行下一句  if (n \u0026lt;= 0) return \u0026#34;\u0026#34;; return s; } "},{"id":17,"href":"/1-1-18/","title":"1.1.18","section":"帮助","content":"1.1.18 #  解答 #  其实就是一种快速乘法的实现，换成乘号之后就变成了快速乘幂。\n例如对于乘法 $2 \\times 4$ ，可以用 $2 + 2 + 2 + 2$ 做四次加法计算；也可以变为 $(2 + 2) \\times 2 = (2 + 2) + (2 + 2)$ 的形式，用两次加法就可以完成（先计算 $2 + 2$ 的值，再计算 $4 + 4$ 的值）。\n同理对于乘幂 $2^8$ ，既可以用 $2\\times 2 \\times 2 \\times 2 \\times 2 \\times 2 \\times 2 \\times 2$ 做 8 次乘法，也可以只用三次乘法就计算出来：\n$$\n2^2 = 2 \\times 2 \\\n2^4 = 2^2 \\times 2^2\\\n2^8 = 2^4 \\times 2^4\n$$\n这样时间复杂度就从 $O(n)$ 变为了 $O(log n)$ 。\n代码 #  static void Main(string[] args) { Console.WriteLine($\u0026#34;mystery(2, 25): {mystery(2, 25)}\u0026#34;); Console.WriteLine($\u0026#34;mystery(3, 11): {mystery(3, 11)}\u0026#34;); Console.WriteLine($\u0026#34;mysteryChanged(2, 8): {mysteryChanged(2, 8)}\u0026#34;); Console.WriteLine($\u0026#34;mysteryChanged(3, 2): {mysteryChanged(3, 2)}\u0026#34;); } //mystery(a, b) = a * b //利用等式：a * b = 2a * b/2 = (2a * (b-1) / 2) + a //示例： //mystery(2, 25) = //mystery(2 + 2, 12) + 2 = //mystery(4 + 4, 6) + 2 = //mystery(8 + 8, 3) = //mystery(16 + 16, 1) + 16 + 2 = //mystery(32 + 32, 0) + 32 + 16 + 2 = //0 + 32 + 16 + 2 = //50 public static int mystery(int a, int b) { if (b == 0) return 0; if (b % 2 == 0) return mystery(a + a, b / 2); return mystery(a + a, b / 2) + a; } //mysteryChanged(a, b) = a ^ b //同理（乘方与乘法，乘法与加法之间具有类似的性质） //a ^ b = (a ^ 2) ^ (b / 2) = (a ^ 2) ^ ((b - 1) / 2) * a public static int mysteryChanged(int a, int b) { if (b == 0) return 1; if (b % 2 == 0) return mysteryChanged(a * a, b / 2); return mysteryChanged(a * a, b / 2) * a; } "},{"id":18,"href":"/1-1-19/","title":"1.1.19","section":"帮助","content":"1.1.19 #  解答 #  普通的递归算法效率很低，原因是越到后面重复运算的数目越多。\n比如：\nF(2) = F(1) + F(0)\nF(3) = F(2) + F(1) = F(1) + F(1) + F(0)\n可以看到 F(1) 被重复计算了两次。\n改进的方式是将每次运算的结果保存在数组中，之后计算过的数据直接从数组中提取。\n代码 #  class Fibnacci { //long 类型不够大，换成 UINT64 类型  //用于保存计算结果的数组，UInt64? 代表可以赋值为普通 UInt64 类型的值以及 null 值  private static UInt64?[] fibnacciResults = new UInt64?[100]; static void Main(string[] args) { /* * 测试环境 * * Surface Pro3 i7 * i7 4650U + 8G * */ Stopwatch timer = Stopwatch.StartNew(); for (int N = 0; N \u0026lt; 100; ++N) { //书本中的代码，非常慢，1小时后 N = 50  //Console.WriteLine($\u0026#34;{N} {F(N)}\u0026#34;);  //利用已知结果加速  //全部计算完毕耗时 84ms  Console.WriteLine($\u0026#34;{N} {BetterF(N)}\u0026#34;); } Console.WriteLine($\u0026#34;{timer.ElapsedMilliseconds} ms\u0026#34;); } //书中提供的代码  public static UInt64 F(int N) { if (N == 0) return 0; if (N == 1) return 1; return F(N - 1) + F(N - 2); } //更好的实现，将已经计算的结果保存，不必重复计算  public static UInt64? BetterF(int N) { if (N == 0) return 0; if (N == 1) return 1; if (fibnacciResults[N] != null) //如果已经计算过则直接读取已知值  { return fibnacciResults[N]; } else { fibnacciResults[N] = BetterF(N - 1) + BetterF(N - 2); return fibnacciResults[N]; } } } "},{"id":19,"href":"/1-1-20/","title":"1.1.20","section":"帮助","content":"1.1.20 #  解答 #  根据对数的性质可以得到：\nln(N!) = ln(N) + ln(N – 1) + ln(N – 2)…\n代码 #  static void Main(string[] args) { int N = 4; Console.WriteLine($\u0026#34;{factorialLn(N)}\u0026#34;); } //ln(N!) = //ln(N * (N - 1) * ... * 1) = //ln(N) + ln((N - 1)!) public static double factorialLn(int N) { if (N == 1) { return 0; } return Math.Log(N) + factorialLn(N - 1); } "},{"id":20,"href":"/1-1-21/","title":"1.1.21","section":"帮助","content":"1.1.21 #  解答 #  实现上没什么难度，打印表格的部分可以参考之前打印二位布尔数组的方法。\n注意整型数据之间相除得到的仍然是整型，小数部分会直接舍去，例如 2 / 3 = 0。\n代码 #  static void Main(string[] args) { int columns = 2; int rows = int.Parse(Console.ReadLine()); //行号  string[] names = new string[rows]; //姓名  int[,] array = new int[rows, columns]; //输入的两个整数  double[] results = new double[rows]; //计算结果  for (int i = 0; i \u0026lt; rows; ++i) { string temp = Console.ReadLine(); names[i] = temp.Split(\u0026#39; \u0026#39;)[0]; for (int j = 0; j \u0026lt; columns; ++j) { array[i, j] = int.Parse(temp.Split(\u0026#39; \u0026#39;)[j + 1]); } results[i] = (double)array[i, 0] / array[i, 1]; } PrintArray2D(names, array, results); } static void PrintArray2D(string[] names, int[,] array, double[] results) { int rows = array.GetLength(0);//获取行数  int columns = array.GetLength(1);//获取列数  for (int i = 0; i \u0026lt; rows; i++) { Console.Write($\u0026#34;\\t{names[i]}\u0026#34;); for (int j = 0; j \u0026lt; columns - 1; j++) { Console.Write($\u0026#34;\\t{array[i, j]}\u0026#34;); } Console.Write($\u0026#34;\\t{array[i, columns - 1]}\u0026#34;); Console.Write($\u0026#34;\\t{results[i]:N3}\u0026#34;); //变量名:N3 保留三位小数  Console.Write(\u0026#34;\\n\u0026#34;); } } "},{"id":21,"href":"/1-1-22/","title":"1.1.22","section":"帮助","content":"1.1.22 #  解答 #  按照书中的提示增加一个保存深度的参数。\n代码 #  class BinarySearch { static void Main(string[] args) { int[] array = new int[10] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; rank(9, array); } //重载方法，用于启动二分查找  public static int rank(int key, int[] a) { return rank(key, a, 0, a.Length - 1, 1); } //二分查找  public static int rank(int key, int[] a, int lo, int hi, int number) { for (int i = 0; i \u0026lt; number; ++i) { Console.Write(\u0026#34; \u0026#34;); } Console.WriteLine($\u0026#34;{number}: {lo} {hi}\u0026#34;); if (lo \u0026gt; hi) { return -1; } int mid = lo + (hi - lo) / 2; if (key \u0026lt; a[mid]) { return rank(key, a, lo, mid - 1, number + 1); } else if (key \u0026gt; a[mid]) { return rank(key, a, mid + 1, hi, number + 1); } else { return mid; } } } "},{"id":22,"href":"/1-1-23/","title":"1.1.23","section":"帮助","content":"1.1.23 #  解答 #  在主函数里做一下判断就可以了，加号则输出所有找不到的值，减号则相反。\n代码 #  static void Main(string[] args) { //从largeW.txt中读取数据  string[] whiteList = File.ReadAllLines(\u0026#34;largeW.txt\u0026#34;); int[] WhiteList = new int[whiteList.Length]; for (int i = 0; i \u0026lt; whiteList.Length; ++i) { WhiteList[i] = int.Parse(whiteList[i]); } Array.Sort\u0026lt;int\u0026gt;(WhiteList); Console.WriteLine(\u0026#34;Type the numbers you want to query: \u0026#34;); //输入样例：5 824524 478510 387221  string input = Console.ReadLine(); int[] Query = new int[input.Split(\u0026#39; \u0026#39;).Length]; for (int i = 0; i \u0026lt; Query.Length; ++i) { Query[i] = int.Parse(input.Split(\u0026#39; \u0026#39;)[i]); } Console.WriteLine(\u0026#34;Type \u0026#39;+\u0026#39; to get the numbers that not in the whitelist,\u0026#34; + \u0026#34;\u0026#39;-\u0026#39; to get the numbers that in the whitelist.\u0026#34;); char operation = Console.ReadLine()[0]; foreach (int n in Query) { if (rank(n, WhiteList) == -1) { if (operation == \u0026#39;+\u0026#39;) { Console.WriteLine(n); } } else if (operation == \u0026#39;-\u0026#39;) { Console.WriteLine(n); } } } //重载方法，用于启动二分查找 public static int rank(int key, int[] a) { return rank(key, a, 0, a.Length - 1); } //二分查找 public static int rank(int key, int[] a, int lo, int hi) { if (lo \u0026gt; hi) { return -1; } int mid = lo + (hi - lo) / 2; if (key \u0026lt; a[mid]) { return rank(key, a, lo, mid - 1); } else if (key \u0026gt; a[mid]) { return rank(key, a, mid + 1, hi); } else { return mid; } } 另请参阅 #  LargeW.txt\n"},{"id":23,"href":"/1-1-24/","title":"1.1.24","section":"帮助","content":"1.1.24 #  解答 #  在书本中 GCD 的基础上，在函数开始时增加一条输出语句即可。\n代码 #  static void Main(string[] args) { GCD(105, 24); Console.WriteLine(); GCD(111111, 1234567); } public static int GCD(int a, int b) { Console.WriteLine($\u0026#34;{a} {b}\u0026#34;); if (b == 0) { return a; } return GCD(b, a % b); } "},{"id":24,"href":"/1-1-25/","title":"1.1.25","section":"帮助","content":"1.1.25 #  解答 #  已知：$a,b$ 皆为正整数，且 $a\u0026gt;b$。$g$ 是 $ a,b$ 的最大公约数\n设 $\\ r_0=a\\bmod b$ ，$r_k = r_{k-2} \\bmod\\ r_{k-1}$ 。\n那么有 $gcd(a,b)=gcd(b,r_0)=gcd(r_0,r_1)\u0026hellip;=gcd(r_{n-1},r_n)$ 。\n且 $r_n=0$ （此时算法终止）。\n由于 $r_{n-2}=q_n\\times r_{n-1} + r_n=q_n\\times r_{n-1} \\ (q_n=\\lfloor r_{n-2}/r_{n-1}\\rfloor)$ 。\n可得 $r_{n-2}$ 能被 $r_{n-1}$ 整除。\n则有\n$r_{n-3}\\=q_{n-1} \\times r_{n-2} + r_{n-1}\\=q_{n-1}\\times (q_n \\times r_{n-1})+r_{n-1}\\=q_{n-1}\\times q_n \\times r_{n-1} + r_{n-1} \\=(q_{n-1} \\times q_n +1)\\times r_{n-1}$\n可得 $r_{n-3}$ 也能被 $r_{n-1}$ 整除\n以此类推，$r_{n-1}$ 可以整除 $a$ 和 $b$ ，即 $r_{n-1}$ 是 $a$ 和 $b$ 的公约数\n则 $r_{n-1}\\le g$ 。\n因为 $g$ 是 $a,b$ 的最大公约数，由其性质可得：\n$a=mg,b=ng$ ，其中 $m,n$ 是自然数。\n$r_0 \\=a \\bmod b \\=a-q_0 \\times b\\qquad (q_0=\\lfloor a/b \\rfloor) \\= mg-q_0\\times ng\\=(m-q_0\\times n)g$\n可得 $r_0$ 能够被 $g$ 整除。\n同理 $r_0,r_1,r_2\\dots r_{n-1}$ 都可以被 $g$ 整除。\n因此 $g\\le r_{n-1}$\n综上，$g=r_{n-1}$ ，证明完毕。\n"},{"id":25,"href":"/1-1-26/","title":"1.1.26","section":"帮助","content":"1.1.26 #  解答 #  见代码部分。\n代码 #  static void Main(string[] args) { int a = 3; int b = 2; int c = 1; int t = 0; if (a \u0026gt; b) { t = a; a = b; b = t; } //如果 a \u0026gt; b，那么 a, b 交换，保证b \u0026gt;= a  if (a \u0026gt; c) { t = a; a = c; c = t; } //如果 b \u0026gt;= a \u0026gt; c，那么 a, c 交换，保证 c \u0026gt;= a  if (b \u0026gt; c) { t = b; b = c; c = t; } //如果 b \u0026gt; c \u0026gt;= a，那么 b, c 交换，保证 c \u0026gt;= b  Console.WriteLine($\u0026#34;{a} {b} {c}\u0026#34;); //最终结果为 c \u0026gt;= b \u0026gt;= a，保证升序排列 } "},{"id":26,"href":"/1-1-27/","title":"1.1.27","section":"帮助","content":"1.1.27 #  解答 #  与之前的斐波那契数列类似，都是重复计算的问题。\n答案是 7751 次。\n代码 #  class Program { static int BinomialCalled = 0; //计算递归调用次数  static double?[,] BinomialCache; //保存计算结果的数组  static void Main(string[] args) { BinomialCache = new double?[101, 51]; Console.WriteLine(Binomial(100, 50, 0.25)); Console.WriteLine(BinomialCalled); } public static double? Binomial(int N, int k, double p) { BinomialCalled++; if (N == 0 \u0026amp;\u0026amp; k == 0) return 1.0; if (N \u0026lt; 0 || k \u0026lt; 0) return 0.0; if (BinomialCache[N, k] != null) { return BinomialCache[N, k]; } else { BinomialCache[N, k] = (1.0 - p) * Binomial(N - 1, k, p) + p * Binomial(N - 1, k - 1, p); return BinomialCache[N, k]; } } } "},{"id":27,"href":"/1-1-28/","title":"1.1.28","section":"帮助","content":"1.1.28 #  解答 #  实现方法有很多，这里是使用一个 HashSet 做中转，删除所有的重复元素。\n也可以使用 Linq 里的 Distinct() 方法，\n也可以排序后直接遍历一遍，遇到相同的就删除，遇到不同的就保存起来用于之后的比较。\n代码 #  static void Main(string[] args) { //从largeW.txt中读取数据  //用 HashSet 的不可重复性去除重复  HashSet\u0026lt;string\u0026gt; h = new HashSet\u0026lt;string\u0026gt;(File.ReadAllLines(\u0026#34;largeW.txt\u0026#34;)); string[] whiteList = new string[h.Count]; h.CopyTo(whiteList); int[] WhiteList = new int[whiteList.Length]; for (int i = 0; i \u0026lt; whiteList.Length; ++i) { WhiteList[i] = int.Parse(whiteList[i]); } Array.Sort\u0026lt;int\u0026gt;(WhiteList); Console.WriteLine(\u0026#34;Type the numbers you want to query: \u0026#34;); //输入样例：5 824524 478510 387221  string input = Console.ReadLine(); int[] Query = new int[input.Split(\u0026#39; \u0026#39;).Length]; for (int i = 0; i \u0026lt; Query.Length; ++i) { Query[i] = int.Parse(input.Split(\u0026#39; \u0026#39;)[i]); } Console.WriteLine(\u0026#34;Irrelevant:\u0026#34;); foreach (int n in Query) { if (rank(n, WhiteList) == -1) { Console.WriteLine(n); } } } //重载方法，用于启动二分查找 public static int rank(int key, int[] a) { return rank(key, a, 0, a.Length - 1); } //二分查找 public static int rank(int key, int[] a, int lo, int hi) { if (lo \u0026gt; hi) { return -1; } int mid = lo + (hi - lo) / 2; if (key \u0026lt; a[mid]) { return rank(key, a, lo, mid - 1); } else if (key \u0026gt; a[mid]) { return rank(key, a, mid + 1, hi); } else { return mid; } } 另请参阅 #  LargeW.txt\n"},{"id":28,"href":"/1-1-29/","title":"1.1.29","section":"帮助","content":"1.1.29 #  解答 #  查找小于指定值的元素数量可以多次使用二分查找实现。\n例如：\n序号：0 1 2 3 4 5 6 7 8\n元素：1 2 2 2 2 2 2 2 3\n二分查找返回 4\n再次在 0~3 之间查找\n二分查找返回 1\n再次在 0~1 之间查找\n二分查找返回 -1，没有指定值了\n因此小于该值的元素数量就是 1 – 0 = 1 个\n用同样的方法可以找到大于指定值的元素个数，\n从总数中减去这两个数值就是等于指定值的元素数量。\n代码 #  static void Main(string[] args) { int[] WhiteList = new int[] { 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6 }; Array.Sort\u0026lt;int\u0026gt;(WhiteList); Console.WriteLine(\u0026#34;Type the numbers you want to query: \u0026#34;); string input = Console.ReadLine(); int[] Query = new int[input.Split(\u0026#39; \u0026#39;).Length]; for (int i = 0; i \u0026lt; Query.Length; ++i) { Query[i] = int.Parse(input.Split(\u0026#39; \u0026#39;)[i]); } Console.WriteLine(\u0026#34;Result:\u0026#34;); foreach (int n in Query) { int less = rank(n, WhiteList); int equal = count(n, WhiteList); Console.WriteLine($\u0026#34;Less: {less} Equal: {equal}\u0026#34;); } } //返回数组中相等元素的个数  public static int count(int key, int[] a) { int lowerBound = rank(key, a); int upperBound = lowerBound; if (lowerBound == -1) return 0; int result = 0; while (true) { result = rank(key, a, upperBound + 1, a.Length - 1); if (result == -1) break; if (result \u0026gt; upperBound) { upperBound = result; } } return upperBound - lowerBound + 1; } //返回数组中小于该数的数字个数  public static int rank(int key, int[] a) { int mid = rank(key, a, 0, a.Length - 1); if (mid == -1) return 0; int result = mid; while (true) { result = rank(key, a, 0, mid - 1); if (result == -1) break; if (result \u0026lt; mid) mid = result; } return mid; } //二分查找  public static int rank(int key, int[] a, int lo, int hi) { if (lo \u0026gt; hi) { return -1; } int mid = lo + (hi - lo) / 2; if (key \u0026lt; a[mid]) { return rank(key, a, lo, mid - 1); } else if (key \u0026gt; a[mid]) { return rank(key, a, mid + 1, hi); } else { return mid; } } } "},{"id":29,"href":"/1-1-30/","title":"1.1.30","section":"帮助","content":"1.1.30 #  解答 #  互质可以用之前的 GCD 最大公因数算法判断，如果最大公因数是 1 则两数互质。\n代码 #  //互质 = 最大公约数为 1 = gcd(i, j) == 1 static void Main(string[] args) { int N = int.Parse(Console.ReadLine()); bool[,] a = new bool[N, N]; for (int i = 0; i \u0026lt; N; ++i) { for (int j = 0; j \u0026lt; N; ++j) { a[i, j] = (gcd(i, j) == 1); } } PrintArray2D(a, N, N); } static int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); } private static void PrintArray2D(bool[,] array, int rows, int columns) { for (int i = 0; i \u0026lt; rows; i++) { for (int j = 0; j \u0026lt; columns; j++) { Console.Write($\u0026#34;\\t{array[i, j]}\u0026#34;); } Console.Write(\u0026#34;\\n\u0026#34;); } } "},{"id":30,"href":"/1-1-31/","title":"1.1.31","section":"帮助","content":"1.1.31 #  解答 #  概率的实现方法：\n例如概率是 60 %，就在 [0, 100) 之间随机一个值，小于等于 60 则执行操作，反之不执行。\n需要更精确的情况可以增大随机的范围，例如 [0, 1000)。\n绘图结果\nN = 10,p = 0.2, 0.5, 1\n完整项目可以到 Github 上下载。\n代码 #  /// \u0026lt;summary\u0026gt; /// 主绘图函数 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;N\u0026#34;\u0026gt;点的总数目\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;每对点之间连接的概率\u0026lt;/param\u0026gt; public static void StartDrawing(int N, double p) { int pointSize = 5;//每个点绘制的大小  int precious = 1000;//概率判断的精度  //新建一个绘图窗口  Form2 DrawPad = new Form2(); //显示绘图窗口  DrawPad.Show(); //新建画布  Graphics graphics = DrawPad.CreateGraphics(); //建立绘图区域（矩形）  Rectangle rect = new Rectangle(10, 10, 400, 400); //画圆  graphics.DrawEllipse(Pens.Black, rect); //计算旋转角度  double rotateDgree = 360.0 / N; //计算点的坐标  Point Center = new Point(rect.Top + rect.Height / 2, rect.Top + rect.Height / 2); Point[] points = new Point[N]; points[0].X = rect.Left + rect.Width / 2; points[0].Y = rect.Top; for (int i = 1; i \u0026lt; N; ++i) { points[i] = Rotate(Center, points[i - 1], rotateDgree); } //绘制点  foreach (Point point in points) { graphics.FillEllipse(Brushes.Black, point.X - pointSize, point.Y - pointSize, pointSize, pointSize); } //按照概率绘制直线  Random random = new Random(); for (int i = 0; i \u0026lt; N; ++i) { for (int j = i + 1; j \u0026lt; N; ++j) { //举例：输入概率为 0.6，精度为 1000  //在 0~1000 范围内等概率取值，如果小于等于 600 则视为事件发生  if (random.Next(0, precious) \u0026lt;= p * precious) { graphics.DrawLine(Pens.Gray, points[i], points[j]); } } } //释放资源  graphics.Dispose(); } /// \u0026lt;summary\u0026gt; /// 计算一个点绕某点旋转之后的坐标值 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;origin\u0026#34;\u0026gt;旋转的圆心\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;point\u0026#34;\u0026gt;需要旋转的点\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;dgree\u0026#34;\u0026gt;旋转的角度（逆时针）\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;返回旋转后的坐标\u0026lt;/returns\u0026gt; public static Point Rotate(Point origin, Point point, double dgree) { Point rotated = new Point(); double dgreePi = dgree / 180 * Math.PI; rotated.X = (int)((point.X - origin.X) * Math.Cos(dgreePi) - (point.Y - origin.Y) * Math.Sin(dgreePi) + origin.X); rotated.Y = (int)((point.X - origin.X) * Math.Sin(dgreePi) + (point.Y - origin.Y) * Math.Cos(dgreePi) + origin.Y); return rotated; } "},{"id":31,"href":"/1-1-32/","title":"1.1.32","section":"帮助","content":"1.1.32 #  解答 #  绘图结果：\n完整的项目代码可以去 Github 上下载。\n代码 #  public static void StartDrawing(double[] array, int N, double l, double r) { //创建并显示绘图窗口  Form2 DrawPad = new Form2(); DrawPad.Show(); //新建画布  Graphics graphics = DrawPad.CreateGraphics(); //翻转默认坐标系  graphics.TranslateTransform(0, DrawPad.Height); graphics.ScaleTransform(1, -1); //对原始数组排序  Array.Sort(array); //计算各区域的值  int[] counts = new int[N]; int index = 0; for (int i = 0; i \u0026lt; N; ++i) { for (int j = index; j \u0026lt; array.Length; ++j) { if (array[j] \u0026lt;= (r - l) * (i + 1) / N) { counts[i]++; index++; } else { break; } } } //获取最大值  double max = counts.Max(); //计算间距  double unit = DrawPad.Width / (3.0 * N + 1); //计算直方图的矩形  Rectangle[] rects = new Rectangle[N]; rects[0].X = (int)unit; rects[0].Y = 0; rects[0].Width = (int)(2 * unit); rects[0].Height = (int)((counts[0] / max) * DrawPad.Height); for (int i = 1; i \u0026lt; N; ++i) { rects[i].X = (int)(rects[i - 1].X + 3 * unit); rects[i].Y = 0; rects[i].Width = (int)(2 * unit); rects[i].Height = (int)((counts[i] / (max + 1)) * DrawPad.Height); } //绘图  graphics.FillRectangles(Brushes.Black, rects); //释放资源  graphics.Dispose(); } "},{"id":32,"href":"/1-1-33/","title":"1.1.33","section":"帮助","content":"1.1.33 #  解答 #  这里矩阵使用交错数组实现（方便取行向量），不是普通的二维数组。\n矩阵和矩阵、矩阵和向量、向量和矩阵都使用行向量点乘列向量的方式计算。\n代码 #  public class Matrix { /// \u0026lt;summary\u0026gt;  /// 计算两个向量的点积  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;需要点乘的向量\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;y\u0026#34;\u0026gt;需要点乘的另一个向量\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;返回点乘的结果\u0026lt;/returns\u0026gt;  /// \u0026lt;exception cref=\u0026#34;FormatException\u0026#34;\u0026gt;\u0026lt;/exception\u0026gt;  public static double Dot(double[] x, double[] y) { //确保两向量等长  if (x.Length != y.Length) { throw new FormatException(\u0026#34;the length of two vectors must be equal\u0026#34;); } //点乘  double result = 0; for (int i = 0; i \u0026lt; x.Length; ++i) { result += x[i] * y[i]; } return result; } /// \u0026lt;summary\u0026gt;  /// 计算两个矩阵相乘的结果，返回一个矩阵  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;用交错数组表示的 m * p 矩阵\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;用交错数组表示的 p * n 矩阵\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;返回 m * n 的矩阵\u0026lt;/returns\u0026gt;  /// \u0026lt;exception cref=\u0026#34;FormatException\u0026#34;\u0026gt;\u0026lt;/exception\u0026gt;  /// \u0026lt;example\u0026gt;  /// a = {(1,2,3),(4,5,6)}  /// b = {(1,4),(2,5),(3,6)}  /// Mult(a, b) = {(14,32),(32,77)}  /// \u0026lt;/example\u0026gt;  public static double[][] Mult(double[][] a, double[][] b) { if (a[0].Length != b.GetLength(0)) { throw new FormatException(\u0026#34;a\u0026#39;s column number must be equal to b\u0026#39;s row number\u0026#34;); } int m = a.GetLength(0); int n = b[0].Length; int p = a[0].Length; double[][] result = new double[m][]; for (int i = 0; i \u0026lt; m; ++i) { double[] resultrow = new double[n]; for (int j = 0; j \u0026lt; n; ++j) { //result[i][j] = 行向量 a[i] 与列向量 b[j] 的点积  double[] row = a[i]; double[] col = new double[p]; //取得列向量  for (int k = 0; k \u0026lt; p; ++k) { col[k] = b[k][j]; } //点积  resultrow[j] = Dot(row, col); } result[i] = resultrow; } return result; } /// \u0026lt;summary\u0026gt;  /// 将一个矩阵转置  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待转置的矩阵\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;返回转置后的数组\u0026lt;/returns\u0026gt;  public static double[][] Transpose(double[][] a) { double[][] trans = new double[a[0].Length][]; for (int i = 0; i \u0026lt; a[0].Length; ++i) { double[] row = new double[a.GetLength(0)]; for (int j = 0; j \u0026lt; a.GetLength(0); ++j) { row[j] = a[j][i]; } trans[i] = row; } return trans; } /// \u0026lt;summary\u0026gt;  /// 计算矩阵与向量的乘积  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;左乘的矩阵\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;列向量\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;返回一个向量\u0026lt;/returns\u0026gt;  /// \u0026lt;exception cref=\u0026#34;FormatException\u0026#34;\u0026gt;\u0026lt;/exception\u0026gt;  public static double[] Mult(double[][] a, double[] x) { if (a[0].Length != x.Length) { throw new FormatException(\u0026#34;a\u0026#39;s column number must be equal to x\u0026#39;s length\u0026#34;); } double[] result = new double[a.GetLength(0)]; for (int i = 0; i \u0026lt; a.GetLength(0); ++i) { result[i] = Dot(a[i], x); } return result; } /// \u0026lt;summary\u0026gt;  /// 计算向量与矩阵的乘积  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;行向量\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;矩阵\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;返回一个向量\u0026lt;/returns\u0026gt;  /// \u0026lt;exception cref=\u0026#34;FormatException\u0026#34;\u0026gt;\u0026lt;/exception\u0026gt;  public static double[] Mult(double[] x, double[][] a) { if (a.GetLength(0) != x.Length) { throw new FormatException(\u0026#34;a\u0026#39;s column number must be equal to x\u0026#39;s length\u0026#34;); } double[] result = new double[a[0].Length]; for (int i = 0; i \u0026lt; a[0].Length; ++i) { double[] colVector = new double[a.GetLength(0)]; for (int j = 0; j \u0026lt; colVector.Length; ++j) { colVector[j] = a[j][i]; } result[i] = Dot(x, colVector); } return result; } /// \u0026lt;summary\u0026gt;  /// 在控制台上输出矩阵  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要输出的矩阵\u0026lt;/param\u0026gt;  public static void PrintMatrix(double[][] a) { for (int i = 0; i \u0026lt; a.GetLength(0); ++i) { for (int j = 0; j \u0026lt; a[i].Length; ++j) { Console.Write($\u0026#34;\\t{a[i][j]}\u0026#34;); } Console.Write(\u0026#34;\\n\u0026#34;); } } /// \u0026lt;summary\u0026gt;  /// 在控制台上输出一行向量  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要输出的向量\u0026lt;/param\u0026gt;  public static void PrintVector(double[] a) { for (int i = 0; i \u0026lt; a.Length; ++i) { Console.Write($\u0026#34;\\t{a[i]}\u0026#34;); } Console.Write(\u0026#34;\\n\u0026#34;); } } "},{"id":33,"href":"/1-1-34/","title":"1.1.34","section":"帮助","content":"1.1.34 #  解答 #  第二个以及最后三个需要，其他都可以设计成过滤器的模式。\n这里的 largeW.txt 只需要保留前 100 个数字就可以了，太多的话最后两个测试会刷屏。\n代码 #  static void Main(string[] args) { string[] AllNumbers = File.ReadAllLines(\u0026#34;largeW.txt\u0026#34;); int N = AllNumbers.Length; int[] input = new int[N]; for (int i = 0; i \u0026lt; N; ++i) { input[i] = int.Parse(AllNumbers[i]); } MinAndMax(input); Console.WriteLine(); MidNumber(input); Console.WriteLine(); NumberK(4, input); Console.WriteLine(); SquareSum(input); Console.WriteLine(); AboveAverage(input); Console.WriteLine(); Ascending(input); Console.WriteLine(); Shuffle(input); Console.WriteLine(); } /// \u0026lt;summary\u0026gt; /// 获取最大值和最小值 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;input\u0026#34;\u0026gt;输入流\u0026lt;/param\u0026gt; static void MinAndMax(int[] input) { //只用到了两个变量  int min = input[0]; int max = input[0]; //只对输入值正向遍历一遍，不需要保存  for (int i = 1; i \u0026lt; input.Length; ++i) { if (input[i] \u0026gt; max) { max = input[i]; } if (input[i] \u0026lt; min) { min = input[i]; } } Console.WriteLine(\u0026#34;Min and Max:\u0026#34;); Console.WriteLine($\u0026#34;Min: {min}\\nMax: {max}\u0026#34;); } /// \u0026lt;summary\u0026gt; /// 获取中位数 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;input\u0026#34;\u0026gt;输入流\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;中位数\u0026lt;/returns\u0026gt; static int MidNumber(int[] input) { //需要对输入值进行去重 \u0026amp; 排序，故需要保存  List\u0026lt;int\u0026gt; DistinctNumbers = new List\u0026lt;int\u0026gt;(input.Distinct()); DistinctNumbers.Sort(); Console.WriteLine(\u0026#34;MidNumber:\u0026#34;); Console.WriteLine(DistinctNumbers[DistinctNumbers.Count / 2]); return DistinctNumbers[DistinctNumbers.Count / 2]; } /// \u0026lt;summary\u0026gt; /// 获取第 k 小的数 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要获取的排名\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;input\u0026#34;\u0026gt;输入流\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;第 k 小的数\u0026lt;/returns\u0026gt; static int NumberK (int k, int[] input) { int[] temp = new int[101]; //只正向遍历一遍，不需要保存  for (int i = 0; i \u0026lt; input.Length; ++i) { if (i \u0026lt; 100) { temp[i] = input[i]; } else { temp[100] = input[i]; Array.Sort(temp); } } Console.WriteLine(\u0026#34;NumberK\u0026#34;); Console.WriteLine($\u0026#34;No.k: {temp[k - 1]}\u0026#34;); return temp[k - 1]; } /// \u0026lt;summary\u0026gt; /// 计算输入流中所有数的平方和 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;input\u0026#34;\u0026gt;输入流\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;所有数的平方和\u0026lt;/returns\u0026gt; static long SquareSum(int[] input) { long sum = 0; //只正向遍历一遍，不需要保存  for (int i = 0; i \u0026lt; input.Length; ++i) { sum += input[i] * input[i]; } Console.WriteLine(\u0026#34;Sum Of Square:\u0026#34;); Console.WriteLine(sum); return sum; } /// \u0026lt;summary\u0026gt; /// 计算所有输入数据的平均值 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;input\u0026#34;\u0026gt;输入流\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;所有输入数据的平均值\u0026lt;/returns\u0026gt; static double Average(int[] input) { long sum = 0; //只遍历一遍，且不保存整个数组  for (int i = 0; i \u0026lt; input.Length; ++i) { sum += input[i]; } double ave = sum / (double)input.Length; Console.WriteLine(\u0026#34;Average:\u0026#34;); Console.WriteLine(ave); return ave; } /// \u0026lt;summary\u0026gt; /// 计算大于平均值的元素数量 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;input\u0026#34;\u0026gt;输入流\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;大于平均值的元素数量\u0026lt;/returns\u0026gt; static double AboveAverage(int[] input) { double ave = Average(input); Console.WriteLine(); double count = 0; for (int i = 0; i \u0026lt; input.Length; ++i) { if (input[i] \u0026gt; ave) { count++; } } Console.WriteLine(\u0026#34;AboveAverage:\u0026#34;); Console.WriteLine($\u0026#34;{(count / input.Length) * 100}%\u0026#34;); return count; } /// \u0026lt;summary\u0026gt; /// 升序打印数组 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;input\u0026#34;\u0026gt;输入流\u0026lt;/param\u0026gt; static void Ascending(int[] input) { Array.Sort(input); Console.WriteLine(\u0026#34;Ascending:\u0026#34;); for (int i = 0; i \u0026lt; input.Length; ++i) { Console.Write($\u0026#34; {input[i]}\u0026#34;); } Console.Write(\u0026#34;\\n\u0026#34;); } /// \u0026lt;summary\u0026gt; /// 随机打印数组 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;input\u0026#34;\u0026gt;输入流\u0026lt;/param\u0026gt; static void Shuffle(int[] input) { Random random = new Random(); List\u0026lt;int\u0026gt; All = new List\u0026lt;int\u0026gt;(input); int N = input.Length; int temp = 0; Console.WriteLine(\u0026#34;Shuffle:\u0026#34;); for (int i = 0; i \u0026lt; N; ++i) { temp = random.Next(0, All.Count - 1); Console.Write($\u0026#34; {All[temp]}\u0026#34;); All.RemoveAt(temp); } } "},{"id":34,"href":"/1-1-35/","title":"1.1.35","section":"帮助","content":"1.1.35 #  解答 #  这里用 Random 类模拟掷骰子并计算概率，最后和程序得出的比较。\n代码 #  //程序运行大概需要十几秒时间（也可能更长，看运气） //我的数据： //24098 44448 37776 44401 32541 static void Main(string[] args) { //书中给出的程序  int SIDES = 6; double[] dist = new double[2 * SIDES + 1]; for (int i = 1; i \u0026lt;= SIDES; i++) for (int j = 1; j \u0026lt;= SIDES; j++) dist[i + j] += 1.0; for (int k = 2; k \u0026lt;= 2 * SIDES; k++) dist[k] /= 36.0; //不断进行模拟，直至误差小于 0.001  int N = 36; bool isAccepted = false; double[] disttemp = null; double error = 0.001; while (isAccepted == false) { disttemp = PlayDice(N); isAccepted = true; for (int i = 0; i \u0026lt; disttemp.Length; ++i) { if (Math.Abs(disttemp[i] - dist[i]) \u0026gt;= error) isAccepted = false; } N++; } Console.WriteLine($\u0026#34;N:{N}\\n\u0026#34;); for (int i = 0; i \u0026lt; dist.Length; ++i) { Console.WriteLine($\u0026#34;{i}:\\n Standerd:{dist[i]}\\nSimulated:{disttemp[i]}\\nOffset:{Math.Abs(disttemp[i] - dist[i])}\u0026#34;); } } //利用随机数模拟掷骰子 static double[] PlayDice(int N) { Random random = new Random(); int SIDES = 6; double[] dist = new double[2 * SIDES + 1]; //掷 N 次  int sumtemp = 0; for (int i = 0; i \u0026lt; N; ++i) { sumtemp = random.Next(1, 7) + random.Next(1, 7); dist[sumtemp]++; } //计算概率  for (int i = 0; i \u0026lt; dist.Length; ++i) { dist[i] /= N; } return dist; } "},{"id":35,"href":"/1-1-36/","title":"1.1.36","section":"帮助","content":"1.1.36 #  解答 #  N 取到 1000 左右数据就比较明显了。\nN = 1000， M = 10\n代码 #  static void Main(string[] args) { int M = 10;//数组大小  int N = 1000;//打乱次数  int[] a = new int[10]; int[,] result = new int[M, M]; for (int i = 0; i \u0026lt; N; ++i) { //初始化  for (int j = 0; j \u0026lt; a.Length; ++j) { a[j] = j; } //打乱  Shuffle(a, i); //记录  for (int j = 0; j \u0026lt; M; ++j) { result[a[j], j]++; } } PrintMatrix(result); } /// \u0026lt;summary\u0026gt; /// 打乱数组 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;seed\u0026#34;\u0026gt;用于生成随机数的种子值\u0026lt;/param\u0026gt; static void Shuffle(int[] a, int seed) { int N = a.Length; Random random = new Random(seed); for (int i = 0; i \u0026lt; N; ++i) { int r = i + random.Next(N - i);//等于StdRandom.uniform(N-i)  int temp = a[i]; a[i] = a[r]; a[r] = temp; } } /// \u0026lt;summary\u0026gt; /// 在控制台上输出矩阵 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要输出的矩阵\u0026lt;/param\u0026gt; public static void PrintMatrix(int[,] a) { for (int i = 0; i \u0026lt; a.GetLength(0); ++i) { for (int j = 0; j \u0026lt; a.GetLength(1); ++j) { Console.Write($\u0026#34;\\t{a[i,j]}\u0026#34;); } Console.Write(\u0026#34;\\n\u0026#34;); } } "},{"id":36,"href":"/1-1-37/","title":"1.1.37","section":"帮助","content":"1.1.37 #  解答 #  使用 0~N-1 的随机数会导致每次交换的数字可能相同。\n例如：\n原数组： 1 2 3 4。\n第一次： 2 1 3 4\nrandom = 1，第 0 个和第 1 个交换。\n第二次： 1 2 3 4\nrandom = 0，第 1 个和第 0 个交换。\n代码 #  static void Main(string[] args) { int M = 10;//数组大小  int N = 100000;//打乱次数  int[] a = new int[10]; int[,] result = new int[M, M]; for (int i = 0; i \u0026lt; N; ++i) { //初始化  for (int j = 0; j \u0026lt; a.Length; ++j) { a[j] = j; } //打乱  Shuffle(a, i); //记录  for (int j = 0; j \u0026lt; M; ++j) { result[a[j], j]++; } } PrintMatrix(result); } /// \u0026lt;summary\u0026gt; /// 打乱数组（不够好的版本） /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;seed\u0026#34;\u0026gt;用于生成随机数的种子值\u0026lt;/param\u0026gt; static void Shuffle(int[] a, int seed) { int N = a.Length; Random random = new Random(seed); for (int i = 0; i \u0026lt; N; ++i) { //int r = i + random.Next(N - i);  int r = random.Next(N); //返回的是 0 ~ N-1 之间的随机整数  int temp = a[i]; a[i] = a[r]; a[r] = temp; } } /// \u0026lt;summary\u0026gt; /// 在控制台上输出矩阵 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要输出的矩阵\u0026lt;/param\u0026gt; public static void PrintMatrix(int[,] a) { for (int i = 0; i \u0026lt; a.GetLength(0); ++i) { for (int j = 0; j \u0026lt; a.GetLength(1); ++j) { Console.Write($\u0026#34;\\t{a[i, j]}\u0026#34;); } Console.Write(\u0026#34;\\n\u0026#34;); } } "},{"id":37,"href":"/1-1-38/","title":"1.1.38","section":"帮助","content":"1.1.38 #  解答 #  为了使差距比较明显，故意取了比较靠后的数字。\n代码 #  static void Main(string[] args) { string[] largeWString = File.ReadAllLines(\u0026#34;largeW.txt\u0026#34;); int[] largeW = new int[largeWString.Length]; for (int i = 0; i \u0026lt; largeW.Length; ++i) { largeW[i] = int.Parse(largeWString[i]); } Stopwatch timer = Stopwatch.StartNew(); BruteForceSearch(111111, largeW); Console.WriteLine($\u0026#34;BruteForceSearch: {timer.ElapsedMilliseconds} ms\u0026#34;); timer.Restart(); rank(111111, largeW); Console.WriteLine($\u0026#34;BinarySearch: {timer.ElapsedMilliseconds} ms\u0026#34;); string[] largeTString = File.ReadAllLines(\u0026#34;largeT.txt\u0026#34;); int[] largeT = new int[largeTString.Length]; for (int i = 0; i \u0026lt; largeW.Length; ++i) { largeT[i] = int.Parse(largeTString[i]); } timer.Restart(); BruteForceSearch(111111, largeT); Console.WriteLine($\u0026#34;BruteForceSearch: {timer.ElapsedMilliseconds} ms\u0026#34;); timer.Restart(); rank(111111, largeT); Console.WriteLine($\u0026#34;BinarySearch: {timer.ElapsedMilliseconds} ms\u0026#34;); } //暴力查找 public static int BruteForceSearch(int key, int[] a) { for (int i = 0; i \u0026lt; a.Length; ++i) { if (a[i] == key) return i; } return -1; } //重载方法，用于启动二分查找 public static int rank(int key, int[] a) { return rank(key, a, 0, a.Length - 1, 1); } //二分查找 public static int rank(int key, int[] a, int lo, int hi, int number) { if (lo \u0026gt; hi) { return -1; } int mid = lo + (hi - lo) / 2; if (key \u0026lt; a[mid]) { return rank(key, a, lo, mid - 1, number + 1); } else if (key \u0026gt; a[mid]) { return rank(key, a, mid + 1, hi, number + 1); } else { return mid; } } 另请参阅 #  LargeW.txt\nLargeT.txt\n"},{"id":38,"href":"/1-1-39/","title":"1.1.39","section":"帮助","content":"1.1.39 #  解答 #  按照要求编程就好，视机器不同需要的时间也不同。\n代码 #  //需要 6 秒左右的运算时间 static void Main(string[] args) { Random r = new Random(); int baseNum = 10; int powNum = 3; int T = 10; int M = 4; double[,] Matrix = new double[M,2]; for (int i = 0; i \u0026lt; M; ++i) { int N = (int)Math.Pow(baseNum, powNum + i); double sum = 0; for (int j = 0; j \u0026lt; T; ++j) { sum += Test(N, r.Next()); } Matrix[i, 0] = N; Matrix[i, 1] = sum / T; } PrintMatrix(Matrix); } /// \u0026lt;summary\u0026gt; /// 执行一次“实验” /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;N\u0026#34;\u0026gt;数组的大小\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;seed\u0026#34;\u0026gt;随机种子\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;返回相同数字的数目\u0026lt;/returns\u0026gt; static int Test(int N, int seed) { Random random = new Random(seed); int[] a = new int[N]; int[] b = new int[N]; int count = 0; for (int i = 0; i \u0026lt; N; ++i) { a[i] = random.Next(100000, 1000000); b[i] = random.Next(100000, 1000000); } for (int i = 0; i \u0026lt; N; ++i) { if (rank(a[i], b) != -1) count++; } return count; } //重载方法，用于启动二分查找 public static int rank(int key, int[] a) { return rank(key, a, 0, a.Length - 1, 1); } //二分查找 public static int rank(int key, int[] a, int lo, int hi, int number) { if (lo \u0026gt; hi) { return -1; } int mid = lo + (hi - lo) / 2; if (key \u0026lt; a[mid]) { return rank(key, a, lo, mid - 1, number + 1); } else if (key \u0026gt; a[mid]) { return rank(key, a, mid + 1, hi, number + 1); } else { return mid; } } /// \u0026lt;summary\u0026gt; /// 在控制台上输出矩阵 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要输出的矩阵\u0026lt;/param\u0026gt; public static void PrintMatrix(double[,] a) { for (int i = 0; i \u0026lt; a.GetLength(0); ++i) { for (int j = 0; j \u0026lt; a.GetLength(1); ++j) { Console.Write($\u0026#34;\\t{a[i, j]}\u0026#34;); } Console.Write(\u0026#34;\\n\u0026#34;); } } "},{"id":39,"href":"/1-2-1/","title":"1.2.1","section":"帮助","content":"1.2.1 #  解答 #  这里自己实现了一个 Point2D 类（包含在了 Geometry 库中）。\nJAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Point2D.java.html。\n求最近两点只需要反复调用 Point2D 类中的 DistTo() 方法就可以了。\n代码 #  Point2D 类 #  /// \u0026lt;summary\u0026gt; /// Point2D 二维点类。 /// \u0026lt;/summary\u0026gt; public sealed class Point2D : IComparable\u0026lt;Point2D\u0026gt; { public readonly static Comparer\u0026lt;Point2D\u0026gt; X_Order = new XOrder(); public readonly static Comparer\u0026lt;Point2D\u0026gt; Y_Order = new YOrder(); public readonly static Comparer\u0026lt;Point2D\u0026gt; R_Order = new ROrder(); public double X { get; } public double Y { get; } public int Radius { get; set; } public Point2D(double x, double y) { if (double.IsInfinity(x) || double.IsInfinity(y)) { throw new ArgumentException(\u0026#34;x, y must be finite\u0026#34;); } if (double.IsNaN(x) || double.IsNaN(y)) { throw new ArgumentNullException(\u0026#34;Coordinate cannot be NaN\u0026#34;); } this.X = x; this.Y = y; this.Radius = 2; } /// \u0026lt;summary\u0026gt;  /// 返回极半径。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public double R() { return Math.Sqrt(X * X + Y * Y); } /// \u0026lt;summary\u0026gt;  /// 返回极角。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public double Theta() { return Math.Atan2(Y, X); } /// \u0026lt;summary\u0026gt;  /// 返回两个点之间的角度。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;that\u0026#34;\u0026gt;要计算角度的另一个点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private double AngleTo(Point2D that) { double dx = that.X - this.X; double dy = that.Y - this.Y; return Math.Atan2(dy, dx); } /// \u0026lt;summary\u0026gt;  /// 判断 a,b,c 三个点的关系，如果 {顺时针, 共线, 逆时针} 则返回 {-1, 0, 1}。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;第一个点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;第二个点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;c\u0026#34;\u0026gt;第三个点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static int CCW(Point2D a, Point2D b, Point2D c) { double area2 = (b.X - a.X) * (c.Y - a.Y) - (b.Y - a.Y) * (c.X - a.X); if (area2 \u0026lt; 0) return -1; if (area2 \u0026gt; 0) return 1; return 0; } /// \u0026lt;summary\u0026gt;  /// 返回 abc 三个点构成的三角形的面积的平方。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;第一个点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;第二个点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;c\u0026#34;\u0026gt;第三个点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static double Area2(Point2D a, Point2D b, Point2D c) { return (b.X - a.X) * (c.Y - a.Y) - (b.Y - a.Y) * (c.X - a.X); } /// \u0026lt;summary\u0026gt;  /// 返回当前点到另一个点之间的距离。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;that\u0026#34;\u0026gt;另一个点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public double DistanceTo(Point2D that) { double dx = this.X - that.X; double dy = this.Y - that.Y; return Math.Sqrt(dx * dx + dy * dy); } /// \u0026lt;summary\u0026gt;  /// 返回当前点到另一个点之间的距离的平方。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;that\u0026#34;\u0026gt;另一个点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public double DistanceSquareTo(Point2D that) { double dx = this.X - that.X; double dy = this.Y - that.Y; return dx * dx + dy * dy; } /// \u0026lt;summary\u0026gt;  /// 绘制二维点。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;g\u0026#34;\u0026gt;原点在左下方，y轴向上，x轴向右的画布。\u0026lt;/param\u0026gt;  public void Draw(Graphics g) { g.FillEllipse(Brushes.Black, (int)X, (int)Y, Radius, Radius); } /// \u0026lt;summary\u0026gt;  /// 实现 IComparable 接口。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;需要比较的另一个对象。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int CompareTo(Point2D other) { if (this.Y \u0026lt; other.Y) return -1; if (this.Y \u0026gt; other.Y) return 1; if (this.X \u0026lt; other.X) return -1; if (this.X \u0026gt; other.X) return 1; return 0; } /// \u0026lt;summary\u0026gt;  /// 按照 X 顺序比较。  /// \u0026lt;/summary\u0026gt;  private class XOrder : Comparer\u0026lt;Point2D\u0026gt; { public override int Compare(Point2D x, Point2D y) { if (x.X \u0026lt; y.X) { return -1; } if (x.X \u0026gt; y.X) { return 1; } return 0; } } /// \u0026lt;summary\u0026gt;  /// 按照 Y 顺序比较。  /// \u0026lt;/summary\u0026gt;  private class YOrder : Comparer\u0026lt;Point2D\u0026gt; { public override int Compare(Point2D x, Point2D y) { if (x.Y \u0026lt; y.Y) { return -1; } if (x.Y \u0026gt; y.Y) { return 1; } return 0; } } /// \u0026lt;summary\u0026gt;  /// 按照极径顺序比较。  /// \u0026lt;/summary\u0026gt;  private class ROrder : Comparer\u0026lt;Point2D\u0026gt; { public override int Compare(Point2D x, Point2D y) { double delta = (x.X * x.X + x.Y * x.Y) - (y.X * y.X + y.Y * y.Y); if (delta \u0026lt; 0) { return -1; } if (delta \u0026gt; 0) { return 1; } return 0; } } /// \u0026lt;summary\u0026gt;  /// 按照 atan2 值顺序比较。  /// \u0026lt;/summary\u0026gt;  private class Atan2Order : Comparer\u0026lt;Point2D\u0026gt; { private Point2D parent; public Atan2Order() { } public Atan2Order(Point2D parent) { this.parent = parent; } public override int Compare(Point2D x, Point2D y) { double angle1 = parent.AngleTo(x); double angle2 = parent.AngleTo(y); if (angle1 \u0026lt; angle2) { return -1; } else if (angle1 \u0026gt; angle2) { return 1; } else { return 0; } } } /// \u0026lt;summary\u0026gt;  /// 按照极角顺序比较。  /// \u0026lt;/summary\u0026gt;  private class PolorOrder : Comparer\u0026lt;Point2D\u0026gt; { private Point2D parent; public PolorOrder() { } public PolorOrder(Point2D parent) { this.parent = parent; } public override int Compare(Point2D q1, Point2D q2) { double dx1 = q1.X - parent.X; double dy1 = q1.Y - parent.Y; double dx2 = q2.X - parent.X; double dy2 = q2.Y - parent.Y; if (dy2 \u0026gt;= 0 \u0026amp;\u0026amp; dy2 \u0026lt; 0) { return -1; } else if (dy2 \u0026gt;= 0 \u0026amp;\u0026amp; dy1 \u0026lt; 0) { return 1; } else if (dy1 == 0 \u0026amp;\u0026amp; dy2 == 0) { if (dx1 \u0026gt;= 0 \u0026amp;\u0026amp; dx2 \u0026lt; 0) { return -1; } else if (dx2 \u0026gt;= 0 \u0026amp;\u0026amp; dx1 \u0026lt; 0) { return 1; } else { return 0; } } else { return -CCW(this.parent, q1, q2); } } } /// \u0026lt;summary\u0026gt;  /// 按照距离顺序比较。  /// \u0026lt;/summary\u0026gt;  private class DistanceToOrder : Comparer\u0026lt;Point2D\u0026gt; { private Point2D parent; public DistanceToOrder() { } public DistanceToOrder(Point2D parent) { this.parent = parent; } public override int Compare(Point2D p, Point2D q) { double dist1 = parent.DistanceSquareTo(p); double dist2 = parent.DistanceSquareTo(q); if (dist1 \u0026lt; dist2) { return -1; } else if (dist1 \u0026gt; dist2) { return 1; } else { return 0; } } } public Comparer\u0026lt;Point2D\u0026gt; Polor_Order() { return new PolorOrder(this); } public Comparer\u0026lt;Point2D\u0026gt; Atan2_Order() { return new Atan2Order(this); } public Comparer\u0026lt;Point2D\u0026gt; DistanceTo_Order() { return new DistanceToOrder(this); } public override bool Equals(object obj) { if (obj == this) { return true; } if (obj == null) { return false; } if (obj.GetType() != this.GetType()) { return false; } Point2D that = (Point2D)obj; return this.X == that.X \u0026amp;\u0026amp; this.Y == that.Y; } public override string ToString() { return \u0026#34;(\u0026#34; + X + \u0026#34;, \u0026#34; + Y + \u0026#34;)\u0026#34;; } public override int GetHashCode() { int hashX = X.GetHashCode(); int hashY = Y.GetHashCode(); return 31 * hashX + hashY; } } Main #  namespace _1._2._1 { /* * 1.2.1 * * 编写一个 Point2D 的用例，从命令行接受一个整数 N。 * 在单位正方形中生成 N 个随机点，然后计算两点之间的最近距离。 * */ class Program { static void Main(string[] args) { Console.WriteLine(\u0026#34;Type the value of N:\u0026#34;); int N = int.Parse(Console.ReadLine()); List\u0026lt;Point2D\u0026gt; pointlist = new List\u0026lt;Point2D\u0026gt;(); Random random = new Random(); if (N \u0026lt;= 2) { Console.WriteLine(\u0026#34;Make sure there are 2 points at least\u0026#34;); return; } //random.NextDouble() 返回一个 0~1 之间的 double 值  for (int i = 0; i \u0026lt; N; ++i) { double x = random.NextDouble(); double y = random.NextDouble(); pointlist.Add(new Point2D(x, y)); } double min = pointlist[0].DistanceTo(pointlist[1]); for (int i = 0; i \u0026lt; N; ++i) { for (int j = i + 1; j \u0026lt; N; ++j) { double temp = pointlist[i].DistanceTo(pointlist[j]); Console.WriteLine($\u0026#34;Checking Distance({i}, {j}): {temp}\u0026#34;); if (temp \u0026lt; min) { min = temp; } } } Console.WriteLine($\u0026#34;\\nThe minimal distance is {min}\u0026#34;); } } } 另请参阅 #  Geometry 库\n"},{"id":40,"href":"/1-2-2/","title":"1.2.2","section":"帮助","content":"1.2.2 #  解答 #  同样实现了一个 Interval1D 类（位于 Geometry 库）。\nJAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Interval1D.java.html。\n直接调用其中的 Intersect() 方法即可\n代码 #  Interval1D 类： #  namespace Geometry { /// \u0026lt;summary\u0026gt;  /// 一维闭区间。  /// \u0026lt;/summary\u0026gt;  public class Interval1D { public static readonly Comparer\u0026lt;Interval1D\u0026gt; Min_Order = new MinEndpointComparer(); public static readonly Comparer\u0026lt;Interval1D\u0026gt; Max_Order = new MaxEndpointComparer(); public static readonly Comparer\u0026lt;Interval1D\u0026gt; Length_Order = new LengthComparer(); public double Min { get; } public double Max { get; } /// \u0026lt;summary\u0026gt;  /// 构造函数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;一维区域的下界。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;一维区域的上界。\u0026lt;/param\u0026gt;  public Interval1D(double lo, double hi) { if (double.IsInfinity(lo) || double.IsInfinity(hi)) { throw new ArgumentException(\u0026#34;Endpoints must be finite\u0026#34;); } if (double.IsNaN(lo) || double.IsNaN(hi)) { throw new ArgumentException(\u0026#34;Endpoints cannot be NaN\u0026#34;); } if (lo \u0026lt;= hi) { this.Min = lo; this.Max = hi; } else { throw new ArgumentException(\u0026#34;Illegal interval\u0026#34;); } } /// \u0026lt;summary\u0026gt;  /// 一维区域的长度。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;返回长度。\u0026lt;/returns\u0026gt;  public double Length() { return this.Max - this.Min; } /// \u0026lt;summary\u0026gt;  /// 判断目标区间是否被本区间包含。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;that\u0026#34;\u0026gt;需要判断是否被包含的区间。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool Contains(Interval1D that) { return this.Min \u0026lt; that.Min \u0026amp;\u0026amp; this.Max \u0026gt; that.Max; } /// \u0026lt;summary\u0026gt;  /// 目标值是否处在区域内。如果目标值在区域内则返回 True，否则返回 False。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;需要判断的值。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool Contains(double x) { return x \u0026gt;= this.Min \u0026amp;\u0026amp; x \u0026lt;= this.Max; } /// \u0026lt;summary\u0026gt;  /// 判断两个区域是否相交。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;that\u0026#34;\u0026gt;需要判断相交的另一个区域。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;如果相交则返回 True，否则返回 False。\u0026lt;/returns\u0026gt;  public bool Intersect(Interval1D that) { if (this.Max \u0026lt; that.Min || that.Max \u0026lt; this.Min) return false; return true; } /// \u0026lt;summary\u0026gt;  /// 绘制一维区间。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;g\u0026#34;\u0026gt;原点在左下方，y轴向上，x轴向右的画布。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;y\u0026#34;\u0026gt;绘制一维区间的 y轴 坐标。\u0026lt;/param\u0026gt;  public void Draw(Graphics g, int y) { Point A = new Point((int)Min, y); Point B = new Point((int)Max, y); g.DrawLine(Pens.Black, A, B); } /// \u0026lt;summary\u0026gt;  /// 将区域转换为 string，返回形如 \u0026#34;[lo, hi]\u0026#34; 的字符串。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public override string ToString() { string s = \u0026#34;[\u0026#34; + this.Min + \u0026#34;, \u0026#34; + this.Max + \u0026#34;]\u0026#34;; return s; } /// \u0026lt;summary\u0026gt;  /// 判断两个区间是否相等。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;obj\u0026#34;\u0026gt;相比较的区间。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public override bool Equals(object obj) { if (obj == this) { return true; } if (obj == null) { return false; } if (obj.GetType() != this.GetType()) { return false; } Interval1D that = (Interval1D)obj; return this.Min == that.Min \u0026amp;\u0026amp; this.Max == that.Max; } /// \u0026lt;summary\u0026gt;  /// 返回区间的哈希代码。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public override int GetHashCode() { int hash1 = Min.GetHashCode(); int hash2 = Max.GetHashCode(); return 31 * hash1 + hash2; } private class MinEndpointComparer : Comparer\u0026lt;Interval1D\u0026gt; { public override int Compare(Interval1D a, Interval1D b) { if (a.Min \u0026lt; b.Min) { return -1; } else if (a.Min \u0026gt; b.Min) { return 1; } else if (a.Max \u0026lt; b.Max) { return -1; } else if (a.Max \u0026gt; b.Max) { return 1; } else { return 0; } } } private class MaxEndpointComparer : Comparer\u0026lt;Interval1D\u0026gt; { public override int Compare(Interval1D a, Interval1D b) { if (a.Max \u0026lt; b.Max) { return -1; } else if (a.Max \u0026gt; b.Max) { return 1; } else if (a.Min \u0026lt; b.Min) { return -1; } else if (a.Min \u0026gt; b.Min) { return 1; } else { return 0; } } } private class LengthComparer : Comparer\u0026lt;Interval1D\u0026gt; { public override int Compare(Interval1D a, Interval1D b) { double alen = a.Length(); double blen = b.Length(); if (alen \u0026lt; blen) { return -1; } else if (alen \u0026gt; blen) { return 1; } else { return 0; } } } } } Main 方法 #  namespace _1._2._2 { /* * 1.2.2 * * 编写一个 Interval1D 的用例，从命令行接受一个整数 N。 * 从标准输入中读取 N 个间隔（每个间隔由一对 double 值定义）并打印出所有相交的间隔对。 * */ class Program { static void Main(string[] args) { Console.WriteLine(\u0026#34;Type the value of N:\u0026#34;); int N = int.Parse(Console.ReadLine()); List\u0026lt;Interval1D\u0026gt; intervalList = new List\u0026lt;Interval1D\u0026gt;(); if (N \u0026lt; 2) { Console.WriteLine(\u0026#34;Make sure there are at least 2 Intervals\u0026#34;); return; } //读取并建立间隔数组  Console.WriteLine(\u0026#34;Type the data, make sure there is a space between two numbers.\\nExample: 0.5 1\u0026#34;); for (int i = 0; i \u0026lt; N; ++i) { string temp = Console.ReadLine(); double lo = double.Parse(temp.Split(\u0026#39; \u0026#39;)[0]); double hi = double.Parse(temp.Split(\u0026#39; \u0026#39;)[1]); if (lo \u0026gt; hi) { double t = lo; lo = hi; hi = t; } intervalList.Add(new Interval1D(lo, hi)); } //判断是否相交并输出  for (int i = 0; i \u0026lt; N; ++i) { for (int j = i + 1; j \u0026lt; N; ++j) { if (intervalList[i].Intersect(intervalList[j])) { Console.WriteLine($\u0026#34;{intervalList[i].ToString()} {intervalList[j].ToString()}\u0026#34;); } } } } } } 另请参阅 #  Geometry 库\n"},{"id":41,"href":"/1-2-3/","title":"1.2.3","section":"帮助","content":"1.2.3 #  解答 #  首先先实现一个 Interval2D 类（位于 Geometry 库），再使用窗体应用程序绘图。\nJAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Interval2D.java.html。\n代码 #  Interval2D： #  using System.Drawing; namespace Geometry { /// \u0026lt;summary\u0026gt;  /// 二维闭合区间。  /// \u0026lt;/summary\u0026gt;  public class Interval2D { private readonly Interval1D X; private readonly Interval1D Y; /// \u0026lt;summary\u0026gt;  /// 构造函数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;x 轴上的范围。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;y\u0026#34;\u0026gt;y 轴上的范围。\u0026lt;/param\u0026gt;  public Interval2D(Interval1D x, Interval1D y) { this.X = x; this.Y = y; } /// \u0026lt;summary\u0026gt;  /// 判断两个平面是否相交。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;that\u0026#34;\u0026gt;需要判断的另一个平面。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool Intersects(Interval2D that) { if (!this.X.Intersect(that.X)) { return false; } if (!this.Y.Intersect(that.Y)) { return false; } return true; } /// \u0026lt;summary\u0026gt;  /// 判断目标区间是否被本区间包含。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;that\u0026#34;\u0026gt;需要判断是否被包含的区间。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool Contains(Interval2D that) { return this.X.Contains(that.X) \u0026amp;\u0026amp; this.Y.Contains(that.Y); } /// \u0026lt;summary\u0026gt;  /// 判断一个二维点是否在该平面范围内。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要判断的二维点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool Contains(Point2D p) { return (this.X.Contains(p.X) \u0026amp;\u0026amp; this.Y.Contains(p.Y)); } /// \u0026lt;summary\u0026gt;  /// 计算平面范围的面积。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public double Area() { return this.X.Length() * this.Y.Length(); } /// \u0026lt;summary\u0026gt;  /// 在画布上绘制二维区间。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;g\u0026#34;\u0026gt;原点在左下方，x轴向右，y轴向上的画布。\u0026lt;/param\u0026gt;  public void Draw(Graphics g) { Rectangle rect = new Rectangle((int)this.X.Min, (int)this.Y.Min, (int)this.X.Length(), (int)this.Y.Length()); g.DrawRectangle(Pens.White, rect); g.FillRectangle(Brushes.Black, rect); } /// \u0026lt;summary\u0026gt;  /// 返回形如“[xmin, xmax] x [ymin, ymax]”的字符串。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public override string ToString() { return X + \u0026#34;x\u0026#34; + Y; } /// \u0026lt;summary\u0026gt;  /// 判断两个二维区间是否相等。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;obj\u0026#34;\u0026gt;需要比较的另一个区间。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public override bool Equals(object obj) { if (obj == this) { return true; } if (obj == null) { return false; } if (obj.GetType() != this.GetType()) { return false; } Interval2D that = (Interval2D)obj; return this.X.Equals(that.X) \u0026amp;\u0026amp; this.Y.Equals(that.Y); } /// \u0026lt;summary\u0026gt;  /// 获取哈希值  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public override int GetHashCode() { int hash1 = this.X.GetHashCode(); int hash2 = this.Y.GetHashCode(); return 31 * hash1 + hash2; } } } 绘图方法 #  /// \u0026lt;summary\u0026gt; /// 主绘图函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;N\u0026#34;\u0026gt;2D 间隔的数目。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;Min\u0026#34;\u0026gt;分布范围的下界。（大于 0 且小于 1）\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;Max\u0026#34;\u0026gt;分布范围的上界。（大于 0 且小于 1）\u0026lt;/param\u0026gt; public static void StartDrawing(int N, double Min, double Max) { Interval2D[] list = new Interval2D[N]; Random random = new Random(); //开始绘图  Form2 drawPad = new Form2(); drawPad.Show(); Graphics graphics = drawPad.CreateGraphics(); //生成随机二维间隔  for (int i = 0; i \u0026lt; N; ++i) { double x = random.NextDouble() * (Max - Min) + Min; double y = random.NextDouble() * (Max - Min) + Min; if (x \u0026gt;= y) { double temp = x; x = y; y = temp; } x *= drawPad.ClientRectangle.Width; y *= drawPad.ClientRectangle.Width; Interval1D tempx = new Interval1D(x, y); x = random.NextDouble() * (Max - Min) + Min; y = random.NextDouble() * (Max - Min) + Min; if (x \u0026gt;= y) { double temp = x; x = y; y = temp; } x *= drawPad.ClientRectangle.Height; y *= drawPad.ClientRectangle.Height; Interval1D tempy = new Interval1D(x, y); list[i] = new Interval2D(tempx, tempy); } //计算相交和包含的数量  int intersectNum = 0; for (int i = 0; i \u0026lt; N; ++i) { for (int j = i + 1; j \u0026lt; N; ++j) { if (list[i].Intersects(list[j])) { intersectNum++; } } } int containsNum = 0; for (int i = 0; i \u0026lt; N; ++i) { for (int j = 0; j \u0026lt; N; ++j) { if (i == j) continue; if (list[i].Contains(list[j])) { containsNum++; } } } //移动原点至左下方，翻转坐标系  graphics.TranslateTransform(0, drawPad.ClientRectangle.Height); graphics.ScaleTransform(1, -1); //绘制所有区间  foreach (Interval2D n in list) { n.Draw(graphics); } //新建一个窗口，显示计算结果  MessageBox.Show($\u0026#34;相交的区间数：{intersectNum}, 包含的区间数：{containsNum}\u0026#34;); //清理资源  graphics.Dispose(); } 另请参阅 #  Geometry 库\n"},{"id":42,"href":"/1-2-4/","title":"1.2.4","section":"帮助","content":"1.2.4 #  解答 #  在 C# 中，这段代码能够完成交换的工作，输出为：\nworld hello 代码 #  using System; namespace _1._2._4 { /* * 1.2.4 * * 以下这段代码会打印出什么？ * String string1 = \u0026#34;hello\u0026#34;; * String string2 = string1; * string1 = \u0026#34;world\u0026#34;; * StdOut.println(string1); * StdOut.println(string2); * */ class Program { static void Main(string[] args) { string string1 = \u0026#34;hello\u0026#34;; string string2 = string1; string1 = \u0026#34;world\u0026#34;; Console.WriteLine(string1); Console.WriteLine(string2); } } } "},{"id":43,"href":"/1-2-5/","title":"1.2.5","section":"帮助","content":"1.2.5 #  解答 #  string 类型中的 Uppercase() 以及 Substring() 都不会改变原有字符串，而是新建一个字符串。\n因此输出仍然为 Hello World。\n代码 #  using System; namespace _1._2._5 { /* * 1.2.5 * * 以下这段代码会打印出什么？ * String s = \u0026#34;Hello World\u0026#34;; * s.toUpperCase(); * s.substring(6, 11); * StdOut.println(s); * */ class Program { static void Main(string[] args) { string s = \u0026#34;Hello World\u0026#34;; s.ToUpper(); s.Substring(6, 5);//C# 中两个参数分别代表子串起始下标和长度  Console.WriteLine(s); } } } "},{"id":44,"href":"/1-2-6/","title":"1.2.6","section":"帮助","content":"1.2.6 #  解答 #  对于任意字符串 s，将其拆分成 s = s1 + s2（s2长度即为循环移动的位数） 其回环变位则为 s' = s2 + s1\n显然 s' + s' = s2 + s1 + s2 + s1\n即 s' + s' = s2 + s + s1，其中必定包含 s\n例如 ABC 和 BCA， BCABCA 显然包含 ABC\n代码 #  using System; namespace _1._2._6 { /* * 1.2.6 * * 如果字符串 s 中的字符循环移动任意位置之后能够得到另一个字符串 t， * 那么 s 就被称为 t 的回环变位（circular rotation）。 * 例如，ACTGACG 就是 TGACGAC 的一个回环变位，反之亦然。 * 判定这个条件在基因组序列的研究中是很重要的。 * 编写一个程序检查两个给定的字符串 s 和 t 是否互为回环变位。 * 提示：答案只需要一行用到 indexOf()、length() 和字符串连接的代码。 * */ class Program { static void Main(string[] args) { string s1 = \u0026#34;ACTGACG\u0026#34;; string s2 = \u0026#34;TGACGAC\u0026#34;; Console.WriteLine(Circular(s1, s2)); } //对于任意字符串 s，将其拆分成 s = s1 + s2（s2长度即为循环移动的位数）  //其回环变位则为 s\u0026#39; = s2 + s1  //显然 s\u0026#39; + s\u0026#39; = s2 + s1 + s2 + s1  //即 s\u0026#39; + s\u0026#39; = s2 + s + s1，其中必定包含 s  //例如 ABC 和 BCA， BCABCA 显然包含 ABC  static bool Circular(string s1, string s2) { return s1.Length == s2.Length \u0026amp;\u0026amp; (s2 + s2).Contains(s1); } } } "},{"id":45,"href":"/1-2-7/","title":"1.2.7","section":"帮助","content":"1.2.7 #  解答 #  递归交换字符顺序，最后返回反序的字符串。\nMystery(ABCD)=\nMystery(CD) + Mystery(AB)=\nMystery(D) + Mystery(C) + Mystery(B) + Mystery(A)=\nDCBA\n代码 #  using System; namespace _1._2._7 { /* * 1.2.7 * * 以下递归函数的返回值是什么？ * public static String mystery(String s) * { * int N = s.length(); * if (N \u0026lt;= 1) return s; * String a = s.substring(0, N/2); * String b = s.substring(N/2, N); * return mystery(b) + mystery(a); * } * */ class Program { static void Main(string[] args) { Console.WriteLine(Mystery(\u0026#34;Hello1\u0026#34;)); } /// \u0026lt;summary\u0026gt;  /// 输出反向字符串。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;s\u0026#34;\u0026gt;原字符串。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static string Mystery(string s) { int N = s.Length; if (N \u0026lt;= 1) return s; string a = s.Substring(0, N / 2); string b = s.Substring(N / 2, N - N / 2); return Mystery(b) + Mystery(a); } } } "},{"id":46,"href":"/1-2-8/","title":"1.2.8","section":"帮助","content":"1.2.8 #  解答 #  作用就是交换两个数组。\n但在 C# 或 JAVA 中，数组变量实际是数组的一个引用（类似于指针），交换两个引用的效率与数组大小无关，都是常数时间的。\n代码 #  using System; using System.IO; namespace _1._2._8 { /* * 1.2.8 * * 设 a[] 和 b[] 均为长数百万的整型数组。以下代码的作用是什么？有效吗？ * int[] t = a; a = b; b = t; * */ class Program { static void Main(string[] args) { //读取 largeW.txt  string[] allNums = File.ReadAllLines(\u0026#34;largeW.txt\u0026#34;); int N = allNums.Length; int[] a = new int[N]; int[] b = new int[N]; //数组 a 与数组 b 数字顺序相反  for (int i = 0; i \u0026lt; N; ++i) { a[i] = int.Parse(allNums[i]); b[N - i - 1] = a[i]; } //输出前5个数字  Console.WriteLine(\u0026#34;Before Swap\u0026#34;); Console.Write(\u0026#34;a:\u0026#34;); for (int i = 0; i \u0026lt; 5; ++i) { Console.Write($\u0026#34; {a[i]}\u0026#34;); } Console.WriteLine(); Console.Write(\u0026#34;b:\u0026#34;); for (int i = 0; i \u0026lt; 5; ++i) { Console.Write($\u0026#34; {b[i]}\u0026#34;); } Console.WriteLine(); //交换  int[] t = a; a = b; b = t; //再次输出  Console.WriteLine(\u0026#34;After Swap\u0026#34;); Console.Write(\u0026#34;a:\u0026#34;); for (int i = 0; i \u0026lt; 5; ++i) { Console.Write($\u0026#34; {a[i]}\u0026#34;); } Console.WriteLine(); Console.Write(\u0026#34;b:\u0026#34;); for (int i = 0; i \u0026lt; 5; ++i) { Console.Write($\u0026#34; {b[i]}\u0026#34;); } Console.WriteLine(); } } } "},{"id":47,"href":"/1-2-9/","title":"1.2.9","section":"帮助","content":"1.2.9 #  解答 #  首先实现一个 Counter 类，随后使用非递归版本的 BinarySearch，每进行一次 While 循环就让 Counter 加一。\n代码 #  Counter 类\nnamespace _1._2._9 { /// \u0026lt;summary\u0026gt;  /// 计数器类  /// \u0026lt;/summary\u0026gt;  class Counter { private readonly string name; private int count; /// \u0026lt;summary\u0026gt;  /// 构造函数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;id\u0026#34;\u0026gt;计数器的名称。\u0026lt;/param\u0026gt;  public Counter(string id) { this.name = id; } /// \u0026lt;summary\u0026gt;  /// 计数器加一。  /// \u0026lt;/summary\u0026gt;  public void Increment() { count++; } /// \u0026lt;summary\u0026gt;  /// 获取当前计数值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Tally() { return count; } /// \u0026lt;summary\u0026gt;  /// 输出形如 “1 counter” 的字符串。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public override string ToString() { return count + \u0026#34; \u0026#34; + name; } } } Main 方法\nusing System; using System.IO; namespace _1._2._9 { /* * 1.2.9 * * 修改 BinarySearch（请见 1.1.10.1 节中的二分查找代码）， * 使用 Counter 统计在有查找中被检查的键的总数并在查找全部结束后打印该值。 * 提示：在 main() 中创建一个 Counter 对象并将它作为参数传递给 rank() * */ class Program { //参考 1.1.10 节的代码  static void Main(string[] args) { Counter count = new Counter(\u0026#34;BinarySearch\u0026#34;); //读取白名单  string[] whiteListString = File.ReadAllLines(\u0026#34;tinyW.txt\u0026#34;); int[] whiteList = new int[whiteListString.Length]; for (int i = 0; i \u0026lt; whiteListString.Length; ++i) { whiteList[i] = int.Parse(whiteListString[i]); } Array.Sort(whiteList); //读取查询值  string[] inputListString = File.ReadAllLines(\u0026#34;tinyT.txt\u0026#34;); int[] inputList = new int[inputListString.Length]; for (int i = 0; i \u0026lt; inputListString.Length; ++i) { inputList[i] = int.Parse(inputListString[i]); } //对每一个查询值进行二分查找  foreach (int n in inputList) { int result = rank(n, whiteList, count); //将不在白名单上的数据输出  if (result == -1) { Console.WriteLine(n); } } Console.WriteLine(); //输出查询数目  Console.WriteLine(count.Tally()); } static int rank(int key, int[] a, Counter count) { int lo = 0; int hi = a.Length - 1; while (lo \u0026lt;= hi) { int mid = lo + (hi - lo) / 2; count.Increment(); if (key \u0026lt; a[mid]) { hi = mid - 1; } else if (key \u0026gt; a[mid]) { lo = mid + 1; } else { return mid; } } return -1; } } } "},{"id":48,"href":"/1-2-10/","title":"1.2.10","section":"帮助","content":"1.2.10 #  解答 #  在 Counter 类基础上修改即可。\n代码 #  VisualCounter 类\nusing System.Drawing; namespace _1._2._10 { /// \u0026lt;summary\u0026gt;  /// 可视化计数器  /// \u0026lt;/summary\u0026gt;  class VisualCounter { private readonly string name; private int count; private int max; private int operatorTimes; /// \u0026lt;summary\u0026gt;  /// 构造函数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;id\u0026#34;\u0026gt;计数器的名称。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;max\u0026#34;\u0026gt;计数器的最大值。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;operatorTimes\u0026#34;\u0026gt;计数器的最大操作数。\u0026lt;/param\u0026gt;  public VisualCounter(string id, int max, int operatorTimes) { this.name = id; this.max = max; this.operatorTimes = operatorTimes; } /// \u0026lt;summary\u0026gt;  /// 计数器加一。  /// \u0026lt;/summary\u0026gt;  public bool Increment() { if (operatorTimes \u0026lt;= 0) return false; if (count \u0026lt; max) { count++; operatorTimes--; } return true; } /// \u0026lt;summary\u0026gt;  /// 计数器减一。  /// \u0026lt;/summary\u0026gt;  public bool Decreasement() { if (operatorTimes \u0026lt;= 0) return false; if (count \u0026gt; 0) { count--; operatorTimes--; } return true; } /// \u0026lt;summary\u0026gt;  /// 获取当前计数值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Tally() { return count; } /// \u0026lt;summary\u0026gt;  /// 输出形如 “1 counter” 的字符串。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public override string ToString() { return count + \u0026#34; \u0026#34; + name; } /// \u0026lt;summary\u0026gt;  /// 绘制计数器的图形。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;g\u0026#34;\u0026gt;画布。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;width\u0026#34;\u0026gt;绘图区宽度。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;height\u0026#34;\u0026gt;绘图区高度。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;font\u0026#34;\u0026gt;显示的字体。\u0026lt;/param\u0026gt;  public void Draw(Graphics g, int width, int height, Font font) { //清空画布  g.Clear(SystemColors.Control); //将画布分为上 1/3 和下 2/3  RectangleF headPart = new RectangleF(0, 0, width, height / 3); Rectangle bodyPart = new Rectangle(0, height / 3, (height * 2) / 3, (height * 2) / 3); //绘图  g.DrawString($\u0026#34;计数：{count} 剩余操作数：{operatorTimes} 最大值：{max}\u0026#34;, font, Brushes.Black, headPart); g.FillPie(Brushes.Blue, bodyPart, 0, 360 * (float)count / max); } } } Form2\nusing System; using System.Drawing; using System.Windows.Forms; namespace _1._2._10 { public partial class Form2 : Form { VisualCounter counter; Graphics graphics; public Form2(int N, int max) { InitializeComponent(); counter = new VisualCounter(\u0026#34;count\u0026#34;, max, N); graphics = this.PaintArea.CreateGraphics(); } private void button1_Click(object sender, EventArgs e) { if (!counter.Increment()) { this.ErrorLabel.Text = \u0026#34;操作数不足\u0026#34;; } else { this.ErrorLabel.Text = \u0026#34;\u0026#34;; counter.Draw(graphics,this.PaintArea.Width, this.PaintArea.Height, this.Font); } } private void button2_Click(object sender, EventArgs e) { if (!counter.Decreasement()) { this.ErrorLabel.Text = \u0026#34;操作数不足\u0026#34;; } else { this.ErrorLabel.Text = \u0026#34;\u0026#34;; counter.Draw(graphics, this.PaintArea.Width, this.PaintArea.Height, this.Font); } } } } "},{"id":49,"href":"/1-2-11/","title":"1.2.11","section":"帮助","content":"1.2.11 #  解答 #  在构造函数开始时做一次判断，非法时抛出异常。\n首先建立一个数组，数组的第 1 项至第 12 项的值就是每个月的天数。\n再声明一个布尔类型的变量，用于标记是否是闰年。\n代码 #  using System; namespace _1._2._11 { class SmartDate { public int Month { get; }//月  public int Day { get; }//日  public int Year { get; }//年  //每个月对应的天数，第 0 位空出来  static private int[] dayOfMonth = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; public SmartDate(int m, int d, int y) { if (Vaildation(m, d, y) == false) throw new FormatException(\u0026#34;Invaild Date\u0026#34;); this.Month = m; this.Day = d; this.Year = y; } private bool Vaildation(int m, int d, int y) { if (y \u0026lt; 0) return false; bool isLeapYear = false; if (m \u0026gt; 12 || m \u0026lt; 1) return false; if (d \u0026lt; 0) return false; if (m == 2 \u0026amp;\u0026amp; d \u0026gt; 29 \u0026amp;\u0026amp; isLeapYear) return false; if (d \u0026gt; dayOfMonth[m]) return false; return true; } private bool IsLeapYear(int y) { if (y % 400 == 0) return true; if (y % 100 != 0 \u0026amp;\u0026amp; y % 4 == 0) return true; return false; } public override string ToString() { return this.Month + \u0026#34;/\u0026#34; + this.Day + \u0026#34;/\u0026#34; + this.Year; } } } "},{"id":50,"href":"/1-2-12/","title":"1.2.12","section":"帮助","content":"1.2.12 #  解答 #  这里使用蔡勒公式来推算星期。\n参考：http://www.cnblogs.com/mq0036/p/3534314.html\n代码 #  /// \u0026lt;summary\u0026gt; /// 计算当前日期是星期几，返回对应的星期名称。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public string DayOfTheWeek() { int d = this.Day; int m = this.Month; int y = this.Year; if (m \u0026lt; 3) { m += 12; y--; } //使用蔡勒公式计算，参见 http://www.cnblogs.com/mq0036/p/3534314.html  int w = (d + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400) % 7; return dayOfWeek[w]; } 另请参阅 #  蔡勒公式-维基百科\n"},{"id":51,"href":"/1-2-13/","title":"1.2.13","section":"帮助","content":"1.2.13 #  解答 #  直接实现即可。\nJAVA 版本可以参考：http://algs4.cs.princeton.edu/12oop/Transaction.java.html。\n代码 #  using System; using System.Collections.Generic; namespace Commercial { public class Transaction : IComparable\u0026lt;Transaction\u0026gt; { public string Who { get; } public Date When { get; } public double Amount { get; } /// \u0026lt;summary\u0026gt;  /// 构造函数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;transaction\u0026#34;\u0026gt;用空格隔开的形如 “姓名 日期 金额” 的字符串。\u0026lt;/param\u0026gt;  public Transaction(string transaction) { string[] a = transaction.Split(\u0026#39; \u0026#39;); Who = a[0]; When = new Date(a[1]); Amount = double.Parse(a[2]); } /// \u0026lt;summary\u0026gt;  /// 构造函数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;who\u0026#34;\u0026gt;客户姓名。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;when\u0026#34;\u0026gt;交易日期。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;amount\u0026#34;\u0026gt;交易金额。\u0026lt;/param\u0026gt;  public Transaction(string who, Date when, double amount) { if (double.IsNaN(amount) || double.IsInfinity(amount)) { throw new ArgumentException(\u0026#34;Amount cannot be NaN or Infinity\u0026#34;); } this.Who = who; this.When = when; this.Amount = amount; } /// \u0026lt;summary\u0026gt;  /// 返回字符串形式的交易信息。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public override string ToString() { return string.Format(\u0026#34;{0, -10} {1, 10} {2, 8:F2}\u0026#34;, Who, When, Amount); } /// \u0026lt;summary\u0026gt;  /// 默认按照交易金额升序比较。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;比较的另一个对象。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int CompareTo(Transaction other) { if (this.Amount \u0026lt; other.Amount) return -1; if (this.Amount \u0026gt; other.Amount) return 1; return 0; } /// \u0026lt;summary\u0026gt;  /// 按照客户姓名升序比较。  /// \u0026lt;/summary\u0026gt;  public class WhoOrder : IComparer\u0026lt;Transaction\u0026gt; { int IComparer\u0026lt;Transaction\u0026gt;.Compare(Transaction x, Transaction y) { return x.Who.CompareTo(y.Who); } } /// \u0026lt;summary\u0026gt;  /// 按照交易时间升序比较。  /// \u0026lt;/summary\u0026gt;  public class WhenOrder : IComparer\u0026lt;Transaction\u0026gt; { int IComparer\u0026lt;Transaction\u0026gt;.Compare(Transaction x, Transaction y) { return x.When.CompareTo(y.When); } } /// \u0026lt;summary\u0026gt;  /// 按照交易金额升序比较。  /// \u0026lt;/summary\u0026gt;  public class HowMuchOrder : IComparer\u0026lt;Transaction\u0026gt; { int IComparer\u0026lt;Transaction\u0026gt;.Compare(Transaction x, Transaction y) { return x.Amount.CompareTo(y.Amount); } } /// \u0026lt;summary\u0026gt;  /// 比较两笔交易是否相同。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;obj\u0026#34;\u0026gt;另一个对象。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public override bool Equals(object obj) { if (obj == this) return true; if (obj == null) return false; if (obj.GetType() != this.GetType()) return false; Transaction that = (Transaction)obj; return (that.Amount == this.Amount) \u0026amp;\u0026amp; (that.When.Equals(this.When)) \u0026amp;\u0026amp; (that.Who == this.Who); } /// \u0026lt;summary\u0026gt;  /// 返回交易信息的哈希值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public override int GetHashCode() { int hash = 1; hash = 31 * hash + Who.GetHashCode(); hash = 31 * hash + When.GetHashCode(); hash = 31 * hash + Amount.GetHashCode(); return hash; } } } 另请参阅 #  Commercial 库\n"},{"id":52,"href":"/1-2-14/","title":"1.2.14","section":"帮助","content":"1.2.14 #  解答 #  上一题中的代码已经包含了对 Equals() 方法的实现。\n代码 #  /// \u0026lt;summary\u0026gt; /// 比较两笔交易是否相同。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;obj\u0026#34;\u0026gt;另一个对象。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public override bool Equals(object obj) { if (obj == this) return true; if (obj == null) return false; if (obj.GetType() != this.GetType()) return false; Transaction that = (Transaction)obj; return (that.Amount == this.Amount) \u0026amp;\u0026amp; (that.When.Equals(this.When)) \u0026amp;\u0026amp; (that.Who == this.Who); } 另请参阅 #  Commercial 库\n"},{"id":53,"href":"/1-2-15/","title":"1.2.15","section":"帮助","content":"1.2.15 #  解答 #  这里我们基于 File.ReadAllLines() 进行实现。\n代码 #  public static int[] ReadInts(string path) { string[] allLines = File.ReadAllLines(path); int[] result = new int[allLines.Length]; for (int i = 0; i \u0026lt; allLines.Length; ++i) { result[i] = int.Parse(allLines[i]); } return result; } "},{"id":54,"href":"/1-2-16/","title":"1.2.16","section":"帮助","content":"1.2.16 #  解答 #  JAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Rational.java.html\n欧几里得算法仅适用于正整数，使用前需要注意。\n用欧几里得算法找到公因子之后直接化简即可。\n代码 #  using System; namespace _1._2._16 { public class Rational { public long Numerator { get; } public long Denominator { get; } private bool isNagative; /// \u0026lt;summary\u0026gt;  /// 构造一个有理数对象，自动变为最简形式。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;numerator\u0026#34;\u0026gt;分子。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;denominator\u0026#34;\u0026gt;分母。\u0026lt;/param\u0026gt;  /// \u0026lt;exception cref=\u0026#34;ArgumentException\u0026#34;\u0026gt;分母为 0 时抛出\u0026lt;/exception\u0026gt;  public Rational(long numerator, long denominator) { if (denominator == 0) throw new ArgumentException(\u0026#34;Denominator cannot be 0\u0026#34;); if (numerator \u0026lt; 0 \u0026amp;\u0026amp; denominator \u0026lt; 0) { isNagative = false; numerator = -numerator; denominator = -denominator; } else if (numerator \u0026lt; 0 || denominator \u0026lt; 0) { isNagative = true; } else { isNagative = false; } long gcd = GCD(Math.Abs(numerator), Math.Abs(denominator)); if (gcd != 1) { numerator /= gcd; denominator /= gcd; } this.Numerator = numerator; this.Denominator = denominator; } /// \u0026lt;summary\u0026gt;  /// 将两个有理数对象相加，返回一个有理数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;加数。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Rational Plus(Rational b) { Rational result = new Rational(this.Numerator * b.Denominator + b.Numerator * this.Denominator, this.Denominator * b.Denominator); return result; } /// \u0026lt;summary\u0026gt;  /// 以当前对象为被减数，减去一个有理数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;减数。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Rational Minus(Rational b) { Rational result = new Rational(this.Numerator * b.Denominator - b.Numerator * this.Denominator, this.Denominator * b.Denominator); return result; } /// \u0026lt;summary\u0026gt;  /// 将两个有理数对象相乘。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;乘数。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Rational Multiply(Rational b) { Rational result = new Rational(this.Numerator * b.Numerator, this.Denominator * b.Denominator); return result; } /// \u0026lt;summary\u0026gt;  /// 以当前有理数为被除数，除以一个有理数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;除数。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Rational Divide(Rational b) { Rational result = new Rational(this.Numerator * b.Denominator, this.Denominator * b.Numerator); return result; } /// \u0026lt;summary\u0026gt;  /// 求两个正整数的最大公约数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;第一个整数。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;第二个整数。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private long GCD(long a, long b) { if (b == 0) return a; return GCD(b, a % b); } public override bool Equals(object obj) { if (this == obj) return true; if (obj == null) return false; if (obj.GetType() != this.GetType()) return false; Rational that = (Rational)obj; return (this.Numerator == that.Numerator) \u0026amp;\u0026amp; (this.Denominator == that.Denominator); } public override int GetHashCode() { return 31 * this.Numerator.GetHashCode() + this.Denominator.GetHashCode(); } /// \u0026lt;summary\u0026gt;  /// 返回形如 “分子/分母” 的字符串  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public override string ToString() { string result = \u0026#34;\u0026#34;; if (isNagative) result += \u0026#34;-\u0026#34;; result += Math.Abs(this.Numerator) + \u0026#34;/\u0026#34; + Math.Abs(this.Denominator); return result; } } } "},{"id":55,"href":"/1-2-17/","title":"1.2.17","section":"帮助","content":"1.2.17 #  解答 #  在 C# 中使用 checked 关键字包裹整数运算的代码即可自动检查溢出。\n在 JAVA 中可以考虑在运算前控制运算数的大小。\n例如 a + b 之前保证 long.MaxValue – b \u0026gt;= a 等等。\n代码 #  using System; namespace _1._2._17 { public class Rational { public long Numerator { get; } public long Denominator { get; } private bool isNagative; /// \u0026lt;summary\u0026gt;  /// 构造一个有理数对象，自动变为最简形式。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;numerator\u0026#34;\u0026gt;分子。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;denominator\u0026#34;\u0026gt;分母。\u0026lt;/param\u0026gt;  /// \u0026lt;exception cref=\u0026#34;ArgumentException\u0026#34;\u0026gt;分母为 0 时抛出\u0026lt;/exception\u0026gt;  public Rational(long numerator, long denominator) { if (denominator == 0) throw new ArgumentException(\u0026#34;Denominator cannot be 0\u0026#34;); if (numerator \u0026lt; 0 \u0026amp;\u0026amp; denominator \u0026lt; 0) { isNagative = false; numerator = -numerator; denominator = -denominator; } else if (numerator \u0026lt; 0 || denominator \u0026lt; 0) { isNagative = true; } else { isNagative = false; } long gcd = GCD(Math.Abs(numerator), Math.Abs(denominator)); if (gcd != 1) { numerator /= gcd; denominator /= gcd; } this.Numerator = numerator; this.Denominator = denominator; } /// \u0026lt;summary\u0026gt;  /// 将两个有理数对象相加，返回一个有理数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;加数。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Rational Plus(Rational b) { checked { Rational result = new Rational(this.Numerator * b.Denominator + b.Numerator * this.Denominator, this.Denominator * b.Denominator); return result; } } /// \u0026lt;summary\u0026gt;  /// 以当前对象为被减数，减去一个有理数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;减数。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Rational Minus(Rational b) { checked { Rational result = new Rational(this.Numerator * b.Denominator - b.Numerator * this.Denominator, this.Denominator * b.Denominator); return result; } } /// \u0026lt;summary\u0026gt;  /// 将两个有理数对象相乘。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;乘数。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Rational Multiply(Rational b) { checked { Rational result = new Rational(this.Numerator * b.Numerator, this.Denominator * b.Denominator); return result; } } /// \u0026lt;summary\u0026gt;  /// 以当前有理数为被除数，除以一个有理数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;除数。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Rational Divide(Rational b) { checked { Rational result = new Rational(this.Numerator * b.Denominator, this.Denominator * b.Numerator); return result; } } /// \u0026lt;summary\u0026gt;  /// 求两个正整数的最大公约数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;第一个整数。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;第二个整数。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private long GCD(long a, long b) { if (b == 0) return a; return GCD(b, a % b); } public override bool Equals(object obj) { if (this == obj) return true; if (obj == null) return false; if (obj.GetType() != this.GetType()) return false; Rational that = (Rational)obj; return (this.Numerator == that.Numerator) \u0026amp;\u0026amp; (this.Denominator == that.Denominator); } public override int GetHashCode() { return 31 * this.Numerator.GetHashCode() + this.Denominator.GetHashCode(); } /// \u0026lt;summary\u0026gt;  /// 返回形如 “分子/分母” 的字符串  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public override string ToString() { string result = \u0026#34;\u0026#34;; if (isNagative) result += \u0026#34;-\u0026#34;; result += Math.Abs(this.Numerator) + \u0026#34;/\u0026#34; + Math.Abs(this.Denominator); return result; } } } "},{"id":56,"href":"/1-2-18/","title":"1.2.18","section":"帮助","content":"1.2.18 #  解答 #  当数据比较大时—— 例如 10^9 加上随机小数组成的数列，这时 double 的小数精度将受限。\n求和之后整数部分更大，小数部分将自动四舍五入，出现误差\n这时再计算平均值时将会带来较大的误差。\n因此采用另一个递推公式：\nk 为下标。\n$M_k = M_{k-1}+ (x_k – M_{k-1})/k$\n$S_k = S_{k-1} + (x_k – M_{k-1})\\times(x_k – M_k)$.\n方差 $s^2 = S_k/(k – 1)$.\n这种情况下并没有直接对所有输入值求和，小数精度不会过多受到整数部分长度的影响。\n有关这两个公式的证明可以参考这篇论文，或者去查看我的知乎回答。\n代码 #  using System; namespace _1._2._18 { public class Accumulator { private double m; private double s; private int N; public void AddDataValue(double x) { N++; s = s + 1.0 * (N - 1) / N * (x - m) * (x - m); m = m + (x - m) / N; } public double Mean() { return m; } public double Var() { return s / (N - 1); } public double Stddev() { return Math.Sqrt(this.Var()); } public override string ToString() { return \u0026#34;Mean (\u0026#34; + N + \u0026#34; values): \u0026#34; + string.Format(\u0026#34;{0, 7:F5}\u0026#34;, Mean()); } } } "},{"id":57,"href":"/1-2-19/","title":"1.2.19","section":"帮助","content":"1.2.19 #  解答 #  之前的 Date 和 Transaction 已经包含了这些实现。\n代码 #  Date #  /// \u0026lt;summary\u0026gt; /// 构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;date\u0026#34;\u0026gt;形如 \u0026#34;05/31/2017\u0026#34; 的字符串。\u0026lt;/param\u0026gt; public Date(string date) { string[] a = date.Split(\u0026#39;/\u0026#39;); if (a.Length != 3) throw new ArgumentException(\u0026#34;Illgal Date\u0026#34;); Month = int.Parse(a[0]); Day = int.Parse(a[1]); Year = int.Parse(a[2]); } Transaction #  /// \u0026lt;summary\u0026gt; /// 构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;transaction\u0026#34;\u0026gt;用空格隔开的形如 “姓名 日期 金额” 的字符串。\u0026lt;/param\u0026gt; public Transaction(string transaction) { string[] a = transaction.Split(\u0026#39; \u0026#39;); Who = a[0]; When = new Date(a[1]); Amount = double.Parse(a[2]); } 另请参阅 #  Commercial 类\n"},{"id":58,"href":"/1-3-1/","title":"1.3.1","section":"帮助","content":"1.3.1 #  解答 #  首先是 FixedCapacityStackOfStrings 类，官方 JAVA 版本参考：FixedCapacityStackOfStrings.java\nIsFull() 的实现比较简单，判断 N 与数组长度是否相等即可。\n代码 #  using System; using System.Collections; using System.Collections.Generic; namespace _1._3._1 { class FixedCapacityStackOfStrings : IEnumerable\u0026lt;string\u0026gt; { private string[] a; private int N; /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;栈的大小。\u0026lt;/param\u0026gt;  public FixedCapacityStackOfStrings(int capacity) { this.a = new string[capacity]; this.N = 0; } /// \u0026lt;summary\u0026gt;  /// 检查栈是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.N == 0; } /// \u0026lt;summary\u0026gt;  /// 检查栈是否已满。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsFull() { return this.N == this.a.Length; } /// \u0026lt;summary\u0026gt;  /// 将一个元素压入栈中。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要压入栈中的元素。\u0026lt;/param\u0026gt;  public void Push(string item) { this.a[N] = item; this.N++; } /// \u0026lt;summary\u0026gt;  /// 从栈中弹出一个元素，返回被弹出的元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public string Pop() { this.N--; return this.a[N]; } /// \u0026lt;summary\u0026gt;  /// 返回栈顶元素（但不弹出它）。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public string Peek() { return this.a[N - 1]; } public IEnumerator\u0026lt;string\u0026gt; GetEnumerator() { return new ReverseEnmerator(this.a); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class ReverseEnmerator : IEnumerator\u0026lt;string\u0026gt; { private int current; private string[] a; public ReverseEnmerator(string[] a) { this.current = a.Length; this.a = a; } string IEnumerator\u0026lt;string\u0026gt;.Current =\u0026gt; a[current]; object IEnumerator.Current =\u0026gt; a[current]; void IDisposable.Dispose() { this.current = -1; this.a = null; } bool IEnumerator.MoveNext() { if (this.current == 0) return false; this.current--; return true; } void IEnumerator.Reset() { this.current = a.Length; } } } } "},{"id":59,"href":"/1-3-2/","title":"1.3.2","section":"帮助","content":"1.3.2 #  解答 #  首先是 Stack\u0026lt;\u0026gt; 类的实现，官方 JAVA 版本参考：Stack.java\n输出内容：was best times of the was the it\n代码 #  using System; using System.Collections; using System.Collections.Generic; using System.Text; namespace Generics { public class Stack\u0026lt;Item\u0026gt; : IEnumerable\u0026lt;Item\u0026gt; { private Node\u0026lt;Item\u0026gt; first; private int count; /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public Stack() { this.first = null; this.count = 0; } /// \u0026lt;summary\u0026gt;  /// 复制构造函数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;s\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  public Stack(Stack\u0026lt;Item\u0026gt; s) { if (s.first != null) { this.first = new Node\u0026lt;Item\u0026gt;(s.first); for (Node\u0026lt;Item\u0026gt; x = this.first; x.next != null; x = x.next) { x.next = new Node\u0026lt;Item\u0026gt;(x.next); } } } /// \u0026lt;summary\u0026gt;  /// 检查栈是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.first == null; } /// \u0026lt;summary\u0026gt;  /// 返回栈内元素的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() { return this.count; } /// \u0026lt;summary\u0026gt;  /// 将一个元素压入栈中。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要压入栈中的元素。\u0026lt;/param\u0026gt;  public void Push(Item item) { Node\u0026lt;Item\u0026gt; oldFirst = this.first; this.first = new Node\u0026lt;Item\u0026gt;(); this.first.item = item; this.first.next = oldFirst; this.count++; } /// \u0026lt;summary\u0026gt;  /// 将一个元素从栈中弹出，返回弹出的元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Pop() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Stack Underflow\u0026#34;); Item item = this.first.item; this.first = this.first.next; this.count--; return item; } /// \u0026lt;summary\u0026gt;  /// 返回栈顶元素（但不弹出它）。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Peek() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Stack Underflow\u0026#34;); return this.first.item; } /// \u0026lt;summary\u0026gt;  /// 将两个栈连接。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;s1\u0026#34;\u0026gt;第一个栈。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;s2\u0026#34;\u0026gt;第二个栈（将被删除）。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static Stack\u0026lt;Item\u0026gt; Catenation(Stack\u0026lt;Item\u0026gt; s1, Stack\u0026lt;Item\u0026gt; s2) { if (s1.IsEmpty()) { s1.first = s2.first; s1.count = s2.count; } else { Node\u0026lt;Item\u0026gt; last = s1.first; while (last.next != null) { last = last.next; } last.next = s2.first; s1.count += s2.count; } s2 = null; return s1; } /// \u0026lt;summary\u0026gt;  /// 创建栈的浅表副本。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Stack\u0026lt;Item\u0026gt; Copy() { Stack\u0026lt;Item\u0026gt; temp = new Stack\u0026lt;Item\u0026gt;(); temp.first = this.first; temp.count = this.count; return temp; } public override string ToString() { StringBuilder s = new StringBuilder(); foreach (Item n in this) { s.Append(n); s.Append(\u0026#39; \u0026#39;); } return s.ToString(); } public IEnumerator\u0026lt;Item\u0026gt; GetEnumerator() { return new StackEnumerator(this.first); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class StackEnumerator : IEnumerator\u0026lt;Item\u0026gt; { private Node\u0026lt;Item\u0026gt; current; private Node\u0026lt;Item\u0026gt; first; public StackEnumerator(Node\u0026lt;Item\u0026gt; first) { this.current = new Node\u0026lt;Item\u0026gt;(); this.current.next = first; this.first = this.current; } Item IEnumerator\u0026lt;Item\u0026gt;.Current =\u0026gt; current.item; object IEnumerator.Current =\u0026gt; current.item; void IDisposable.Dispose() { this.current = null; this.first = null; } bool IEnumerator.MoveNext() { if (this.current.next == null) return false; this.current = this.current.next; return true; } void IEnumerator.Reset() { this.current = this.first; } } } } 另请参阅 #  Generics 库\n"},{"id":60,"href":"/1-3-3/","title":"1.3.3","section":"帮助","content":"1.3.3 #  解答 #  这个问题的通用解法见习题 1.3.46 的解答。\n第 2、6、7 个不可能产生，可以画个栈模拟一下。\n第 2 个\n​ 输出数 栈内数\n4 0~3\n6 0~3 + 5\n8 0~3 + 5 + 7\n7 0~3 + 5\n5 0~3\n3 0~2\n2 0~1\n9 0~1\n0 Error\n第 6 个\n输出数 栈内数\n0 null\n4 1~3\n6 1~3 + 5\n5 1~3\n3 1~2\n8 1~2 + 7\n1 Error\n第 7 个\n输出数 栈内数\n1 0\n4 0 + 2~3\n7 0 + 2~3 + 5~6\n9 0 + 2~3 + 5~6 + 8\n8 0 + 2~3 + 5~6\n6 0 + 2~3 + 5\n5 0 + 2~3\n3 0 + 2\n0 Error\n"},{"id":61,"href":"/1-3-4/","title":"1.3.4","section":"帮助","content":"1.3.4 #  解答 #  官方 JAVA 版本参考：Parentheses.java。\n遇到左括号就入栈，遇到右括号就检查是否和栈顶的左括号匹配，如果匹配则弹栈，否则返回 false。\n结束时如果栈不为空则返回 false，否则返回 true。\n代码 #  using System; using Generics; namespace _1._3._4 { /* * 1.3.4 * * 编写一个 Stack 的用例 Parentheses， * 从标准输入中读取一个文本流并使用栈判定其中的括号是否配对完整。 * 例如，对于 [()]{}{[()()]()} 程序应该打印 true， * 对于 [(]) 则打印 false。 * */ class Parentheses { static bool isBalanced(string input) { Stack\u0026lt;char\u0026gt; stack = new Stack\u0026lt;char\u0026gt;(); foreach (char i in input) { if (i == \u0026#39;(\u0026#39; || i == \u0026#39;[\u0026#39; || i == \u0026#39;{\u0026#39;) stack.Push(i); else { if (stack.Peek() == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; i == \u0026#39;)\u0026#39;) stack.Pop(); else if (stack.Peek() == \u0026#39;{\u0026#39; \u0026amp;\u0026amp; i == \u0026#39;}\u0026#39;) stack.Pop(); else if (stack.Peek() == \u0026#39;[\u0026#39; \u0026amp;\u0026amp; i == \u0026#39;]\u0026#39;) stack.Pop(); else return false; } } return stack.IsEmpty(); } static void Main(string[] args) { string input = \u0026#34;[()]{}{[()()]()}\u0026#34;; Console.WriteLine(isBalanced(input)); string input2 = \u0026#34;[(])\u0026#34;; Console.WriteLine(isBalanced(input2)); } } } 另请参阅 #  Generics 库\n"},{"id":62,"href":"/1-3-5/","title":"1.3.5","section":"帮助","content":"1.3.5 #  解答 #  实际上是用除二取余法求一个十进制数的二进制形式。\n代码 #  using System; using Generics; namespace _1._3._5 { /* * 1.3.5 * * 当 N 为 50 时下面这段代码会打印什么？ * 从较高的抽象层次描述给定正整数 N 时这段代码的行为。 * */ class Program { //将十进制数 N 转换为二进制数。  static void Main(string[] args) { int N = 50; Stack\u0026lt;int\u0026gt; stack = new Stack\u0026lt;int\u0026gt;(); while (N \u0026gt; 0) { stack.Push(N % 2); N = N / 2; } foreach (int d in stack) { Console.WriteLine(d); } Console.WriteLine(); } } } 另请参阅 #  Generics 库\n"},{"id":63,"href":"/1-3-6/","title":"1.3.6","section":"帮助","content":"1.3.6 #  解答 #  利用一个栈对队列元素进行反序操作。\n先把队列中的元素全部入栈，再依次弹出并加入队列中。\n代码 #  using System; using Generics; namespace _1._3._6 { /* * 1.3.6 * * 下面这段代码对队列 q 进行了什么操作？ * */ class Program { //将队列反序  static void Main(string[] args) { Queue\u0026lt;string\u0026gt; q = new Queue\u0026lt;string\u0026gt;(); q.Enqueue(\u0026#34;first\u0026#34;); q.Enqueue(\u0026#34;second\u0026#34;); q.Enqueue(\u0026#34;third\u0026#34;); q.Enqueue(\u0026#34;fourth\u0026#34;); Stack\u0026lt;string\u0026gt; stack = new Stack\u0026lt;string\u0026gt;(); while (!q.IsEmpty()) stack.Push(q.Dequeue()); while (!stack.IsEmpty()) q.Enqueue(stack.Pop()); Console.WriteLine(q.ToString()); } } } 另请参阅 #  Generics 库\n"},{"id":64,"href":"/1-3-7/","title":"1.3.7","section":"帮助","content":"1.3.7 #  解答 #  链表实现的话就是返回第一个结点 first 的 item 字段。\n数组实现的话就是返回 first 对应的数组元素。\n这里给出链表实现，完整实现见习题 1.3.2 的代码。\n代码 #  /// \u0026lt;summary\u0026gt; /// 返回栈顶元素（但不弹出它）。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public Item Peek() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Stack Underflow\u0026#34;); return this.first.item; } "},{"id":65,"href":"/1-3-8/","title":"1.3.8","section":"帮助","content":"1.3.8 #  解答 #  首先是 DoublingStackOfStrings 类，据我猜测应该是用数组实现的栈，扩容时长度增加一倍，缩短时长度减小一半。\n官方 JAVA 代码参考：FixedCapacityStackOfString.java。\n代码 #  DoublingStackOfStrings 类\nusing System; using System.Collections; using System.Collections.Generic; namespace _1._3._8 { class DoublingStackOfStrings : IEnumerable\u0026lt;string\u0026gt; { private string[] items; private int count; /// \u0026lt;summary\u0026gt;  /// 新建一个字符串栈。  /// \u0026lt;/summary\u0026gt;  public DoublingStackOfStrings() { this.items = new string[2]; this.count = 0; } /// \u0026lt;summary\u0026gt;  /// 检查栈是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.count == 0; } /// \u0026lt;summary\u0026gt;  /// 返回栈中字符串的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() { return this.count; } /// \u0026lt;summary\u0026gt;  /// 向栈中压入一个字符串。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;s\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  public void Push(string s) { if (this.count == this.items.Length) Resize(this.items.Length * 2); this.items[this.count] = s; this.count++; } /// \u0026lt;summary\u0026gt;  /// 从栈中弹出一个字符串，返回被弹出的元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public string Pop() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Stack underflow\u0026#34;); count--; //缩小长度  if (count \u0026gt; 0 \u0026amp;\u0026amp; count \u0026lt;= items.Length / 4) Resize(items.Length / 2); return items[count]; } /// \u0026lt;summary\u0026gt;  /// 返回栈顶元素（但不弹出它）。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public string Peek() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Stack underflow\u0026#34;); return items[count - 1]; } /// \u0026lt;summary\u0026gt;  /// 为栈重新分配空间，超出空间的元素将被舍弃。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capcity\u0026#34;\u0026gt;重新分配的空间大小。\u0026lt;/param\u0026gt;  private void Resize(int capcity) { string[] temp = new string[capcity]; for (int i = 0; i \u0026lt; this.count; ++i) { temp[i] = items[i]; } items = temp; } public IEnumerator\u0026lt;string\u0026gt; GetEnumerator() { return new StackEnumerator(this.items); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class StackEnumerator : IEnumerator\u0026lt;string\u0026gt; { int current; string[] items; public StackEnumerator(string[] items) { this.items = items; current = -1; } string IEnumerator\u0026lt;string\u0026gt;.Current =\u0026gt; this.items[this.current]; object IEnumerator.Current =\u0026gt; this.items[this.current]; void IDisposable.Dispose() { this.items = null; this.current = -1; } bool IEnumerator.MoveNext() { if (this.current == items.Length - 1) return false; this.current++; return true; } void IEnumerator.Reset() { this.current = -1; } } } } 主函数\nusing System; namespace _1._3._8 { /* * 1.3.8 * * 给定以下输入，给出 DoublingStackOfStrings 的数组的内容和大小。 * * it was - the best - of times - - - it was - the - - * */ class Program { static void Main(string[] args) { DoublingStackOfStrings stack = new DoublingStackOfStrings(); string[] input = \u0026#34;it was - the best - of times - - - it was - the - -\u0026#34;.Split(\u0026#39; \u0026#39;); foreach (string n in input) { if (n == \u0026#34;-\u0026#34;) stack.Pop(); else stack.Push(n); } foreach (string s in stack) { Console.Write(s + \u0026#39; \u0026#39;); } Console.WriteLine($\u0026#34;\\nStack Size: {stack.Size()}\u0026#34;); } } } "},{"id":66,"href":"/1-3-9/","title":"1.3.9","section":"帮助","content":"1.3.9 #  解答 #  在计算中序表达式算法的基础上做修改。\n压入数字时将该数字所在的位置也一并压入。\n弹出数字进行运算时在位置靠前的数字前加上左括号。\nA + B ) * C + D ) ) 为例。\nA 压入栈中并记录位置 。\n\u0026lsquo;+\u0026rsquo; 压入栈中。\nB 压入栈中并记录位置。\n) 计算，在 A 之前加入左括号，结果 E 压入栈中，位置为 A 的位置。\n\u0026lsquo;*\u0026rsquo; 压入栈中。\nC 压入栈中并记录位置。\n\u0026lsquo;+\u0026rsquo; 压入栈中。\nD 压入栈中并记录位置。\n) 计算，在 C 之前加入左括号，结果 F 压入栈中，位置为 C 的位置。\n) 计算，在 E 之前加入左括号（也就是 A 之前），结果 G 压入栈中，位置为 E 的位置。\n代码 #  using System; using Generics; namespace _1._3._9 { /* * 1.3.9 * * 编写一段程序，从标准输入得到一个缺少左括号的表达式并打印出补全括号之后的中序表达式。 * 例如，给定输入： * 1 + 2 ) * 3 - 4 ) * 5 - 6 ) ) ) * 你的程序应该输出： * ( ( 1 + 2 ) * ( ( 3 - 4 ) * ( 5 - 6 ) ) ) * */ class Program { //在计算中序表达式算法的基础上做修改  //压入数字时将该数字所在的位置也一并压入  //弹出数字进行运算时在位置靠前的数字前加上左括号  //A + B ) * C + D ) ) 为例  //A 压入栈中并记录位置  //+ 压入栈中  //B 压入栈中并记录位置  //) 计算，在 A 之前加入左括号，结果 E 压入栈中，位置为 A 的位置  //* 压入栈中  //C 压入栈中并记录位置  //+ 压入栈中  //D 压入栈中并记录位置  //) 计算，在 C 之前加入左括号，结果 F 压入栈中，位置为 C 的位置  //) 计算，在 E 之前加入左括号（也就是 A 之前），结果 G 压入栈中，位置为 E 的位置。  static void Main(string[] args) { string input = \u0026#34;1 + 2 ) * 3 - 4 ) * 5 - 6 ) ) )\u0026#34;; Stack\u0026lt;char\u0026gt; operators = new Stack\u0026lt;char\u0026gt;(); Stack\u0026lt;Number\u0026gt; numbers = new Stack\u0026lt;Number\u0026gt;(); int[] leftBrackets = new int[input.Length]; for (int i = 0; i \u0026lt; input.Length; ++i) { if (input[i] == \u0026#39; \u0026#39;) continue; else if (input[i] == \u0026#39;+\u0026#39; || input[i] == \u0026#39;-\u0026#39; || input[i] == \u0026#39;*\u0026#39; || input[i] == \u0026#39;/\u0026#39;) { operators.Push(input[i]); } else if (input[i] == \u0026#39;)\u0026#39;) { Number B = numbers.Pop(); Number A = numbers.Pop(); char operation = operators.Pop(); Number C = new Number(); C.Position = A.Position; leftBrackets[A.Position]++; switch (operation) { case \u0026#39;+\u0026#39;: C.Value = A.Value + B.Value; break; case \u0026#39;-\u0026#39;: C.Value = A.Value - B.Value; break; case \u0026#39;*\u0026#39;: C.Value = A.Value * B.Value; break; case \u0026#39;/\u0026#39;: C.Value = A.Value / B.Value; break; } numbers.Push(C); } else { Number num = new Number(); num.Position = i; num.Value = input[i] - \u0026#39;0\u0026#39;; numbers.Push(num); } } for (int i = 0; i \u0026lt; input.Length; ++i) { while (leftBrackets[i] != 0) { Console.Write(\u0026#34;( \u0026#34;); leftBrackets[i]--; } Console.Write(input[i]); } } } struct Number { public int Value; public int Position; } } 另请参阅 #  Generics 库\n"},{"id":67,"href":"/1-3-10/","title":"1.3.10","section":"帮助","content":"1.3.10 #  解答 #  官方 JAVA 代码：InfixToPostfix.java。\n其实就是把右括号换成相应运算符\n对于 (A + B)，忽略左括号，数字直接输出，运算符入栈，遇到右括号时再弹出\n结果 A B +，变成后序表达式\n代码 #  using System; using Generics; namespace _1._3._10 { /* * 1.3.10 * * 编写一个过滤器 InfixToPostfix， * 将算术表达式由中序表达式转为后序表达式。 * */ class InfixToPostfix { //其实就是把右括号换成相应运算符  //对于 (A + B)，忽略左括号，数字直接输出，运算符入栈，遇到右括号时再弹出  //结果 A B +，变成后序表达式  static void Main(string[] args) { Stack\u0026lt;string\u0026gt; stack = new Stack\u0026lt;string\u0026gt;(); string[] input = \u0026#34;( 2 + ( ( 3 + 4 ) * ( 5 * 6 ) ) )\u0026#34;.Split(\u0026#39; \u0026#39;); foreach (string n in input) { if (n == \u0026#34; \u0026#34;) continue; else if (n == \u0026#34;+\u0026#34; || n == \u0026#34;-\u0026#34; || n == \u0026#34;*\u0026#34; || n == \u0026#34;/\u0026#34;) { stack.Push(n); } else if (n == \u0026#34;)\u0026#34;) { Console.Write(stack.Pop() + \u0026#34; \u0026#34;); } else if (n == \u0026#34;(\u0026#34;) { continue; } else { Console.Write(n + \u0026#34; \u0026#34;); } } Console.WriteLine(); } } } 另请参阅 #  Generics 库\n"},{"id":68,"href":"/1-3-11/","title":"1.3.11","section":"帮助","content":"1.3.11 #  解答 #  官方 JAVA 代码：EvaluatePostfix.java。\n遇到数字就入栈，遇到运算符就弹出两个数字运算，再把结果入栈。\n如果倒着读取的话也可以用递归做，当作前序表达式计算即可。\n代码 #  using System; using Generics; namespace _1._3._11 { /* * 1.3.11 * * 编写一段程序 EvaluatePostfix，从标准输入中得到一个后序表达式，求值并打印结果 * （将上一题的程序中得到的输出用管道传递给这一段程序可以得到和 Evaluate 相同的行为）。 * */ class EvaluatePostfix { static void Main(string[] args) { Stack\u0026lt;int\u0026gt; stack = new Stack\u0026lt;int\u0026gt;(); string[] input = \u0026#34;7 16 * 5 + 16 * 3 + 16 * 1 +\u0026#34;.Split(\u0026#39; \u0026#39;); foreach (string n in input) { if (n == \u0026#34; \u0026#34;) { continue; } else if (n == \u0026#34;+\u0026#34;) { stack.Push(stack.Pop() + stack.Pop()); } else if (n == \u0026#34;-\u0026#34;) { int temp = stack.Pop(); stack.Push(stack.Pop() - temp); } else if (n == \u0026#34;*\u0026#34;) { stack.Push(stack.Pop() * stack.Pop()); } else if (n == \u0026#34;/\u0026#34;) { int temp = stack.Pop(); stack.Push(stack.Pop() / temp); } else { stack.Push(int.Parse(n)); } } Console.WriteLine(stack.Pop()); } } } 另请参阅 #  Generics 库\n"},{"id":69,"href":"/1-3-12/","title":"1.3.12","section":"帮助","content":"1.3.12 #  解答 #  先用 foreach 语句遍历一遍栈，把所有元素都压入一个临时栈中。\n此时临时栈变成了源栈的一个倒序副本。\n再将临时栈中的元素依次压入目标栈中，就得到了源栈的一个副本。\n代码 #  using System; using Generics; namespace _1._3._12 { /* * 1.3.12 * * 编写一个可迭代的 Stack 用例，它含有一个静态的 CopyTo() 方法， * 接受一个字符串的栈作为参数并返回该栈的一个副本。 * 注意：这种能力是迭代器价值的一个重要体现， * 因为有了它我们无需改变基本 API 就能实现这种功能。 * */ class Program { static void Main(string[] args) { Stack\u0026lt;string\u0026gt; src = new Stack\u0026lt;string\u0026gt;(); src.Push(\u0026#34;first\u0026#34;); src.Push(\u0026#34;second\u0026#34;); src.Push(\u0026#34;third\u0026#34;); Stack\u0026lt;string\u0026gt; des = CopyTo(src); while (!des.IsEmpty()) { Console.WriteLine(des.Pop()); } } static Stack\u0026lt;string\u0026gt; CopyTo(Stack\u0026lt;string\u0026gt; src) { Stack\u0026lt;string\u0026gt; des = new Stack\u0026lt;string\u0026gt;(); Stack\u0026lt;string\u0026gt; temp = new Stack\u0026lt;string\u0026gt;(); foreach (string s in src) { temp.Push(s); } while (!temp.IsEmpty()) { des.Push(temp.Pop()); } return des; } } } 另请参阅 #  Generics 库\n"},{"id":70,"href":"/1-3-13/","title":"1.3.13","section":"帮助","content":"1.3.13 #  解答 #  除了第一个以外都不可能。\n根据题意，0 一定是最先入列的。\n那么根据队列的特性，0 一定是最先出列的，因此除第一个以外其他几个序列都不可能。\n"},{"id":71,"href":"/1-3-14/","title":"1.3.14","section":"帮助","content":"1.3.14 #  解答 #  对于 ResizingArrayQueueOfStrings 类，给出官方 JAVA 代码参考：ResizingArrayQueue.java。\n代码 #  ResizingArrayQueue 类 #  using System; using System.Collections; using System.Collections.Generic; namespace _1._3._14 { class ResizingArrayQueueOfStrings\u0026lt;Item\u0026gt; : IEnumerable\u0026lt;Item\u0026gt; { private Item[] q; private int count; private int first; private int last; public ResizingArrayQueueOfStrings() { this.q = new Item[2]; this.count = 0; this.first = 0; } public bool IsEmpty() { return this.count == 0; } public int Size() { return this.count; } private void Resize(int capacity) { if (capacity \u0026lt; 0) throw new ArgumentException(\u0026#34;capacity should be above zero\u0026#34;); Item[] temp = new Item[capacity]; for (int i = 0; i \u0026lt; count; ++i) { temp[i] = this.q[(this.first + i) % this.q.Length]; } this.q = temp; this.first = 0; this.last = this.count; } public void Enqueue(Item item) { if (this.count == this.q.Length) { Resize(this.count * 2); } this.q[this.last] = item; this.last++; if (this.last == this.q.Length) this.last = 0; this.count++; } public Item Dequeue() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Queue underflow\u0026#34;); Item item = this.q[first]; this.q[first] = default(Item); this.count--; this.first++; if (this.first == this.q.Length) this.first = 0; if (this.count \u0026gt; 0 \u0026amp;\u0026amp; this.count \u0026lt;= this.q.Length / 4) Resize(this.q.Length / 2); return item; } public Item Peek() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Queue underflow\u0026#34;); return this.q[first]; } public IEnumerator\u0026lt;Item\u0026gt; GetEnumerator() { return new QueueEnumerator(this.q, this.first, this.last); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class QueueEnumerator : IEnumerator\u0026lt;Item\u0026gt; { int current; int first; int last; Item[] q; public QueueEnumerator(Item[] q, int first, int last) { this.current = first - 1; this.first = first; this.last = last; this.q = q; } Item IEnumerator\u0026lt;Item\u0026gt;.Current =\u0026gt; this.q[this.current]; object IEnumerator.Current =\u0026gt; this.q[this.current]; void IDisposable.Dispose() { } bool IEnumerator.MoveNext() { if (this.current == this.last - 1) return false; this.current++; return true; } void IEnumerator.Reset() { this.current = this.first - 1; } } } } Program.cs #  using System; namespace _1._3._14 { /* * 1.3.14 * * 编写一个类 ResizingArrayQueueOfStrings， * 使用定长数组实现队列的抽象，然后扩展实现， * 使用调整数组的方法突破大小的限制。 * */ class Program { public static void Main(string[] args) { ResizingArrayQueueOfStrings\u0026lt;string\u0026gt; queue = new ResizingArrayQueueOfStrings\u0026lt;string\u0026gt;(); string[] input = \u0026#34;to be or not to - be - - that - - - is\u0026#34;.Split(\u0026#39; \u0026#39;); foreach (string s in input) { if (!s.Equals(\u0026#34;-\u0026#34;)) queue.Enqueue(s); else if (!queue.IsEmpty()) Console.Write(queue.Dequeue() + \u0026#39; \u0026#39;); } Console.WriteLine(\u0026#34;(\u0026#34; + queue.Size() + \u0026#34; left on queue)\u0026#34;); } } } "},{"id":72,"href":"/1-3-15/","title":"1.3.15","section":"帮助","content":"1.3.15 #  解答 #  方法有很多，只要把所有输入保存，之后算出倒数第 k 个是正数第几个就可以了。\n这里先全部入队，之后算出是正数第几个，再把前面的元素全部出队，剩下的第一个就是要求的元素了。\n代码 #  using System; using Generics; namespace _1._3._15 { /* * 1.3.15 * * 编写一个 Queue 的用例，接受一个命令行参数 k 并打印出标准输入中的倒数第 k 个字符串 * （假设标准输入中至少有 k 个字符串）。 * */ class Program { static void Main(string[] args) { Queue\u0026lt;string\u0026gt; queue = new Queue\u0026lt;string\u0026gt;(); string[] input = \u0026#34;1 2 3 4 5 6 7 8 9 10\u0026#34;.Split(\u0026#39; \u0026#39;); int k = 4; foreach(string s in input) { queue.Enqueue(s); } int count = queue.Size() - k; for(int i = 0; i \u0026lt; count; ++i) { queue.Dequeue(); } Console.WriteLine(queue.Peek()); } } } 另请参阅 #  Generics 库\n"},{"id":73,"href":"/1-3-16/","title":"1.3.16","section":"帮助","content":"1.3.16 #  解答 #  在习题 1.2.19 里已经写好了接受字符串作为参数构造函数\n这里只要把所有字符串读入并调用相应构造函数就可以了。\n代码 #  /// \u0026lt;summary\u0026gt; /// 从标准输入按行读取所有日期，返回一个日期数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static Date[] ReadDates() { char[] split = new char[] { \u0026#39;\\n\u0026#39; }; string[] input = Console.In.ReadToEnd().Split(split, StringSplitOptions.RemoveEmptyEntries); Date[] d = new Date[input.Length]; for (int i = 0; i \u0026lt; input.Length; ++i) { d[i] = new Date(input[i]); } return d; } "},{"id":74,"href":"/1-3-17/","title":"1.3.17","section":"帮助","content":"1.3.17 #  解答 #  和前一题类似，按行读取输入再调用相应构造函数就可以了。\n代码 #  /// \u0026lt;summary\u0026gt; /// 从标准输入中按行读取所有交易信息，返回一个 Transaction 数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static Transaction[] ReadTransactions() { char[] split = new char[] { \u0026#39;\\n\u0026#39; }; string[] input = Console.In.ReadToEnd().Split(split, StringSplitOptions.RemoveEmptyEntries); Transaction[] t = new Transaction[input.Length]; for (int i = 0; i \u0026lt; input.Length; ++i) { t[i] = new Transaction(input[i]); } return t; } "},{"id":75,"href":"/1-3-18/","title":"1.3.18","section":"帮助","content":"1.3.18 #  解答 #  删除该结点的下一个结点。\n如下图，没有任何结点指向 y 结点，失去了所有引用的 y 结点会被 GC 清理掉。\n代码 #  using System; using Generics; namespace _1._3._18 { /* * 1.3.18 * * 假设 x 是一条链表的某个结点且不是尾结点。 * 下面这条语句的效果是什么？ * x.next = x.next.next; * */ class Program { //删除 x 的后一个结点。  static void Main(string[] args) { Node\u0026lt;string\u0026gt; x = new Node\u0026lt;string\u0026gt;(); x.item = \u0026#34;first\u0026#34;; Node\u0026lt;string\u0026gt; y = new Node\u0026lt;string\u0026gt;(); y.item = \u0026#34;second\u0026#34;; x.next = y; Node\u0026lt;string\u0026gt; z = new Node\u0026lt;string\u0026gt;(); z.item = \u0026#34;third\u0026#34;; y.next = z; Console.WriteLine(\u0026#34;x: \u0026#34; + x.item); Console.WriteLine(\u0026#34;x.next: \u0026#34; + x.next.item); x.next = x.next.next; Console.WriteLine(); Console.WriteLine(\u0026#34;x: \u0026#34; + x.item); Console.WriteLine(\u0026#34;x.next: \u0026#34; + x.next.item); } } } 另请参阅 #  Generics 库\n"},{"id":76,"href":"/1-3-19/","title":"1.3.19","section":"帮助","content":"1.3.19 #  解答 #  建立一个结点引用 Cur，让它移动到尾结点的前一个结点，让那个结点的 next 变为 null。\n代码 #  using System; using Generics; namespace _1._3._19 { /* * 1.3.19 * * 给出一段代码，删除链表的尾结点，其中链表的首结点为 first。 * */ class Program { static void Main(string[] args) { Node\u0026lt;string\u0026gt; first = new Node\u0026lt;string\u0026gt;() { item = \u0026#34;first\u0026#34; }; Node\u0026lt;string\u0026gt; second = new Node\u0026lt;string\u0026gt;() { item = \u0026#34;second\u0026#34; }; Node\u0026lt;string\u0026gt; third = new Node\u0026lt;string\u0026gt;() { item = \u0026#34;third\u0026#34; }; first.next = second; second.next = third; third.next = null; Node\u0026lt;string\u0026gt; current = first; while (current != null) { Console.Write(current.item + \u0026#34; \u0026#34;); current = current.next; } DeleteLast(first); Console.WriteLine(); current = first; while (current != null) { Console.Write(current.item + \u0026#34; \u0026#34;); current = current.next; } Console.WriteLine(); } static void DeleteLast(Node\u0026lt;string\u0026gt; first) { Node\u0026lt;string\u0026gt; current = first; while (current.next.next != null) { current = current.next; } current.next = null; } } } 另请参阅 #  Generics 库\n"},{"id":77,"href":"/1-3-20/","title":"1.3.20","section":"帮助","content":"1.3.20 #  解答 #  和上一题类似，只不过这次让 Cur 移动 k – 1 次即可。\n代码 #  /// \u0026lt;summary\u0026gt; /// 删除指定位置的元素，返回该元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;需要删除元素的位置。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public Item Delete(int index) { if (index \u0026gt;= this.count) { throw new IndexOutOfRangeException(); } Node\u0026lt;Item\u0026gt; front = this.first; Item temp = this.first.item; if (index == 0) { this.first = this.first.next; return temp; } for (int i = 1; i \u0026lt; index; ++i) { front = front.next; } temp = front.next.item; front.next = front.next.next; this.count--; return temp; } "},{"id":78,"href":"/1-3-21/","title":"1.3.21","section":"帮助","content":"1.3.21 #  解答 #  遍历整条链表，方法和前两题类似，用一个结点引用 Cur 去访问就可以了。\n代码 #  using System; using Generics; namespace _1._3._21 { /* * 1.3.21 * * 编写一个方法 find()，接受一条链表和一个字符串 key 作为参数。 * 如果链表中的某个结点的 item 域的值为 key，则方法返回 true，否则返回 false。 * */ class Program { static void Main(string[] args) { LinkedList\u0026lt;string\u0026gt; link = new LinkedList\u0026lt;string\u0026gt;(); link.Insert(\u0026#34;first\u0026#34;, 0); link.Insert(\u0026#34;second\u0026#34;, 1); link.Insert(\u0026#34;third\u0026#34;, 2); Console.WriteLine(Find(link, \u0026#34;second\u0026#34;)); Console.WriteLine(Find(link, \u0026#34;fourth\u0026#34;)); } static bool Find\u0026lt;Item\u0026gt;(LinkedList\u0026lt;Item\u0026gt; link, Item key) { foreach (Item i in link) { if (i.Equals(key)) { return true; } } return false; } } } 另请参阅 #  Generics 库\n"},{"id":79,"href":"/1-3-22/","title":"1.3.22","section":"帮助","content":"1.3.22 #  解答 #  在 x 之后插入 t，如下图所示。\n代码 #  using System; using Generics; namespace _1._3._22 { /* * 1.3.22 * * 假设 x 是一条链表中的某个结点，下面这段代码做了什么？ * */ class Program { //将 t 插入到 x 之后  static void Main(string[] args) { Node\u0026lt;string\u0026gt; first = new Node\u0026lt;string\u0026gt;(); Node\u0026lt;string\u0026gt; second = new Node\u0026lt;string\u0026gt;(); Node\u0026lt;string\u0026gt; third = new Node\u0026lt;string\u0026gt;(); Node\u0026lt;string\u0026gt; fourth = new Node\u0026lt;string\u0026gt;(); first.item = \u0026#34;first\u0026#34;; second.item = \u0026#34;second\u0026#34;; third.item = \u0026#34;third\u0026#34;; fourth.item = \u0026#34;fourth\u0026#34;; first.next = second; second.next = third; third.next = fourth; fourth.next = null; Node\u0026lt;string\u0026gt; current = first; while (current != null) { Console.Write(current.item + \u0026#34; \u0026#34;); current = current.next; } Node\u0026lt;string\u0026gt; t = new Node\u0026lt;string\u0026gt;(); t.item = \u0026#34;t\u0026#34;; t.next = second.next; second.next = t; Console.WriteLine(); current = first; while (current != null) { Console.Write(current.item + \u0026#34; \u0026#34;); current = current.next; } } } } 另请参阅 #  Generics 库\n"},{"id":80,"href":"/1-3-23/","title":"1.3.23","section":"帮助","content":"1.3.23 #  解答 #  由于先后问题，y 在第一句代码执行完毕之后无法访问，t 的 next 会指向自己。\n代码 #  using System; using Generics; namespace _1._3._23 { /* * 1.3.23 * * 为什么下面这段代码和上一题中的代码效果不同？ * */ class Program { //x.next = t x 的下一个是 t  //t.next = x.next t 的下一个和 x 的下一个相同（也就是 t）  //于是 t.next = t, 遍历会出现死循环。  static void Main(string[] args) { Node\u0026lt;string\u0026gt; first = new Node\u0026lt;string\u0026gt;(); Node\u0026lt;string\u0026gt; second = new Node\u0026lt;string\u0026gt;(); Node\u0026lt;string\u0026gt; third = new Node\u0026lt;string\u0026gt;(); Node\u0026lt;string\u0026gt; fourth = new Node\u0026lt;string\u0026gt;(); first.item = \u0026#34;first\u0026#34;; second.item = \u0026#34;second\u0026#34;; third.item = \u0026#34;third\u0026#34;; fourth.item = \u0026#34;fourth\u0026#34;; first.next = second; second.next = third; third.next = fourth; fourth.next = null; Node\u0026lt;string\u0026gt; current = first; while (current != null) { Console.Write(current.item + \u0026#34; \u0026#34;); current = current.next; } Node\u0026lt;string\u0026gt; t = new Node\u0026lt;string\u0026gt;(); t.item = \u0026#34;t\u0026#34;; second.next = t; t.next = second.next; Console.WriteLine(); current = first; while (current != null) { Console.Write(current.item + \u0026#34; \u0026#34;); current = current.next; } } } } 另请参阅 #  Generics 库\n"},{"id":81,"href":"/1-3-24/","title":"1.3.24","section":"帮助","content":"1.3.24 #  解答 #  直接把该节点的 next 域设为 null，后续元素就会因无法访问而被清理掉。\n代码 #  using System; using Generics; namespace _1._3._24 { /* * 1.3.24 * * 编写一个方法 removeAfter()，接受一个链表结点作为参数并删除该结点的后续结点。 * （如果参数结点的后续结点为空则什么也不做） * */ class Program { static void Main(string[] args) { Node\u0026lt;string\u0026gt; first = new Node\u0026lt;string\u0026gt;(); Node\u0026lt;string\u0026gt; second = new Node\u0026lt;string\u0026gt;(); Node\u0026lt;string\u0026gt; third = new Node\u0026lt;string\u0026gt;(); Node\u0026lt;string\u0026gt; fourth = new Node\u0026lt;string\u0026gt;(); first.item = \u0026#34;first\u0026#34;; second.item = \u0026#34;second\u0026#34;; third.item = \u0026#34;third\u0026#34;; fourth.item = \u0026#34;fourth\u0026#34;; first.next = second; second.next = third; third.next = fourth; fourth.next = null; Node\u0026lt;string\u0026gt; current = first; while (current != null) { Console.Write(current.item + \u0026#34; \u0026#34;); current = current.next; } RemoveAfter(second); Console.WriteLine(); current = first; while (current != null) { Console.Write(current.item + \u0026#34; \u0026#34;); current = current.next; } } static void RemoveAfter\u0026lt;Item\u0026gt;(Node\u0026lt;Item\u0026gt; i) { i.next = null; } } } 另请参阅 #  Generics 库\n"},{"id":82,"href":"/1-3-25/","title":"1.3.25","section":"帮助","content":"1.3.25 #  解答 #  见练习 1.3.22，加入一些对边界情况的处理即可。\n代码 #  using System; using Generics; namespace _1._3._25 { /* * 1.3.25 * * 编写一个方法 insertAfter()，接受两个链表结点作为参数， * 将第二个结点插入链表并使之成为第一个结点的后续结点 * （如果两个参数为空则什么也不做）。 * */ class Program { static void Main(string[] args) { Node\u0026lt;string\u0026gt; first = new Node\u0026lt;string\u0026gt;(); Node\u0026lt;string\u0026gt; second = new Node\u0026lt;string\u0026gt;(); Node\u0026lt;string\u0026gt; third = new Node\u0026lt;string\u0026gt;(); first.item = \u0026#34;first\u0026#34;; second.item = \u0026#34;second\u0026#34;; third.item = \u0026#34;third\u0026#34;; first.next = second; second.next = null; Node\u0026lt;string\u0026gt; current = first; while (current != null) { Console.Write(current.item + \u0026#34; \u0026#34;); current = current.next; } InsertAfter(second, third); Console.WriteLine(); current = first; while (current != null) { Console.Write(current.item + \u0026#34; \u0026#34;); current = current.next; } } static void InsertAfter\u0026lt;Item\u0026gt;(Node\u0026lt;Item\u0026gt; A, Node\u0026lt;Item\u0026gt; B) { if (A == null || B == null) return; B.next = A.next; A.next = B; } } } 另请参阅 #  Generics 库\n"},{"id":83,"href":"/1-3-26/","title":"1.3.26","section":"帮助","content":"1.3.26 #  解答 #  之前已经写过了删除指定结点（习题 1.3.20）和查找指定结点（习题 1.3.21），结合使用即可。\n代码 #  using System; using Generics; namespace _1._3._26 { /* * 1.3.26 * * 编写一个方法 remove()，接受一条链表和一个字符串 key 作为参数， * 删除链表中所有 item 域为 key 的结点。 * */ class Program { static void Main(string[] args) { LinkedList\u0026lt;string\u0026gt; link = new LinkedList\u0026lt;string\u0026gt;(); link.Insert(\u0026#34;first\u0026#34;, 0); link.Insert(\u0026#34;second\u0026#34;, 1); link.Insert(\u0026#34;third\u0026#34;, 2); link.Insert(\u0026#34;third\u0026#34;, 3); link.Insert(\u0026#34;third\u0026#34;, 4); Console.WriteLine(link); Remove(link, \u0026#34;third\u0026#34;); Console.WriteLine(link); } static void Remove(LinkedList\u0026lt;string\u0026gt; link, string key) { for (int i = 0; i \u0026lt; link.Size(); ++i) { if (link.Find(i) == key) { link.Delete(i); i--; } } } } } 另请参阅 #  Generics 库\n"},{"id":84,"href":"/1-3-27/","title":"1.3.27","section":"帮助","content":"1.3.27 #  解答 #  遍历一遍即可。\n代码 #  using System; using Generics; namespace _1._3._27 { /* * 1.3.27 * * 编写一个方法 max()，接受一条链表的首结点作为参数，返回链表中键最大的节点的值。 * 假设所有键均为正整数，如果链表为空则返回 0。 * */ class Program { static void Main(string[] args) { Node\u0026lt;int\u0026gt; first = new Node\u0026lt;int\u0026gt;(); Node\u0026lt;int\u0026gt; second = new Node\u0026lt;int\u0026gt;(); Node\u0026lt;int\u0026gt; third = new Node\u0026lt;int\u0026gt;(); Node\u0026lt;int\u0026gt; fourth = new Node\u0026lt;int\u0026gt;(); first.item = 1; second.item = 2; third.item = 3; fourth.item = 4; first.next = second; second.next = third; third.next = fourth; fourth.next = null; Console.WriteLine(\u0026#34;Max:\u0026#34; + Max(first)); } static int Max(Node\u0026lt;int\u0026gt; first) { int max = 0; Node\u0026lt;int\u0026gt; current = first; while (current != null) { if (max \u0026lt; current.item) { max = current.item; } current = current.next; } return max; } } } 另请参阅 #  Generics 库\n"},{"id":85,"href":"/1-3-28/","title":"1.3.28","section":"帮助","content":"1.3.28 #  解答 #  其实链表本身就是一个递归结构，链表的定义可以用递归的方式表示：\n链表 = 头结点A + 链表B = 头结点A + 头结点B + 链表C……\n所以 Max() 可以这么写：\nMax(Node\u0026lt;Item\u0026gt; Cur, int nowmax) 如果 Cur 为空，则直接返回 nowmax。 否则检查 Cur 结点的值是否大于目前找到的最大值 nowmax。 如果不大于，继续查找下一个结点，返回 Max(Cur.next, nowmax) 否则，把 nowmax 修改为当前结点的值，继续查找，返回 Max(Cur.next, Cur.item) 代码 #  using System; using Generics; namespace _1._3._28 { /* * 1.3.28 * * 用递归方法解答上一道练习。 * */ class Program { static void Main(string[] args) { Node\u0026lt;int\u0026gt; first = new Node\u0026lt;int\u0026gt;(); Node\u0026lt;int\u0026gt; second = new Node\u0026lt;int\u0026gt;(); Node\u0026lt;int\u0026gt; third = new Node\u0026lt;int\u0026gt;(); Node\u0026lt;int\u0026gt; fourth = new Node\u0026lt;int\u0026gt;(); first.item = 1; second.item = 2; third.item = 3; fourth.item = 4; first.next = second; second.next = third; third.next = fourth; fourth.next = null; Console.WriteLine(\u0026#34;Max:\u0026#34; + Max(first)); } static int Max(Node\u0026lt;int\u0026gt; first, int max = 0) { if (first == null) return max; if (max \u0026lt; first.item) return Max(first.next, first.item); else return Max(first.next, max); } } } 另请参阅 #  Generics 库\n"},{"id":86,"href":"/1-3-29/","title":"1.3.29","section":"帮助","content":"1.3.29 #  解答 #  其实就是一个长这样的链表：\n显然说 first 和最后一个节点的指针重复了，所以我们只需要保留 last 的指针就行了。\n入队（注意顺序）\n出队\n代码 #  Queue.cs #  using System; using System.Collections; using System.Collections.Generic; using System.Text; namespace _1._3._29 { public class Queue\u0026lt;Item\u0026gt; : IEnumerable\u0026lt;Item\u0026gt; { private Node\u0026lt;Item\u0026gt; last; private int count; /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public Queue() { this.last = null; this.count = 0; } /// \u0026lt;summary\u0026gt;  /// 检查队列是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.last == null; } /// \u0026lt;summary\u0026gt;  /// 返回队列中元素的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() { return this.count; } /// \u0026lt;summary\u0026gt;  /// 返回队列中的第一个元素（但不让它出队）。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Peek() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Queue underflow\u0026#34;); return this.last.next.item; } /// \u0026lt;summary\u0026gt;  /// 将一个新元素加入队列中。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要入队的元素。\u0026lt;/param\u0026gt;  public void Enqueue(Item item) { Node\u0026lt;Item\u0026gt; oldLast = this.last; this.last = new Node\u0026lt;Item\u0026gt;(); this.last.item = item; this.last.next = this.last; if (oldLast != null) { this.last.next = oldLast.next; oldLast.next = this.last; } count++; } /// \u0026lt;summary\u0026gt;  /// 将队列中的第一个元素出队并返回它。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Dequeue() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Queue underflow\u0026#34;); Item item = this.last.next.item; this.last.next = this.last.next.next; this.count--; if (IsEmpty()) this.last = null; return item; } public override string ToString() { StringBuilder s = new StringBuilder(); foreach (Item item in this) { s.Append(item); s.Append(\u0026#34; \u0026#34;); } return s.ToString(); } public IEnumerator\u0026lt;Item\u0026gt; GetEnumerator() { return new QueueEnumerator(this.last); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class QueueEnumerator : IEnumerator\u0026lt;Item\u0026gt; { private Node\u0026lt;Item\u0026gt; current; private Node\u0026lt;Item\u0026gt; first; public QueueEnumerator(Node\u0026lt;Item\u0026gt; last) { this.current = new Node\u0026lt;Item\u0026gt;(); this.current.next = last.next; this.first = this.current; } Item IEnumerator\u0026lt;Item\u0026gt;.Current =\u0026gt; this.current.item; object IEnumerator.Current =\u0026gt; this.current.item; void IDisposable.Dispose() { this.first = null; this.current = null; } bool IEnumerator.MoveNext() { if (this.current.next == first.next) return false; this.current = this.current.next; return true; } void IEnumerator.Reset() { this.current = this.first; } } } public class Node\u0026lt;Item\u0026gt; { public Item item; public Node\u0026lt;Item\u0026gt; next; } } Program.cs #  using System; namespace _1._3._29 { /* * 1.3.29 * * 用环形链表实现 Queue。 * 环形链表也是一条链表，只是没有任何结点的链接为空，且只要链表非空则 last.next 的值为 first。 * 只能使用一个 Node 类型的实例变量（last）。 * */ class Program { static void Main(string[] args) { string input = \u0026#34;to be or not to - be - - that - - - is\u0026#34;; string[] s = input.Split(\u0026#39; \u0026#39;); Queue\u0026lt;string\u0026gt; queue = new Queue\u0026lt;string\u0026gt;(); foreach (string n in s) { if (!n.Equals(\u0026#34;-\u0026#34;)) queue.Enqueue(n); else if (!queue.IsEmpty()) Console.WriteLine(queue.Dequeue()); } Console.WriteLine($\u0026#34;({queue.Size()}) left on queue\u0026#34;); Console.WriteLine(queue); } } } "},{"id":87,"href":"/1-3-30/","title":"1.3.30","section":"帮助","content":"1.3.30 #  解答 #  书中给出了代码，这里说一下递归的实现。\n如果说一个链表除了第一个结点剩下的都已经反转了，那么我们就只要把该结点插入到最后就行了（也就是原先的第二个结点之后）。\n像这样：\n代码 #  using System; using Generics; namespace _1._3._30 { /* * 1.3.30 * * 编写一个函数，接受一条链表的首结点作为参数， * （破坏性地）将链表反转并返回链表的首结点。 * */ class Program { static void Main(string[] args) { Node\u0026lt;string\u0026gt; first = new Node\u0026lt;string\u0026gt;(); Node\u0026lt;string\u0026gt; second = new Node\u0026lt;string\u0026gt;(); Node\u0026lt;string\u0026gt; third = new Node\u0026lt;string\u0026gt;(); Node\u0026lt;string\u0026gt; fourth = new Node\u0026lt;string\u0026gt;(); first.item = \u0026#34;first\u0026#34;; second.item = \u0026#34;second\u0026#34;; third.item = \u0026#34;third\u0026#34;; fourth.item = \u0026#34;fourth\u0026#34;; first.next = second; second.next = third; third.next = fourth; fourth.next = null; Node\u0026lt;string\u0026gt; current = first; while (current != null) { Console.Write(current.item + \u0026#34; \u0026#34;); current = current.next; } first = Reverse(first); Console.WriteLine(); current = first; while (current != null) { Console.Write(current.item + \u0026#34; \u0026#34;); current = current.next; } } //使用书中的递归方式实现  static Node\u0026lt;Item\u0026gt; Reverse\u0026lt;Item\u0026gt;(Node\u0026lt;Item\u0026gt; first) { if (first == null) return null; if (first.next == null) return first; Node\u0026lt;Item\u0026gt; second = first.next; Node\u0026lt;Item\u0026gt; rest = Reverse(second); second.next = first; first.next = null; return rest; } } } 另请参阅 #  Generics 库\n"},{"id":88,"href":"/1-3-31/","title":"1.3.31","section":"帮助","content":"1.3.31 #  解答 #  双向链表的插入有顺序，务必当心。\n双向链表长这样（似乎有一种画法是把空指针画成“接地”的样子）：\n删除中间那个：\n再插回去：\n原则是不要让有用的结点变得无法访问。\n代码 #  DoubleNode\u0026lt;\u0026gt; #  using System; using System.Collections; using System.Collections.Generic; using System.Text; namespace _1._3._31 { /* * 1.3.31 * * 实现一个嵌套类 DoubleNode 用来构造双向链表， * 其中每个结点都含有一个指向前驱元素的应用和一项指向后续元素的引用（如果不存在则为 null）。 * 为以下任务实现若干静态方法： * 在表头插入结点。 * 在表尾插入结点。 * 从表头删除结点。 * 从表尾删除结点。 * 在指定结点之前插入新结点。 * 在指定结点之后插入新结点。 * 删除指定结点。 * */ public class DoubleLinkList\u0026lt;Item\u0026gt; : IEnumerable\u0026lt;Item\u0026gt; { private class DoubleNode\u0026lt;T\u0026gt; { public T item; public DoubleNode\u0026lt;T\u0026gt; prev; public DoubleNode\u0026lt;T\u0026gt; next; } DoubleNode\u0026lt;Item\u0026gt; first; DoubleNode\u0026lt;Item\u0026gt; last; int count; /// \u0026lt;summary\u0026gt;  /// 建立一条双向链表。  /// \u0026lt;/summary\u0026gt;  public DoubleLinkList() { this.first = null; this.last = null; this.count = 0; } /// \u0026lt;summary\u0026gt;  /// 检查链表是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return count == 0; } /// \u0026lt;summary\u0026gt;  /// 返回链表中元素的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() { return this.count; } /// \u0026lt;summary\u0026gt;  /// 在表头插入一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要插入的元素。\u0026lt;/param\u0026gt;  public void InsertFront(Item item) { DoubleNode\u0026lt;Item\u0026gt; node = new DoubleNode\u0026lt;Item\u0026gt;() { item = item, next = this.first, prev = null }; if (this.first != null) { this.first.prev = node; } else { this.last = node; } this.first = node; this.count++; } /// \u0026lt;summary\u0026gt;  /// 在表尾插入一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要插入表尾的元素。\u0026lt;/param\u0026gt;  public void InsertRear(Item item) { DoubleNode\u0026lt;Item\u0026gt; node = new DoubleNode\u0026lt;Item\u0026gt;() { item = item, next = null, prev = last }; if (this.last != null) { this.last.next = node; } else { this.first = node; } this.last = node; this.count++; } /// \u0026lt;summary\u0026gt;  /// 检索指定下标的元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;要检索的下标。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item At(int index) { if (index \u0026gt;= count || index \u0026lt; 0) throw new IndexOutOfRangeException(); DoubleNode\u0026lt;Item\u0026gt; current = this.first; for (int i = 0; i \u0026lt; index; ++i) { current = current.next; } return current.item; } /// \u0026lt;summary\u0026gt;  /// 返回指定下标的结点。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;要查找的下标。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private DoubleNode\u0026lt;Item\u0026gt; Find(int index) { if (index \u0026gt;= count || index \u0026lt; 0) throw new IndexOutOfRangeException(); DoubleNode\u0026lt;Item\u0026gt; current = this.first; for (int i = 0; i \u0026lt; index; ++i) { current = current.next; } return current; } /// \u0026lt;summary\u0026gt;  /// 在指定位置之前插入一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要插入的元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;插入位置的下标。\u0026lt;/param\u0026gt;  public void InsertBefore(Item item, int index) { if (index == 0) { InsertFront(item); return; } if (index \u0026gt;= count || index \u0026lt; 0) throw new IndexOutOfRangeException(); DoubleNode\u0026lt;Item\u0026gt; current = Find(index); DoubleNode\u0026lt;Item\u0026gt; node = new DoubleNode\u0026lt;Item\u0026gt;() { next = current, prev = current.prev, item = item }; current.prev.next = node; current.prev = node; this.count++; } /// \u0026lt;summary\u0026gt;  /// 在指定位置之后插入一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要插入的元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;查找元素的下标。\u0026lt;/param\u0026gt;  public void InsertAfter(Item item, int index) { if (index == count - 1) { InsertRear(item); return; } if (index \u0026gt;= count || index \u0026lt; 0) throw new IndexOutOfRangeException(); DoubleNode\u0026lt;Item\u0026gt; current = Find(index); DoubleNode\u0026lt;Item\u0026gt; node = new DoubleNode\u0026lt;Item\u0026gt;() { prev = current, next = current.next, item = item }; current.next.prev = node; current.next = node; this.count++; } /// \u0026lt;summary\u0026gt;  /// 删除表头元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item DeleteFront() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;List underflow\u0026#34;); Item temp = this.first.item; this.first = this.first.next; this.count--; if (IsEmpty()) { this.last = null; } return temp; } /// \u0026lt;summary\u0026gt;  /// 删除表尾的元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item DeleteRear() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;List underflow\u0026#34;); Item temp = this.last.item; this.last = this.last.prev; this.count--; if (IsEmpty()) { this.first = null; } else { this.last.next = null; } return temp; } /// \u0026lt;summary\u0026gt;  /// 删除指定位置的元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;要删除元素的下标。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Delete(int index) { if (index \u0026lt; 0 || index \u0026gt;= this.count) throw new IndexOutOfRangeException(); if (index == 0) { return DeleteFront(); } if (index == count - 1) { return DeleteRear(); } DoubleNode\u0026lt;Item\u0026gt; current = Find(index); Item temp = current.item; current.prev.next = current.next; current.next.prev = current.prev; count--; return temp; } public override string ToString() { StringBuilder s = new StringBuilder(); foreach (Item i in this) { s.Append(i.ToString()); s.Append(\u0026#34; \u0026#34;); } return s.ToString(); } public IEnumerator\u0026lt;Item\u0026gt; GetEnumerator() { return new DoubleLinkListEnumerator(this.first); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class DoubleLinkListEnumerator : IEnumerator\u0026lt;Item\u0026gt; { DoubleNode\u0026lt;Item\u0026gt; current; DoubleNode\u0026lt;Item\u0026gt; first; public DoubleLinkListEnumerator(DoubleNode\u0026lt;Item\u0026gt; first) { this.current = new DoubleNode\u0026lt;Item\u0026gt;(); this.current.next = first; this.first = current; } Item IEnumerator\u0026lt;Item\u0026gt;.Current =\u0026gt; current.item; object IEnumerator.Current =\u0026gt; current.item; void IDisposable.Dispose() { this.current = null; this.first = null; } bool IEnumerator.MoveNext() { if (this.current.next == null) return false; this.current = this.current.next; return true; } void IEnumerator.Reset() { this.current = this.first; } } } } Program.cs #  using System; namespace _1._3._31 { class Program { static void Main(string[] args) { DoubleLinkList\u0026lt;string\u0026gt; linklist = new DoubleLinkList\u0026lt;string\u0026gt;(); linklist.InsertRear(\u0026#34;fourth\u0026#34;); linklist.InsertFront(\u0026#34;first\u0026#34;); linklist.InsertAfter(\u0026#34;second\u0026#34;, 0); linklist.InsertBefore(\u0026#34;third\u0026#34;, 2); Console.WriteLine(linklist); linklist.DeleteFront(); Console.WriteLine(linklist); linklist.DeleteRear(); Console.WriteLine(linklist); linklist.Delete(1); Console.WriteLine(linklist); Console.WriteLine(linklist.At(0)); } } } "},{"id":89,"href":"/1-3-32/","title":"1.3.32","section":"帮助","content":"1.3.32 #  解答 #  在队列的基础上增加一个在队首插入元素的方法即可。\n代码 #  Steque.cs #  using System; using System.Collections; using System.Collections.Generic; using System.Text; namespace _1._3._32 { //API:  //public class Steque\u0026lt;Item\u0026gt; : Ienumerable\u0026lt;Item\u0026gt;  // public Steque(); 默认构造函数。  // public bool IsEmpty(); 检查 Steque 是否为空。  // public int Size(); 返回 Steque 中的元素数量。  // public void Push(Item item); 向 Steque 中压入一个元素。  // public Item Pop(); 从 Steque 中弹出一个元素。  // public void Peek(); 返回栈顶元素（但不弹出它）。  // public void Enqueue(Item item); 将一个元素添加入 Steque 中。  public class Steque\u0026lt;Item\u0026gt; : IEnumerable\u0026lt;Item\u0026gt; { private Node\u0026lt;Item\u0026gt; first; private Node\u0026lt;Item\u0026gt; last; private int count; private class Node\u0026lt;T\u0026gt; { public T item; public Node\u0026lt;T\u0026gt; next; } /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public Steque() { this.first = null; this.count = 0; } /// \u0026lt;summary\u0026gt;  /// 检查栈是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return count == 0; } /// \u0026lt;summary\u0026gt;  /// 返回栈内元素的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() { return this.count; } /// \u0026lt;summary\u0026gt;  /// 将一个元素压入栈中。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要压入栈中的元素。\u0026lt;/param\u0026gt;  public void Push(Item item) { Node\u0026lt;Item\u0026gt; oldFirst = first; this.first = new Node\u0026lt;Item\u0026gt;(); this.first.item = item; this.first.next = oldFirst; if (oldFirst == null) { this.last = this.first; } count++; } /// \u0026lt;summary\u0026gt;  /// 将一个元素从栈中弹出，返回弹出的元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Pop() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Stack Underflow\u0026#34;); Item item = first.item; first = first.next; count--; if (count == 0) { this.last = null; } return item; } /// \u0026lt;summary\u0026gt;  /// 将一个元素加入队列中。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要入队的元素。\u0026lt;/param\u0026gt;  public void Enqueue(Item item) { Node\u0026lt;Item\u0026gt; oldLast = this.last; this.last = new Node\u0026lt;Item\u0026gt;(); this.last.item = item; this.last.next = null; if (IsEmpty()) this.first = this.last; else oldLast.next = this.last; count++; } /// \u0026lt;summary\u0026gt;  /// 返回栈顶元素（但不弹出它）。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Peek() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Stack Underflow\u0026#34;); return first.item; } public override string ToString() { StringBuilder s = new StringBuilder(); foreach (Item n in this) { s.Append(n); s.Append(\u0026#39; \u0026#39;); } return s.ToString(); } public IEnumerator\u0026lt;Item\u0026gt; GetEnumerator() { return new StackEnumerator(this.first); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class StackEnumerator : IEnumerator\u0026lt;Item\u0026gt; { private Node\u0026lt;Item\u0026gt; current; private Node\u0026lt;Item\u0026gt; first; public StackEnumerator(Node\u0026lt;Item\u0026gt; first) { this.current = new Node\u0026lt;Item\u0026gt;(); this.current.next = first; this.first = this.current; } Item IEnumerator\u0026lt;Item\u0026gt;.Current =\u0026gt; current.item; object IEnumerator.Current =\u0026gt; current.item; void IDisposable.Dispose() { this.current = null; this.first = null; } bool IEnumerator.MoveNext() { if (this.current.next == null) return false; this.current = this.current.next; return true; } void IEnumerator.Reset() { this.current = this.first; } } } } program.cs #  using System; namespace _1._3._32 { /* * 1.3.32 * * Steque * 一个以栈为目标的队列（或称 steque）， * 是一种支持 push、pop 和 enqueue 操作的数据类型。 * 为这种抽象数据类定义一份 API 并给出一份基于链表的实现。 * */ class Program { //见 Steque.cs  static void Main(string[] args) { Steque\u0026lt;string\u0026gt; steque = new Steque\u0026lt;string\u0026gt;(); steque.Push(\u0026#34;first\u0026#34;); steque.Push(\u0026#34;second\u0026#34;); steque.Push(\u0026#34;third\u0026#34;); steque.Enqueue(\u0026#34;fourth\u0026#34;); Console.WriteLine(steque.ToString()); steque.Pop(); steque.Pop(); steque.Pop(); steque.Pop(); Console.WriteLine(steque.ToString()); steque.Enqueue(\u0026#34;first\u0026#34;); steque.Push(\u0026#34;zero\u0026#34;); Console.WriteLine(steque.ToString()); } } } "},{"id":90,"href":"/1-3-33/","title":"1.3.33","section":"帮助","content":"1.3.33 #  解答 #  动态数组这里要注意 first 不要小于零。\n代码 #  Deque 类 #  using System; using System.Collections; using System.Collections.Generic; namespace _1._3._33 { public class Deque\u0026lt;Item\u0026gt; : IEnumerable\u0026lt;Item\u0026gt; { private class DoubleNode\u0026lt;T\u0026gt; { public T item; public DoubleNode\u0026lt;T\u0026gt; next; public DoubleNode\u0026lt;T\u0026gt; prev; } DoubleNode\u0026lt;Item\u0026gt; first; DoubleNode\u0026lt;Item\u0026gt; last; int count; /// \u0026lt;summary\u0026gt;  /// 默认构造函数，建立一个双端队列。  /// \u0026lt;/summary\u0026gt;  public Deque() { this.first = null; this.last = null; this.count = 0; } /// \u0026lt;summary\u0026gt;  /// 检查队列是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.count == 0; } /// \u0026lt;summary\u0026gt;  /// 返回队列中元素的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() { return this.count; } /// \u0026lt;summary\u0026gt;  /// 向左端添加一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要添加的元素。\u0026lt;/param\u0026gt;  public void PushLeft(Item item) { DoubleNode\u0026lt;Item\u0026gt; oldFirst = this.first; this.first = new DoubleNode\u0026lt;Item\u0026gt;() { item = item, prev = null, next = oldFirst }; if (oldFirst == null) { this.last = this.first; } else { oldFirst.prev = this.first; } this.count++; } /// \u0026lt;summary\u0026gt;  /// 向右端添加一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要添加的元素。\u0026lt;/param\u0026gt;  public void PushRight(Item item) { DoubleNode\u0026lt;Item\u0026gt; oldLast = this.last; this.last = new DoubleNode\u0026lt;Item\u0026gt;() { item = item, prev = oldLast, next = null }; if (oldLast == null) { this.first = this.last; } else { oldLast.next = this.last; } this.count++; } /// \u0026lt;summary\u0026gt;  /// 从右端删除并返回一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item PopRight() { if (IsEmpty()) { throw new InvalidOperationException(); } Item temp = this.last.item; this.last = this.last.prev; this.count--; if (this.last == null) { this.first = null; } else { this.last.next.item = default(Item); this.last.next = null; } return temp; } /// \u0026lt;summary\u0026gt;  /// 从左端删除并返回一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item PopLeft() { if (IsEmpty()) { throw new InvalidOperationException(); } Item temp = this.first.item; this.first = this.first.next; this.count--; if (this.first == null) { this.last = null; } else { this.first.prev.item = default(Item); this.first.prev = null; } return temp; } public IEnumerator\u0026lt;Item\u0026gt; GetEnumerator() { return new DequeEnumerator(this.first); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class DequeEnumerator : IEnumerator\u0026lt;Item\u0026gt; { private DoubleNode\u0026lt;Item\u0026gt; current; private DoubleNode\u0026lt;Item\u0026gt; first; public DequeEnumerator(DoubleNode\u0026lt;Item\u0026gt; first) { this.current = new DoubleNode\u0026lt;Item\u0026gt;(); this.current.next = first; this.current.prev = null; this.first = this.current; } public Item Current =\u0026gt; current.item; object IEnumerator.Current =\u0026gt; current.item; public void Dispose() { this.current = null; this.first = null; } public bool MoveNext() { if (this.current.next == null) return false; this.current = this.current.next; return true; } public void Reset() { this.current = this.first; } } } } ResizingArrayDeque 类 #  using System; using System.Collections; using System.Collections.Generic; namespace _1._3._33 { public class ResizingArrayDeque\u0026lt;Item\u0026gt; : IEnumerable\u0026lt;Item\u0026gt; { private Item[] deque; private int first; private int last; private int count; /// \u0026lt;summary\u0026gt;  /// 默认构造函数，建立一个双向队列。  /// \u0026lt;/summary\u0026gt;  public ResizingArrayDeque() { this.deque = new Item[2]; this.first = 0; this.last = 0; this.count = 0; } /// \u0026lt;summary\u0026gt;  /// 检查队列是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.count == 0; } /// \u0026lt;summary\u0026gt;  /// 返回队列中元素的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() { return this.count; } /// \u0026lt;summary\u0026gt;  /// 为队列重新分配空间。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;需要重新分配的空间大小。\u0026lt;/param\u0026gt;  private void Resize(int capacity) { if (capacity \u0026lt;= 0) throw new ArgumentException(); Item[] temp = new Item[capacity]; for (int i = 0; i \u0026lt; count; ++i) { temp[i] = this.deque[(this.first + i) % this.deque.Length]; } this.deque = temp; this.first = 0; this.last = this.count; } /// \u0026lt;summary\u0026gt;  /// 在队列左侧添加一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要添加的元素\u0026lt;/param\u0026gt;  public void PushLeft(Item item) { if (this.count == this.deque.Length) { Resize(2 * this.count); } this.first--; if (this.first \u0026lt; 0) { this.first += this.deque.Length; } this.deque[this.first] = item; this.count++; } public void PushRight (Item item) { if (this.count == this.deque.Length) { Resize(2 * this.count); } this.deque[this.last] = item; this.last = (this.last + 1) % this.deque.Length; this.count++; } public Item PopRight() { if (IsEmpty()) { throw new InvalidOperationException(); } this.last--; if (this.last \u0026lt; 0) { this.last += this.deque.Length; } Item temp = this.deque[this.last]; this.count--; if (this.count \u0026gt; 0 \u0026amp;\u0026amp; this.count == deque.Length / 4) Resize(this.deque.Length / 2); return temp; } public Item PopLeft() { if (IsEmpty()) throw new ArgumentException(); Item temp = this.deque[this.first]; this.first = (this.first + 1) % this.deque.Length; this.count--; if (this.count \u0026gt; 0 \u0026amp;\u0026amp; this.count == deque.Length / 4) { Resize(this.deque.Length / 2); } return temp; } public IEnumerator\u0026lt;Item\u0026gt; GetEnumerator() { return new ResizingDequeEnumerator(this.deque, this.first, this.count); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class ResizingDequeEnumerator : IEnumerator\u0026lt;Item\u0026gt; { private Item[] deque; private int current; private int first; private int count; public ResizingDequeEnumerator(Item[] deque, int first, int count) { this.deque = deque; this.first = first; this.count = count; this.current = -1; } Item IEnumerator\u0026lt;Item\u0026gt;.Current =\u0026gt; this.deque[(this.first + this.current) % this.deque.Length]; object IEnumerator.Current =\u0026gt; this.deque[(this.first + this.current) % this.deque.Length]; void IDisposable.Dispose() { this.deque = null; this.current = -1; } bool IEnumerator.MoveNext() { if (this.current == this.count - 1) { return false; } this.current++; return true; } void IEnumerator.Reset() { this.current = -1; } } } } Program.cs #  using System; namespace _1._3._33 { /* * 1.3.33 * * Deque。 * 一个双向队列（或称 deque）和栈或队列类似，但它同时支持在两端添加或删除元素。 * Deque 能够存储一组元素并支持下表中的 API： * * Deque() * 创建空双向队列。 * Bool isEmpty() * 双向队列是否为空。 * int size() * 双向队列中的元素数量。 * void pushLeft(Item item) * 向左端添加一个新元素。 * void pushRight(Item item) * 向右端添加一个新元素。 * Item popLeft() * 从左端删除一个元素。 * Item popRight() * 从右端删除一个元素。 * * 编写一个使用双向链表实现这份 API 的 Deque 类， * 以及一个使用动态数组调整实现这份 API 的 ResizingArrayDeque 类。 * */ class Program { static void Main(string[] args) { Deque\u0026lt;string\u0026gt; a = new Deque\u0026lt;string\u0026gt;(); ResizingArrayDeque\u0026lt;string\u0026gt; b = new ResizingArrayDeque\u0026lt;string\u0026gt;(); a.PushLeft(\u0026#34;first\u0026#34;); b.PushLeft(\u0026#34;first\u0026#34;); a.PushRight(\u0026#34;second\u0026#34;); b.PushRight(\u0026#34;second\u0026#34;); Display(a, b); a.PopLeft(); b.PopLeft(); Display(a, b); a.PopRight(); b.PopRight(); Display(a, b); } static void Display(Deque\u0026lt;string\u0026gt; a, ResizingArrayDeque\u0026lt;string\u0026gt; b) { foreach (string s in a) { Console.Write(s + \u0026#34; \u0026#34;); } Console.WriteLine(); foreach (string s in b) { Console.Write(s + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.WriteLine(); } } } "},{"id":91,"href":"/1-3-34/","title":"1.3.34","section":"帮助","content":"1.3.34 #  解答 #  在初始化迭代器的时候随机生成一个访问序列，\n之后按照这个访问序列进行迭代即可。\n代码 #  RandomBag.cs #  using System; using System.Collections; using System.Collections.Generic; namespace _1._3._34 { public class RandomBag\u0026lt;Item\u0026gt; : IEnumerable\u0026lt;Item\u0026gt; { private Item[] bag; private int count; /// \u0026lt;summary\u0026gt;  /// 建立一个随机背包。  /// \u0026lt;/summary\u0026gt;  public RandomBag() { this.bag = new Item[2]; this.count = 0; } /// \u0026lt;summary\u0026gt;  /// 检查背包是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.count == 0; } /// \u0026lt;summary\u0026gt;  /// 返回背包中元素的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() { return this.count; } /// \u0026lt;summary\u0026gt;  /// 向背包中添加一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要向背包中添加的元素。\u0026lt;/param\u0026gt;  public void Add(Item item) { if (this.count == this.bag.Length) { Resize(this.count * 2); } this.bag[count] = item; count++; } /// \u0026lt;summary\u0026gt;  /// 重新为背包分配内存空间。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  private void Resize(int capacity) { if (capacity \u0026lt;= 0) throw new ArgumentException(); Item[] temp = new Item[capacity]; for (int i = 0; i \u0026lt; this.count; ++i) { temp[i] = this.bag[i]; } this.bag = temp; } public IEnumerator\u0026lt;Item\u0026gt; GetEnumerator() { return new RandomBagEnumerator(this.bag, this.count); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class RandomBagEnumerator : IEnumerator\u0026lt;Item\u0026gt; { private Item[] bag; private int[] sequence; private int current; private int count; public RandomBagEnumerator(Item[] bag, int count) { this.bag = bag; this.current = -1; this.count = count; this.sequence = new int[count]; for (int i = 0; i \u0026lt; this.count; ++i) { this.sequence[i] = i; } Shuffle(sequence, DateTime.Now.Millisecond); } /// \u0026lt;summary\u0026gt;  /// 随机打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;seed\u0026#34;\u0026gt;随机种子值。\u0026lt;/param\u0026gt;  private void Shuffle(int[] a, int seed) { int N = a.Length; Random random = new Random(seed); for (int i = 0; i \u0026lt; N; ++i) { int r = i + random.Next(N - i); int temp = a[i]; a[i] = a[r]; a[r] = temp; } } Item IEnumerator\u0026lt;Item\u0026gt;.Current =\u0026gt; this.bag[this.sequence[this.current]]; object IEnumerator.Current =\u0026gt; this.bag[this.sequence[this.current]]; void IDisposable.Dispose() { this.bag = null; this.sequence = null; this.current = -1; } bool IEnumerator.MoveNext() { if (this.current == this.count - 1) return false; this.current++; return true; } void IEnumerator.Reset() { this.current = -1; } } } } "},{"id":92,"href":"/1-3-35/","title":"1.3.35","section":"帮助","content":"1.3.35 #  解答 #  事实上只需要在普通队列的基础上稍作修改就可以了。\n出队时先随机选择一个元素，之后让它和最开始的元素做交换，之后正常出队即可。\n代码 #  RandomQueue.cs #  using System; namespace _1._3._35 { public class RandomQueue\u0026lt;Item\u0026gt; { private Item[] queue; private int count; /// \u0026lt;summary\u0026gt;  /// 新建一个随机队列。  /// \u0026lt;/summary\u0026gt;  public RandomQueue() { this.queue = new Item[2]; this.count = 0; } /// \u0026lt;summary\u0026gt;  /// 判断队列是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.count == 0; } /// \u0026lt;summary\u0026gt;  /// 为队列重新分配内存空间。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  private void Resize(int capacity) { if (capacity \u0026lt;= 0) { throw new ArgumentException(); } Item[] temp = new Item[capacity]; for (int i = 0; i \u0026lt; this.count; ++i) { temp[i] = this.queue[i]; } this.queue = temp; } /// \u0026lt;summary\u0026gt;  /// 向队列中添加一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要向队列中添加的元素。\u0026lt;/param\u0026gt;  public void Enqueue(Item item) { if (this.queue.Length == this.count) { Resize(this.count * 2); } this.queue[this.count] = item; this.count++; } /// \u0026lt;summary\u0026gt;  /// 从队列中随机删除并返回一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Dequeue() { if (IsEmpty()) { throw new InvalidOperationException(); } Random random = new Random(DateTime.Now.Millisecond); int index = random.Next(this.count); Item temp = this.queue[index]; this.queue[index] = this.queue[this.count - 1]; this.queue[this.count - 1] = temp; this.count--; if (this.count \u0026lt; this.queue.Length / 4) { Resize(this.queue.Length / 2); } return temp; } /// \u0026lt;summary\u0026gt;  /// 随机返回一个队列中的元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Sample() { if (IsEmpty()) { throw new InvalidOperationException(); } Random random = new Random(); int index = random.Next(this.count); return this.queue[index]; } } } "},{"id":93,"href":"/1-3-36/","title":"1.3.36","section":"帮助","content":"1.3.36 #  解答 #  实现方法和 1.3.34 类似，初始化迭代器的时候同时初始化一个随机访问序列。\n代码 #  RandomQueue.cs #  using System; using System.Collections; using System.Collections.Generic; namespace _1._3._36 { public class RandomQueue\u0026lt;Item\u0026gt; : IEnumerable\u0026lt;Item\u0026gt; { private Item[] queue; private int count; /// \u0026lt;summary\u0026gt;  /// 新建一个随机队列。  /// \u0026lt;/summary\u0026gt;  public RandomQueue() { this.queue = new Item[2]; this.count = 0; } /// \u0026lt;summary\u0026gt;  /// 判断队列是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.count == 0; } /// \u0026lt;summary\u0026gt;  /// 为队列重新分配内存空间。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  private void Resize(int capacity) { if (capacity \u0026lt;= 0) { throw new ArgumentException(); } Item[] temp = new Item[capacity]; for (int i = 0; i \u0026lt; this.count; ++i) { temp[i] = this.queue[i]; } this.queue = temp; } /// \u0026lt;summary\u0026gt;  /// 向队列中添加一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要向队列中添加的元素。\u0026lt;/param\u0026gt;  public void Enqueue(Item item) { if (this.queue.Length == this.count) { Resize(this.count * 2); } this.queue[this.count] = item; this.count++; } /// \u0026lt;summary\u0026gt;  /// 从队列中随机删除并返回一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Dequeue() { if (IsEmpty()) { throw new InvalidOperationException(); } Random random = new Random(DateTime.Now.Millisecond); int index = random.Next(this.count); Item temp = this.queue[index]; this.queue[index] = this.queue[this.count - 1]; this.queue[this.count - 1] = temp; this.count--; if (this.count \u0026lt; this.queue.Length / 4) { Resize(this.queue.Length / 2); } return temp; } /// \u0026lt;summary\u0026gt;  /// 随机返回一个队列中的元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Sample() { if (IsEmpty()) { throw new InvalidOperationException(); } Random random = new Random(); int index = random.Next(this.count); return this.queue[index]; } public IEnumerator\u0026lt;Item\u0026gt; GetEnumerator() { return new RandomQueueEnumerator(this.queue, this.count); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class RandomQueueEnumerator : IEnumerator\u0026lt;Item\u0026gt; { private int current; private int count; private Item[] queue; private int[] sequence; public RandomQueueEnumerator(Item[] queue, int count) { this.count = count; this.queue = queue; this.current = -1; this.sequence = new int[this.count]; for (int i = 0; i \u0026lt; this.count; ++i) { this.sequence[i] = i; } Shuffle(this.sequence, DateTime.Now.Millisecond); } /// \u0026lt;summary\u0026gt;  /// 随机打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;seed\u0026#34;\u0026gt;随机种子值。\u0026lt;/param\u0026gt;  private void Shuffle(int[] a, int seed) { int N = a.Length; Random random = new Random(seed); for (int i = 0; i \u0026lt; N; ++i) { int r = i + random.Next(N - i); int temp = a[i]; a[i] = a[r]; a[r] = temp; } } Item IEnumerator\u0026lt;Item\u0026gt;.Current =\u0026gt; this.queue[this.sequence[this.current]]; object IEnumerator.Current =\u0026gt; this.queue[this.sequence[this.current]]; void IDisposable.Dispose() { this.current = -1; this.sequence = null; this.queue = null; } bool IEnumerator.MoveNext() { if (this.current == this.count - 1) return false; this.current++; return true; } void IEnumerator.Reset() { this.current = -1; } } } } "},{"id":94,"href":"/1-3-37/","title":"1.3.37","section":"帮助","content":"1.3.37 #  解答 #  也就是约瑟夫问题，官方给出的 JAVA 版答案：Josephus.java。\n报数时将一个人出队然后入队来模拟一个环。\n报到 M 个后将那个人出队但不入队（删除）\n随后继续循环。\n代码 #  using System; using Generics; namespace _1._3._37 { /* * 1.3.37 * * Josephus 问题。 * 在这个古老的问题中，N 个身陷绝境的人一致同意通过以下方式减少生存人数。 * 他们围坐成一圈（位置记作 0 到 N-1）并从第一个人开始报数， * 报到 M 的人会被杀死，直到最后一个人留下来。 * 传说中 Josephus 找到了不会被杀死的位置。 * 编写一个 Queue 的用例 Josephus，从命令行接受 N 和 M 并打印出人们被杀死的顺序 * （这也将显示 Josephus 在圈中的位置）。 * */ class Program { static void Main(string[] args) { int numOfPeople = 7; int callForDeath = 2; Queue\u0026lt;int\u0026gt; queue = new Queue\u0026lt;int\u0026gt;(); for (int i = 0; i \u0026lt; numOfPeople; ++i) { queue.Enqueue(i); } while (!queue.IsEmpty()) { for (int i = 0; i \u0026lt; callForDeath - 1; ++i) { queue.Enqueue(queue.Dequeue()); } Console.Write(queue.Dequeue() + \u0026#34; \u0026#34;); } Console.WriteLine(); } } } 另请参阅 #  Generics 库\n约瑟夫问题-维基百科——给出了约瑟夫问题的数学通解\n"},{"id":95,"href":"/1-3-38/","title":"1.3.38","section":"帮助","content":"1.3.38 #  解答 #  这里采用“假删除”的方式，对要删除的元素不直接删除而是打上标记，这样就可以维持插入的顺序。\n代码 #  数组实现 #  using System; namespace _1._3._38 { class ArrayBasedGeneralizeQueue\u0026lt;Item\u0026gt; { private Item[] queue; private bool[] IsVisited; private int count; private int first; private int last; /// \u0026lt;summary\u0026gt;  /// 建立一个队列。  /// \u0026lt;/summary\u0026gt;  public ArrayBasedGeneralizeQueue() { this.queue = new Item[2]; this.IsVisited = new bool[2]; this.first = 0; this.last = 0; this.count = 0; } /// \u0026lt;summary\u0026gt;  /// 检查队列是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.count == 0; } /// \u0026lt;summary\u0026gt;  /// 为队列重新分配空间。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  private void Resize(int capacity) { Item[] temp = new Item[capacity]; for (int i = 0; i \u0026lt; this.count; ++i) { temp[i] = this.queue[i]; } this.queue = temp; bool[] t = new bool[capacity]; for (int i = 0; i \u0026lt; this.count; ++i) { t[i] = this.IsVisited[i]; } this.IsVisited = t; } /// \u0026lt;summary\u0026gt;  /// 向队列中插入一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要插入队列的元素。\u0026lt;/param\u0026gt;  public void Insert(Item item) { if (this.count == this.queue.Length) { Resize(this.queue.Length * 2); } this.queue[this.last] = item; this.IsVisited[this.last] = false; this.last++; this.count++; } /// \u0026lt;summary\u0026gt;  /// 从队列中删除并返回第 k 个插入的元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;要删除元素的顺序（从 1 开始）\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Delete(int k) { if (IsEmpty()) { throw new InvalidOperationException(); } if (k \u0026gt; this.last || k \u0026lt; 0) { throw new ArgumentOutOfRangeException(); } if (IsVisited[k - 1] == true) { throw new ArgumentException(\u0026#34;this node had been already deleted\u0026#34;); } Item temp = this.queue[k - 1]; this.IsVisited[k - 1] = true; this.count--; return temp; } } } 链表实现 #  using System; namespace _1._3._38 { class LinkedListBasedGeneralizeQueue\u0026lt;Item\u0026gt; { private class Node\u0026lt;T\u0026gt; { public T item; public Node\u0026lt;T\u0026gt; next; public bool IsVisited; } private Node\u0026lt;Item\u0026gt; first; private Node\u0026lt;Item\u0026gt; last; private int count; /// \u0026lt;summary\u0026gt;  /// 建立一个队列。  /// \u0026lt;/summary\u0026gt;  public LinkedListBasedGeneralizeQueue() { this.first = null; this.last = null; this.count = 0; } /// \u0026lt;summary\u0026gt;  /// 检查数组是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.first == null; } /// \u0026lt;summary\u0026gt;  /// 在队尾插入元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;需要插入的元素。\u0026lt;/param\u0026gt;  public void Insert(Item item) { Node\u0026lt;Item\u0026gt; oldLast = this.last; this.last = new Node\u0026lt;Item\u0026gt;() { item = item, IsVisited = false, next = null }; if (oldLast == null) { this.first = this.last; } else { oldLast.next = this.last; } count++; } /// \u0026lt;summary\u0026gt;  /// 删除第 k 个插入的结点  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;结点序号（从 1 开始）\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Delete(int k) { if (k \u0026gt; this.count || k \u0026lt;= 0) { throw new ArgumentOutOfRangeException(); } k--; //找到目标结点  Node\u0026lt;Item\u0026gt; current = this.first; for (int i = 0; i \u0026lt; k; ++i) { current = current.next; } if (current.IsVisited == true) { throw new ArgumentException(\u0026#34;this node had been already deleted\u0026#34;); } current.IsVisited = true; return current.item; } } } "},{"id":96,"href":"/1-3-39/","title":"1.3.39","section":"帮助","content":"1.3.39 #  解答 #  可以直接套用队列的实现方式，在满或空时抛出相应异常。\n代码 #  using System; namespace _1._3._39 { class RingBuffer\u0026lt;Item\u0026gt; { private Item[] buffer; private int count; private int first; //读指针  private int last; //写指针  /// \u0026lt;summary\u0026gt;  /// 建立一个缓冲区。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;N\u0026#34;\u0026gt;缓冲区的大小。\u0026lt;/param\u0026gt;  public RingBuffer(int N) { this.buffer = new Item[N]; this.count = 0; this.first = 0; this.last = 0; } /// \u0026lt;summary\u0026gt;  /// 检查缓冲区是否已满。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsFull() { return this.count == this.buffer.Length; } /// \u0026lt;summary\u0026gt;  /// 检查缓冲区是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.count == 0; } /// \u0026lt;summary\u0026gt;  /// 向缓冲区写入数据。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要写入的数据。\u0026lt;/param\u0026gt;  public void Write(Item item) { if (IsFull()) { throw new OutOfMemoryException(\u0026#34;buffer is full\u0026#34;); } this.buffer[this.last] = item; this.last = (this.last + 1) % this.buffer.Length; this.count++; } /// \u0026lt;summary\u0026gt;  /// 从缓冲区读取一个数据。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Read() { if (IsEmpty()) { throw new InvalidOperationException(); } Item temp = this.buffer[this.first]; this.first = (this.first + 1) % this.buffer.Length; this.count--; return temp; } } } "},{"id":97,"href":"/1-3-40/","title":"1.3.40","section":"帮助","content":"1.3.40 #  解答 #  每次插入时都先搜索一遍链表，再判定相应动作。\n代码 #  using System; using System.Text; namespace _1._3._40 { class MoveToFront\u0026lt;Item\u0026gt; { private class Node\u0026lt;T\u0026gt; { public T item; public Node\u0026lt;T\u0026gt; next; } private Node\u0026lt;Item\u0026gt; first; private int count; /// \u0026lt;summary\u0026gt;  /// 检查编码组是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.first == null; } /// \u0026lt;summary\u0026gt;  /// 建立一个前移编码组。  /// \u0026lt;/summary\u0026gt;  public MoveToFront() { this.first = null; this.count = 0; } /// \u0026lt;summary\u0026gt;  /// 找到相应元素的前驱结点。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要寻找的元素。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private Node\u0026lt;Item\u0026gt; Find(Item item) { if (IsEmpty()) { return null; } Node\u0026lt;Item\u0026gt; current = this.first; while (current.next != null) { if (current.next.item.Equals(item)) { return current; } current = current.next; } return null; } /// \u0026lt;summary\u0026gt;  /// 前移编码插入。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;需要插入的元素。\u0026lt;/param\u0026gt;  public void Insert(Item item) { Node\u0026lt;Item\u0026gt; temp = Find(item); if (temp == null) { temp = new Node\u0026lt;Item\u0026gt;() { item = item, next = this.first }; this.first = temp; this.count++; } else if (temp != null \u0026amp;\u0026amp; this.count != 1) { Node\u0026lt;Item\u0026gt; target = temp.next; temp.next = temp.next.next; target.next = this.first; this.first = target; } } /// \u0026lt;summary\u0026gt;  /// 查看第一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Peek() { if (this.first == null) { throw new InvalidOperationException(); } return this.first.item; } public override string ToString() { StringBuilder s = new StringBuilder(); Node\u0026lt;Item\u0026gt; current = this.first; while (current != null) { s.Append(current.item.ToString()); s.Append(\u0026#34; \u0026#34;); current = current.next; } return s.ToString(); } } } 另请参阅 #  "},{"id":98,"href":"/1-3-41/","title":"1.3.41","section":"帮助","content":"1.3.41 #  解答 #  可以按照书上的提示出队再入队，也可以直接用迭代器访问一遍进行复制。\n代码 #  /// \u0026lt;summary\u0026gt; /// 复制构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;r\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public Queue(Queue\u0026lt;Item\u0026gt; r) { foreach (Item i in r) { Enqueue(i); } } "},{"id":99,"href":"/1-3-42/","title":"1.3.42","section":"帮助","content":"1.3.42 #  解答 #  直接把链栈的整个链表复制一份即可。\n代码 #  /// \u0026lt;summary\u0026gt; /// 复制构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;s\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public Stack(Stack\u0026lt;Item\u0026gt; s) { if (s.first != null) { this.first = new Node\u0026lt;Item\u0026gt;(s.first); for (Node\u0026lt;Item\u0026gt; x = this.first; x.next != null; x = x.next) { x.next = new Node\u0026lt;Item\u0026gt;(x.next); } } this.count = s.count; } "},{"id":100,"href":"/1-3-43/","title":"1.3.43","section":"帮助","content":"1.3.43 #  解答 #  C# 中可以用 Directory 类里面的几个方法来获得文件路径和文件名。\n代码 #  using System; using System.IO; using System.Linq; namespace _1._3._43 { /* * 1.3.43 * * 文件列表。 * 文件夹就是一列文件和文件夹的列表。 * 编写一个程序，从命令行接受一个文件夹名作为参数， * 打印出该文件夹下的所有文件并用递归的方式在所有子文件夹的名下（缩进）列出其下的所有文件。 * */ class Program { static void Main(string[] args) { //获取当前目录  string path = Directory.GetCurrentDirectory(); path = Directory.GetParent(path).FullName; path = Directory.GetParent(path).FullName; //获取文件  Console.WriteLine(path + \u0026#34;中的所有文件\u0026#34;); Search(path, 0); } static void Search(string path, int tabs) { string[] dirs = Directory.GetDirectories(path); string[] files = Directory.GetFiles(path); foreach (string p in dirs) { for (int i = 0; i \u0026lt; tabs; ++i) { Console.Write(\u0026#34; \u0026#34;); } Console.WriteLine(p.Split(\u0026#39;\\\\\u0026#39;).Last()); Search(p, tabs + 1); } foreach (string f in files) { for (int i = 0; i \u0026lt; tabs; ++i) { Console.Write(\u0026#34; \u0026#34;); } Console.WriteLine(f.Split(\u0026#39;\\\\\u0026#39;).Last()); } } } } "},{"id":101,"href":"/1-3-44/","title":"1.3.44","section":"帮助","content":"1.3.44 #  解答 #  这里我们使用两个栈来模拟缓冲区。\n向左/向右移动 = 从左/右栈弹出相应数量的元素并压入另外一个栈。\n插入/删除 = 左栈压入/弹出一个元素。\n字符数量 = 左栈数量 + 右栈数量。\n代码 #  using Generics; namespace _1._3._44 { class Buffer { private Stack\u0026lt;char\u0026gt; leftside; private Stack\u0026lt;char\u0026gt; rightside; /// \u0026lt;summary\u0026gt;  /// 建立一个文本缓冲区。  /// \u0026lt;/summary\u0026gt;  public Buffer() { this.leftside = new Stack\u0026lt;char\u0026gt;(); this.rightside = new Stack\u0026lt;char\u0026gt;(); } /// \u0026lt;summary\u0026gt;  /// 在光标位置插入字符 c。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;c\u0026#34;\u0026gt;要插入的字符。\u0026lt;/param\u0026gt;  public void Insert(char c) { this.leftside.Push(c); } /// \u0026lt;summary\u0026gt;  /// 删除并返回光标位置的字符。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public char Delete() { return this.leftside.Pop(); } /// \u0026lt;summary\u0026gt;  /// 将光标向左移动 k 个位置。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;光标移动的距离。\u0026lt;/param\u0026gt;  public void Left(int k) { for (int i = 0; i \u0026lt; k; ++i) { this.rightside.Push(this.leftside.Pop()); } } /// \u0026lt;summary\u0026gt;  /// 将光标向右移动 k 个位置。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;光标移动的距离。\u0026lt;/param\u0026gt;  public void Right(int k) { for (int i = 0; i \u0026lt; k; ++i) { this.leftside.Push(this.rightside.Pop()); } } /// \u0026lt;summary\u0026gt;  /// 返回缓冲区中的字符数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() { return this.leftside.Size() + this.rightside.Size(); } /// \u0026lt;summary\u0026gt;  /// 将缓冲区的内容输出，这将使光标重置到最左端。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public string Getstring() { while (!leftside.IsEmpty()) { this.rightside.Push(this.leftside.Pop()); } return rightside.ToString(); } } } 另请参阅 #  Generics 库\n"},{"id":102,"href":"/1-3-45/","title":"1.3.45","section":"帮助","content":"1.3.45 #  解答 #  书上已经给出了思路，简单说明一下。\n第一问是给定输入判断是否会下溢出，只要记录栈中元素的数量即可，一旦为负数则返回 true。\n第二问是给定输出判断是否可能。\n对于输出序列中的每一个数，如果栈顶为空或者栈顶数字小于当前输出序列的数，那么就从输入序列中输入数字，直到栈顶数字和当前输出序列中的数字相等。\n如果当前输出序列中的数字和栈顶元素相等，从栈中弹出相应元素。\n最后如果栈为空则可能，否则不可能。\n可以结合习题 1.3.3 的解答查看。\n通用解法见下一题。\n代码 #  using System; using Generics; namespace _1._3._45 { /* * 1.3.45 * * 栈的可生成性。 * 假设我们的栈测试用例会进行一系列的入栈和出栈操作， * 序列中的整数 0, 1, ... , N - 1 （按此先后顺序排列）表示入栈操作，N个减号表示出栈操作。 * 设计一个算法，判定给定的混合序列是否会使数组向下溢出 * （你使用的空间量与 N 无关，即不能用某种数据结构存储所有整数）。 * 设计一个线性时间算法判定我们的测试用例能否产生某个给定的排列 * （这取决于出栈操作指令的出现位置）。 * */ class Program { static void Main(string[] args) { //给定输入序列，判断是否会出现下溢出。  string input = \u0026#34;- 0 1 2 3 4 5 6 7 8 9 - - - - - - - - -\u0026#34;; Console.WriteLine(IsUnderflow(input.Split(\u0026#39; \u0026#39;)));//True  input = \u0026#34;0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 -\u0026#34;; Console.WriteLine(IsUnderflow(input.Split(\u0026#39; \u0026#39;)));//False  //给定输出序列，判定是否可能。  int[] output = { 4, 3, 2, 1, 0, 9, 8, 7, 6, 5 }; Console.WriteLine(IsOutputPossible(output));//True  output = new int[]{ 4, 6, 8, 7, 5, 3, 2, 9, 0, 1}; Console.WriteLine(IsOutputPossible(output));//False  } /// \u0026lt;summary\u0026gt;  /// 判断是否会出现下溢出。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;input\u0026#34;\u0026gt;输入序列。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  static bool IsUnderflow(string[] input) { //记录栈中元素数量，如果元素数量小于 0 则会出现下溢出。  int count = 0; foreach (string s in input) { if (count \u0026lt; 0) { return true; } if (s.Equals(\u0026#34;-\u0026#34;)) { count--; } else { count++; } } return false; } /// \u0026lt;summary\u0026gt;  /// 判断输出序列是否正确。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;output\u0026#34;\u0026gt;输出序列。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  static bool IsOutputPossible(int[] output) { int input = 0; int N = output.Length; Stack\u0026lt;int\u0026gt; stack = new Stack\u0026lt;int\u0026gt;(); foreach (int i in output) { //如果栈为空，则从输入序列中压入一个数。  if (stack.IsEmpty()) { stack.Push(input); input++; } //如果输入序列中的所有数都已经入栈过了，跳出循环。  if (input == N \u0026amp;\u0026amp; stack.Peek() != i) { break; } //如果输出序列的下一个数不等于栈顶的数，那么就从输入序列中压入一个数。  while (stack.Peek() != i \u0026amp;\u0026amp; input \u0026lt; N) { stack.Push(input); input++; } //如果栈顶的数等于输出的数，弹出它。  if (stack.Peek() == i) { stack.Pop(); } } return stack.IsEmpty(); } } } 另请参阅 #  Generics 库\n"},{"id":103,"href":"/1-3-46/","title":"1.3.46","section":"帮助","content":"1.3.46 #  解答 #  这道题的解答参考了这篇博文：http://ceeji.net/blog/forbidden-triple-for-stack-generability/。\n显然书中的解答已经十分明确，这里简单说明一下：\n首先有结论：对于栈顶元素 Sn，栈中所有小于 Sn 的值都以递减形式保存（已经输出的不算）。\n表现在输出序列中，Sn 输出之后，如果有小于 Sn 的值输出，其顺序必定是递减的。\n例如序列 4 3 2 1 0 9 8 7 6 5\n4 输出之后，3 2 1 0 递减输出；9 输出之后，8 7 6 5 递减输出。\n依次验证其中的每个值都能满足结论。\n而对于序列 4 6 8 7 5 3 2 9 0 1\n对于 4，之后的 3 2 1 0 并不是以递减顺序输出的，因此这个序列是不合法的。\n"},{"id":104,"href":"/1-3-47/","title":"1.3.47","section":"帮助","content":"1.3.47 #  解答 #  这里用的都是链式结构，头尾相接即可。\n代码 #  Queue #  /// \u0026lt;summary\u0026gt; /// 在当前队列之后附加一个队列。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;q1\u0026#34;\u0026gt;需要被附加的队列。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;q2\u0026#34;\u0026gt;需要附加的队列（将被删除）。\u0026lt;/param\u0026gt; public static Queue\u0026lt;Item\u0026gt; Catenation(Queue\u0026lt;Item\u0026gt; q1, Queue\u0026lt;Item\u0026gt; q2) { if (q1.IsEmpty()) { q1.first = q2.first; q1.last = q2.last; q1.count = q2.count; } else { q1.last.next = q2.first; q1.last = q2.last; q1.count += q2.count; } q2 = null; return q1; } Stack #  /// \u0026lt;summary\u0026gt; /// 将两个栈连接。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;s1\u0026#34;\u0026gt;第一个栈。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;s2\u0026#34;\u0026gt;第二个栈（将被删除）。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static Stack\u0026lt;Item\u0026gt; Catenation(Stack\u0026lt;Item\u0026gt; s1, Stack\u0026lt;Item\u0026gt; s2) { if (s1.IsEmpty()) { s1.first = s2.first; s1.count = s2.count; } else { Node\u0026lt;Item\u0026gt; last = s1.first; while (last.next != null) { last = last.next; } last.next = s2.first; s1.count += s2.count; } s2 = null; return s1; } Steque #  /// \u0026lt;summary\u0026gt; /// 将两个 Steque 连接。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;s1\u0026#34;\u0026gt;第一个 Steque \u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;s2\u0026#34;\u0026gt;第二个 Steque （将被删除）\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static Steque\u0026lt;Item\u0026gt; Catenation(Steque\u0026lt;Item\u0026gt; s1, Steque\u0026lt;Item\u0026gt; s2) { if (s1.IsEmpty()) { s1.first = s2.first; s1.last = s2.last; s1.count = s2.count; } else { s1.last.next = s2.first; s1.count += s2.count; } s2 = null; return s1; } "},{"id":105,"href":"/1-3-48/","title":"1.3.48","section":"帮助","content":"1.3.48 #  解答 #  按照双向队列原本的操作就可以实现，需要维护两个栈的长度以防越界。（左侧栈弹出了右侧栈栈底的内容）\n代码 #  using System; using System.Collections; using System.Collections.Generic; namespace _1._3._48 { public class DeStack\u0026lt;Item\u0026gt; : IEnumerable\u0026lt;Item\u0026gt; { private class DoubleNode\u0026lt;T\u0026gt; { public T item; public DoubleNode\u0026lt;T\u0026gt; next; public DoubleNode\u0026lt;T\u0026gt; prev; } DoubleNode\u0026lt;Item\u0026gt; first; DoubleNode\u0026lt;Item\u0026gt; last; int leftcount; int rightcount; /// \u0026lt;summary\u0026gt;  /// 默认构造函数，建立一个双端栈。  /// \u0026lt;/summary\u0026gt;  public DeStack() { this.first = null; this.last = null; this.leftcount = 0; this.rightcount = 0; } /// \u0026lt;summary\u0026gt;  /// 检查左侧栈是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsLeftEmpty() { return this.leftcount == 0; } /// \u0026lt;summary\u0026gt;  /// 检查右侧栈是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsRightEmpty() { return this.rightcount == 0; } /// \u0026lt;summary\u0026gt;  /// 返回左侧栈中元素的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int LeftSize() { return this.leftcount; } /// \u0026lt;summary\u0026gt;  /// 返回右侧栈中元素的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int RightSize() { return this.rightcount; } /// \u0026lt;summary\u0026gt;  /// 向左端添加一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要添加的元素。\u0026lt;/param\u0026gt;  public void PushLeft(Item item) { DoubleNode\u0026lt;Item\u0026gt; oldFirst = this.first; this.first = new DoubleNode\u0026lt;Item\u0026gt;() { item = item, prev = null, next = oldFirst }; if (oldFirst == null) { this.last = this.first; } else { oldFirst.prev = this.first; } this.leftcount++; } /// \u0026lt;summary\u0026gt;  /// 向右端添加一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要添加的元素。\u0026lt;/param\u0026gt;  public void PushRight(Item item) { DoubleNode\u0026lt;Item\u0026gt; oldLast = this.last; this.last = new DoubleNode\u0026lt;Item\u0026gt;() { item = item, prev = oldLast, next = null }; if (oldLast == null) { this.first = this.last; } else { oldLast.next = this.last; } this.rightcount++; } /// \u0026lt;summary\u0026gt;  /// 从右端删除并返回一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item PopRight() { if (IsRightEmpty()) { throw new InvalidOperationException(); } Item temp = this.last.item; this.last = this.last.prev; this.rightcount--; if (this.last == null) { this.first = null; } else { this.last.next.item = default(Item); this.last.next = null; } return temp; } /// \u0026lt;summary\u0026gt;  /// 从左端删除并返回一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item PopLeft() { if (IsLeftEmpty()) { throw new InvalidOperationException(); } Item temp = this.first.item; this.first = this.first.next; this.leftcount--; if (this.first == null) { this.last = null; } else { this.first.prev.item = default(Item); this.first.prev = null; } return temp; } public IEnumerator\u0026lt;Item\u0026gt; GetEnumerator() { return new DequeEnumerator(this.first); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class DequeEnumerator : IEnumerator\u0026lt;Item\u0026gt; { private DoubleNode\u0026lt;Item\u0026gt; current; private DoubleNode\u0026lt;Item\u0026gt; first; public DequeEnumerator(DoubleNode\u0026lt;Item\u0026gt; first) { this.current = new DoubleNode\u0026lt;Item\u0026gt;(); this.current.next = first; this.current.prev = null; this.first = this.current; } public Item Current =\u0026gt; current.item; object IEnumerator.Current =\u0026gt; current.item; public void Dispose() { this.current = null; this.first = null; } public bool MoveNext() { if (this.current.next == null) return false; this.current = this.current.next; return true; } public void Reset() { this.current = this.first; } } } } "},{"id":106,"href":"/1-3-49/","title":"1.3.49","section":"帮助","content":"1.3.49 #  解答 #  那么这里就使用六个栈来解决这个问题。\n这个算法来自于这篇论文。\n原文里用的是 Pure Lisp，不过语法很简单，还是很容易看懂的。\n先导知识——用两个栈模拟一个队列 #  如何使用两个栈来模拟一个队列操作？\n这是一道很经典的题目，答案也有很多种，这里只介绍之后会用到的一种方法。\n首先我们有两个栈，H 和 T，分别用作出队和入队用。\n这样，入队操作等同于向 T 添加元素，T 的入栈操作只需要 O(1) 时间。\n如果 H 不为空，出队操作等同于 H 弹栈，H 的弹栈操作也只需要 O(1) 时间。\n但如果 H 为空，则需要将 T 中的元素依次弹出并压入到 H 中，这是一个 O(n) 的操作。\n显然，这种方式中，出队操作的最坏时间复杂度是 O(n)，并不满足题目要求。\n分摊 O(n) #  那么，怎么解决这个问题呢？\n一个很自然的想法是，如果在栈 H 变为空之前，我们就能逐步将栈 T 的内容弹出并压入到另一个栈 H' 中，等到栈 H 为空时，直接交换 H 和 H' 即可。\n假设目前的队列状态是这样，有三个元素等待出队，还有三个元素等待入队。\n现在依次让三个元素出队，与此同时我们让栈 T 中的元素依次进入 H' 中。\n每一次出队都执行两个操作，元素出队和元素复制（Pop \u0026amp; Push），时间复杂度 O(1) + O(1) + O(1) = O(1)。\n第一次操作（出队）\n第二次操作（出队）\n第三次操作（出队）\n现在栈 H 和栈 T 都为空，下一次出队操作时，我们直接交换栈 H 和栈 H'（由于是交换引用，因此时间复杂度仍为 O(1)）。\n之后再进行出队操作。\n这就是这个算法基本想法，在栈 H 变为空之前，分步将栈 T 中的内容分步复制到另一个栈中。\n当栈 H 为空时直接用准备好的栈 H' 替代 H，保证时间复杂度为常数。\n对复制时 Enqueue 的支持和 T' 的引入 #  刚才是一种理想情况，显然我们的队列在复制时不可能只发生出队操作，为了增加对入队操作的支持，我们引入临时栈 T'。\n例如我们有队列状态如下，现在启动复制进程，入队操作全部由 T' 完成。\n我们进行一次入队操作和两次出队操作，如下组图所示：\n第一次操作（入队）\n第二次操作（出队）\n第三次操作（出队）\n现在 H 和 T 均为空，下一次操作时（不论入队还是出队），我们先交换 H 和 H' 以及 T 和 T'，同时让入队操作控制权回到 T。\n这样，我们增加了对复制时入队操作的支持，但还并不完全，只有在理想情况下才可以做到。\nh 与 HR ，对复制时出入队序列支持的扩展 #  在之前的例子中，当复制结束时 H 总是为空的，现在我们来讨论一下复制结束时 H 不为空的情况。\n如果复制结束时 H 不为空，直接交换的结果是我们丢失了原来栈 H 中的数据。\n因此，在翻转 T 的同时，我们还应翻转 H 到 HR，并在最后将 HR 的内容再度翻转并添加到 H' 上。\n这个过程可以以下图方式进行：\n初始状态：\n第一次操作（入队），H-\u0026gt;HR ,T-\u0026gt;H'，时间复杂度 O(1) + O(1) + O(1) + O(1) + O(1) = O(1)。\n第二次操作（入队）\n第三次操作（入队）\n第四次操作（入队）\n第五次操作（入队）\n第六次操作（出/入队执行前）\n这样我们就解决了 H 复制结束后不为空的问题，代价是引入了两个额外的问题：\n问题一：操作次数增加到了 2k 次，k 代表栈 T 中的元素数量。（如果当 T 中元素数量大于 H 中元素数量时开始复制）\n问题二：由于 H 被用于复制进程，我们无法在复制过程中支持出队操作。\n第一个问题解决方案比较简单，我们可以在每一次出/入队操作执行时进行两次的复制步骤（对 T 和 H 进行两次的 Pop 操作），时间复杂度仍为 O(1)。\n第二个问题我们通过引入栈 h 来解决。\nh 用于在复制时代替 H 执行出队功能，它会在复制开始时自动变为栈 H 的一个浅拷贝（也就是说，h 和 H 共用同一片内存空间，但它们用于指示栈顶位置的指针相互独立）。\n现在我们有了全部 6 个栈，它们的功能如下图所示（为了方便介绍我将一些栈的位置做了调换）。\n由于我们并不能预知接下来会发生的操作，因此当 H 栈中的元素数量第一次小于 T 栈中的元素数量时，我们就必须启动复制进程了（总是假设接下来全部都是出队操作）。我们引入一个布尔类型变量 IsCopying 来指示复制进程。\n现在我们进行第一次入队操作，IsCopying = true，开始复制。\n首先 h 变为 H 的浅拷贝，这个过程是 O(1) 的。\n如果在复制过程中有出队操作，作为 H 的翻转 HR 中就有一个元素不再需要复制，我们引入一个变量 needcopy 来记录 HR 中需要复制的元素数量。\n接下来是两次复制操作，T 和 H 分别有两个元素进入了 H' 和 HR 。\n然后是第二次出/入队操作，这次我们选择出队，1 出队后显然 HR 中的 1 不再需要复制，needcopy – 1。\n随后再是两次复制操作，第一次将 H 中的 3 移到 HR 中，needcopy + 1，T 中的 5 移到 H' 中；第二次只将 T 中的 4 移到 H' 中。\n第三次出/入队操作我们选择入队，8 入队。随后 HR 中的两个元素进入了 H'，needcopy – 2。\n由于 needcopy 变成了 0，我们再额外进行一次交换操作，并将 IsCopying 置为 false。\n至此，完整的算法运行完毕。\n有关复制开始时机的证明 #  这里我们选择了在第 k + 1 个元素入队时开始复制，现在证明一定能够在 h 空之前完成复制：\n假设复制开始时 H 有 k 个元素，T 有 k + 1个元素。\n完成第一轮复制（H-\u0026gt;HR , T-\u0026gt;H'）需要 k + 1 次操作，\n完成第二轮复制（H-\u0026gt;H'）需要 k 次操作，总共需要 2k + 1 次操作才能完成复制。\n而 h 的长度为 k，能够提供 2k 次的操作机会。第 k + 1 个元素入队时也能提供 2 次操作机会，因此一共是 2k + 2 次操作机会。\n由于 2k + 1 \u0026lt; 2k + 2，我们证明了该算法能够及时完成复制工作。\n程序设计 #  根据之前的内容，我们可以开始设计程序了。主要实现三个功能，Enqueue(), Dequeue() 和 Peek()。\n根据算法要求我们添加一个进行复制时操作的函数 OneStep()，用于执行元素的复制，栈交换等操作。\nPeek() 只需要根据是否在进行复制选择栈 h 或栈 H 进行 Peek()。\nEnqueue()\n1. 如果不处于复制状态 1. 如果 H.Length – T.Length \u0026gt; 0，直接将元素压入栈 T。 2. 否则令 IsCopying = true，h 进行浅拷贝，进行两次的 OneStep。 2. 如果处于复制状态，将元素压入 T'，进行两次的 OneStep Dequeue()\n1. 如果不处于复制状态 1. 如果 H.Length – T.Length \u0026gt; 0，直接从 H 弹出元素。 2. 否则从 H 弹出元素，IsCopying = true，h 进行浅拷贝，进行两次的 OneStep。 2. 如果处于复制状态，从 h 弹出元素，needcopy - 1，进行两次的 OneStep。 OneStep()\n1. 如果不处于复制状态，什么也不做。 2. 如果处于复制状态。 1. 如果 H 和 T 都不为空，从 H 搬运一个元素至 HR ，从 T 搬运一个元素至 H' ，needcopy + 1。 2. 如果 H 为空但 T 不为空，从 T 搬运一个元素至 H' 。 3. 如果 H 和 T 都为空，但 needcopy \u0026gt; 1，从 HR 搬运一个元素至 H' ，needcopy – 1。 4. 如果 H 和 T 都为空，但 needcopy = 1，从 HR 搬运一个元素至 H' ，needcopy – 1，交换 H 和 H' 以及 T 和 T'，其他栈置空，退出复制状态。 5. 如果 H 和 T 都为空，但 needcopy = 0，交换 H 和 H' 以及 T 和 T'，其他栈置空，退出复制状态。 代码 #  using Generics; namespace _1._3._49 { class StackQueue\u0026lt;Item\u0026gt; { Stack\u0026lt;Item\u0026gt; H; Stack\u0026lt;Item\u0026gt; T; Stack\u0026lt;Item\u0026gt; h; Stack\u0026lt;Item\u0026gt; HH; Stack\u0026lt;Item\u0026gt; TT; Stack\u0026lt;Item\u0026gt; Hr; bool isRecopying; int nowcopying; public StackQueue() { this.isRecopying = false; this.nowcopying = 0; this.H = new Stack\u0026lt;Item\u0026gt;(); this.T = new Stack\u0026lt;Item\u0026gt;(); this.h = new Stack\u0026lt;Item\u0026gt;(); this.HH = new Stack\u0026lt;Item\u0026gt;(); this.TT = new Stack\u0026lt;Item\u0026gt;(); this.Hr = new Stack\u0026lt;Item\u0026gt;(); } public Item Peek() { if (this.isRecopying) { return h.Peek(); } else { return H.Peek(); } } public void Enqueue(Item item) { if (!this.isRecopying \u0026amp;\u0026amp; Lendiff() \u0026gt; 0) { this.nowcopying = 0; this.T.Push(item); } else if (!this.isRecopying \u0026amp;\u0026amp; Lendiff() == 0) { this.T.Push(item); this.isRecopying = true; this.h = this.H.Copy(); OneStep(OneStep(this)); } else if (this.isRecopying) { this.TT.Push(item); OneStep(OneStep(this)); } } public int Lendiff() { return this.H.Size() - this.T.Size(); } public Item Dequeue() { if (!this.isRecopying \u0026amp;\u0026amp; Lendiff() \u0026gt; 0) { return this.H.Pop(); } else if (!this.isRecopying \u0026amp;\u0026amp; Lendiff() == 0) { Item temp = this.H.Pop(); this.h = this.H.Copy(); this.isRecopying = true; OneStep(OneStep(this)); return temp; } else { Item temp = this.h.Pop(); this.nowcopying--; OneStep(OneStep(this)); return temp; } } private static StackQueue\u0026lt;Item\u0026gt; OneStep(StackQueue\u0026lt;Item\u0026gt; q) { if (q.isRecopying \u0026amp;\u0026amp; !q.H.IsEmpty() \u0026amp;\u0026amp; !q.T.IsEmpty()) { q.nowcopying++; q.HH.Push(q.T.Pop()); q.Hr.Push(q.H.Pop()); } else if (q.isRecopying \u0026amp;\u0026amp; q.H.IsEmpty() \u0026amp;\u0026amp; !q.T.IsEmpty()) { q.isRecopying = true; q.HH.Push(q.T.Pop()); } else if (q.isRecopying \u0026amp;\u0026amp; q.H.IsEmpty() \u0026amp;\u0026amp; q.T.IsEmpty() \u0026amp;\u0026amp; q.nowcopying \u0026gt; 1) { q.isRecopying = true; q.nowcopying--; q.HH.Push(q.Hr.Pop()); } else if (q.isRecopying \u0026amp;\u0026amp; q.H.IsEmpty() \u0026amp;\u0026amp; q.T.IsEmpty() \u0026amp;\u0026amp; q.nowcopying == 1) { q.isRecopying = false; q.nowcopying--; q.HH.Push(q.Hr.Pop()); q.H = q.HH; q.T = q.TT; q.HH = new Stack\u0026lt;Item\u0026gt;(); q.TT = new Stack\u0026lt;Item\u0026gt;(); q.Hr = new Stack\u0026lt;Item\u0026gt;(); q.h = new Stack\u0026lt;Item\u0026gt;(); } else if (q.isRecopying \u0026amp;\u0026amp; q.H.IsEmpty() \u0026amp;\u0026amp; q.T.IsEmpty() \u0026amp;\u0026amp; q.nowcopying == 0) { q.isRecopying = false; q.H = q.HH; q.T = q.TT; q.HH = new Stack\u0026lt;Item\u0026gt;(); q.TT = new Stack\u0026lt;Item\u0026gt;(); q.Hr = new Stack\u0026lt;Item\u0026gt;(); q.h = new Stack\u0026lt;Item\u0026gt;(); } return q; } } } 另请参阅 #  StackOverflow-How to implement a queue with three stacks?——Stack Overflow 上关于这个问题的讨论。\nReal Time Queue Operation in Pure LISP-Robert Hood, Robert Melville——用六个栈实现常数操作队列的论文。\n"},{"id":107,"href":"/1-3-50/","title":"1.3.50","section":"帮助","content":"1.3.50 #  解答 #  初始化迭代器的时候记录栈已经进行过的 Pop 和 Push 数，迭代的时候检查这两个值是否改变，一旦改变就抛出异常。\n代码 #  private class StackEnumerator : IEnumerator\u0026lt;Item\u0026gt; { private Stack\u0026lt;Item\u0026gt; s; private int popcount; private int pushcount; private Node\u0026lt;Item\u0026gt; current; public StackEnumerator(Stack\u0026lt;Item\u0026gt; s) { this.s = s; this.current = s.first; this.popcount = s.popcount; this.pushcount = s.pushcount; } Item IEnumerator\u0026lt;Item\u0026gt;.Current =\u0026gt; current.item; object IEnumerator.Current =\u0026gt; current.item; void IDisposable.Dispose() { this.current = null; this.s = null; } bool IEnumerator.MoveNext() { if (s.popcount != this.popcount || s.pushcount != this.pushcount) throw new InvalidOperationException(\u0026#34;Stack has been modified\u0026#34;); if (this.current.next == null) return false; this.current = this.current.next; return true; } void IEnumerator.Reset() { this.current = this.s.first; } } "},{"id":108,"href":"/1-4-1/","title":"1.4.1","section":"帮助","content":"1.4.1 #  解答 #  即为证明组合计算公式：\n$C(N, 3)$\n$= N! / [(N - 3)! × 3!]$\n$= [(N - 2) * (N - 1) * N] / 3!$\n$= N(N - 1)(N - 2) / 6$\n显然 N 必须大于等于 3。\n$N = 3$ 时公式正确，只有一种组合。\n$N = 4$ 时公式正确，只有四种组合。\n扩展到 $N+1$ 个数，将 $N = N + 1$ 代入，可得：\n$(N + 1)N(N - 1) / 6$\n$N + 1$ 个数能组成的三位数组合可以这样理解\n前 N 个数中取三个数的所有组合 +多出的一个数和前 N 个数中的任意取两个数的所有组合\n即为 $N(N-1)(N - 2) / 6 + C(N, 2)$\n变形后即为 $(N + 1)N(N - 1) / 6$\n得证。\n"},{"id":109,"href":"/1-4-2/","title":"1.4.2","section":"帮助","content":"1.4.2 #  解答 #  将 a[i] + a[j] + a[k] 改为 (long)a[i] + a[j] + a[k] 即可。\n此时整个式子将按照精度最高（也就是 long）的标准计算。\nlong.MaxValue = 9223372036854775807 \u0026gt; int.MaxValue * 3 = 6442450941 代码 #  namespace Measurement { /// \u0026lt;summary\u0026gt;  /// 用暴力方法寻找数组中和为零的三元组。  /// \u0026lt;/summary\u0026gt;  public static class ThreeSum { /// \u0026lt;summary\u0026gt;  /// 输出所有和为零的三元组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;输入数组。\u0026lt;/param\u0026gt;  public static void PrintAll(int[] a) { int n = a.Length; for (int i = 0; i \u0026lt; n; ++i) { for (int j = i + 1; j \u0026lt; n; ++j) { for (int k = j + 1; k \u0026lt; n; ++k) { if ((long)a[i] + a[j] + a[k] == 0) { Console.WriteLine($\u0026#34;{a[i]} + {a[j]} + {a[k]}\u0026#34;); } } } } } /// \u0026lt;summary\u0026gt;  /// 计算和为零的三元组的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;输入数组。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static int Count(int[] a) { int n = a.Length; int count = 0; for (int i = 0; i \u0026lt; n; ++i) { for (int j = i + 1; j \u0026lt; n; ++j) { for (int k = j + 1; k \u0026lt; n; ++k) { if ((long)a[i] + a[j] + a[k] == 0) { count++; } } } } return count; } } } 另请参阅 #  Measurement 库\n"},{"id":110,"href":"/1-4-3/","title":"1.4.3","section":"帮助","content":"1.4.3 #  解答 #  见代码，这里贴出绘图函数，窗体只是在得到测试结果之后简单调用以下这两个函数。\n代码 #  public static void PaintLinear(double[] testResult) { //新建一个绘图窗口  Form2 linear = new Form2(); linear.Show(); //新建画布  Graphics canvas = linear.CreateGraphics(); //获取窗口区域  Rectangle rect = linear.ClientRectangle; //计算单位长度（十等分）  int unitY = rect.Height / 10; int unitX = rect.Width / 10; //获取中心区域（上下左右增加 10% 的内补）  Rectangle center = new Rectangle(rect.X + unitX, rect.Y + unitY, unitX * 8, unitY * 8); //绘制坐标系  canvas.DrawLine(Pens.Black, center.X, center.Y, center.X, center.Y + center.Height); canvas.DrawLine(Pens.Black, center.X, center.Y + center.Height, center.X + center.Width, center.Y + center.Height); //对 X 轴 10 等分，对 Y 轴 10 等分  int xaxisUnit = center.Width / 10; int yaxisUnit = center.Height / 10; //标记 X 轴坐标值  for (int i = 1; i \u0026lt;= 8; i += i) { canvas.DrawString(i + \u0026#34;N\u0026#34;, linear.Font, Brushes.Black, center.X + i * xaxisUnit, center.Y + center.Height); } //反转坐标系  canvas.TranslateTransform(0, linear.ClientRectangle.Height); canvas.ScaleTransform(1, -1); //计算单位长度  double Unit = center.Height / testResult[3]; //标记  PointF[] result = new PointF[4]; for (int i = 0, j = 1; i \u0026lt; 4 \u0026amp;\u0026amp; j \u0026lt;= 8; ++i, j += j) { result[i] = new PointF(center.X + j * xaxisUnit, (float)(center.Y + Unit * testResult[i])); } //链接  canvas.DrawLines(Pens.Black, result); canvas.Dispose(); } public static void PaintLogarithm(double[] testResult) { //新建一个绘图窗口  Form2 log = new Form2(); log.Show(); //新建画布  Graphics canvas = log.CreateGraphics(); //获取窗口区域  Rectangle rect = log.ClientRectangle; //计算单位长度（十等分）  int unitY = rect.Height / 10; int unitX = rect.Width / 10; //获取中心区域（上下左右增加 10% 的内补）  Rectangle center = new Rectangle(rect.X + unitX, rect.Y + unitY, unitX * 8, unitY * 8); //绘制坐标系  canvas.DrawLine(Pens.Black, center.X, center.Y, center.X, center.Y + center.Height); canvas.DrawLine(Pens.Black, center.X, center.Y + center.Height, center.X + center.Width, center.Y + center.Height); //对 X 轴 10 等分，对 Y 轴 10 等分  int xaxisUnit = center.Width / 10; int yaxisUnit = center.Height / 10; //标记 X 轴坐标值  for (int i = 1; i \u0026lt;= 8; i += i) { canvas.DrawString(i + \u0026#34;N\u0026#34;, log.Font, Brushes.Black, center.X + i * xaxisUnit, center.Y + center.Height); } //反转坐标系  canvas.TranslateTransform(0, log.ClientRectangle.Height); canvas.ScaleTransform(1, -1); //计算单位长度  double Unit = center.Height / testResult[3]; //标记  PointF[] result = new PointF[4]; for (int i = 0, j = 1; i \u0026lt; 4 \u0026amp;\u0026amp; j \u0026lt;= 8; ++i, j += j) { result[i] = new PointF(center.X + j * xaxisUnit, (float)(center.Y + Unit * testResult[i])); } //链接  canvas.DrawLines(Pens.Black, result); canvas.Dispose(); } "},{"id":111,"href":"/1-4-4/","title":"1.4.4","section":"帮助","content":"1.4.4 #  解答 #  "},{"id":112,"href":"/1-4-5/","title":"1.4.5","section":"帮助","content":"1.4.5 #  解答 #  类似于取极限的做法。\na. $N$\nb. $1$\nc. $1$\nd. $2N^3$\ne. $1$\nf. $2$\ng. $\\frac{N^{100}}{2^n}$\n"},{"id":113,"href":"/1-4-6/","title":"1.4.6","section":"帮助","content":"1.4.6 #  解答 #  a. N + N/2 + N/4 + … = ~2N，线性。\nb. 1 + 2 + 4 + … = ~2N，线性。\nc. NlogN，线性对数。\n"},{"id":114,"href":"/1-4-7/","title":"1.4.7","section":"帮助","content":"1.4.7 #  解答 #  最外层循环进行了 N 次比较。\n次外层循环进行了 N^2 次比较。\n最里层循环进行了 N^3 次比较。\n内部 if 语句进行了 N^3 次比较。\nif 内部进行了 N(N-1) 次加法。\n加起来，~2N^3。\n"},{"id":115,"href":"/1-4-8/","title":"1.4.8","section":"帮助","content":"1.4.8 #  解答 #  平方级别：直接二层循环遍历一遍。\n线性对数：\n先对数组排序，然后遍历一遍数组，在遍历过程中计算重复元素的数量，\n然后用公式 $1+2+\\cdots+n-1=n(n-1)/2$ 计算重复整数对的数量。\n代码 #  /// \u0026lt;summary\u0026gt; /// 暴力查找数组中相等的整数对。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要查找的数组。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static int CountEqual(int[] a) { int n = a.Length; int count = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { if (a[i] == a[j]) count++; } } return count; } /// \u0026lt;summary\u0026gt; /// 利用 Array.Sort 进行优化的查找相等整数对算法。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要查找的数组。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static int CountEqualLog(int[] a) { int n = a.Length; int count = 0; Array.Sort(a); int dup = 0; // dup = 重复元素数量-1  for (int i = 1; i \u0026lt; n; i++) { while (a[i - 1] == a[i]) { dup++; i++; } count += dup * (dup + 1) / 2; dup = 0; } return count; } "},{"id":116,"href":"/1-4-9/","title":"1.4.9","section":"帮助","content":"1.4.9 #  解答 #  由题意可得：\n$$\nT(2N_0)=2^bT\\\nT(4N_0)=2^b(2^bT)=2^{2b}T\\\n\u0026hellip;\u0026hellip;\\\nT(2^rN_0)=2^{rb}T\n$$\n设：\n$$\nN=2^rN_0\n$$\n则：\n$$\nr=log_2(\\frac{N}{N_0})\n$$\n所以：\n$$\nT(N) = 2^{log_2(\\frac{N}{N_0})b}T\n$$\n"},{"id":117,"href":"/1-4-10/","title":"1.4.10","section":"帮助","content":"1.4.10 #  解答 #  修改二分查找的结束条件，找到后仍然向左侧寻找，如果还能找到更小的，则返回较小的下标；否则返回当前下标。\n代码 #  namespace _1._4._10 { /// \u0026lt;summary\u0026gt;  /// 二分查找。  /// \u0026lt;/summary\u0026gt;  public class BinarySearch { /// \u0026lt;summary\u0026gt;  /// 用递归方法进行二分查找。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;关键字。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;查找范围。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;查找的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;查找的结束下标。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;返回下标，如果没有找到则返回 -1。\u0026lt;/returns\u0026gt;  public static int Rank(int key, int[] a, int lo, int hi) { if (hi \u0026lt; lo) return -1; int mid = (hi - lo) / 2 + lo; if (a[mid] == key) { int mini = Rank(key, a, lo, mid - 1); if (mini != -1) return mini; return mid; } else if (a[mid] \u0026lt; key) { return Rank(key, a, mid + 1, hi); } else { return Rank(key, a, lo, mid - 1); } } } } "},{"id":118,"href":"/1-4-11/","title":"1.4.11","section":"帮助","content":"1.4.11 #  解答 #  这里给出官网上的 Java 实现：StaticSETofInts.java。\nhowMany() 可以用二分查找实现，在找到一个值后继续向两侧查找，最后返回找到的次数。\n代码 #  using System; namespace Measurement { /// \u0026lt;summary\u0026gt;  /// 有序数组，能够快速查找并自动维护其中的顺序。  /// \u0026lt;/summary\u0026gt;  public class StaticSETofInts { private int[] a; /// \u0026lt;summary\u0026gt;  /// 用一个数组初始化有序数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;keys\u0026#34;\u0026gt;源数组。\u0026lt;/param\u0026gt;  public StaticSETofInts(int[] keys) { this.a = new int[keys.Length]; for (int i = 0; i \u0026lt; keys.Length; ++i) { this.a[i] = keys[i]; } Array.Sort(this.a); } /// \u0026lt;summary\u0026gt;  /// 检查数组中是否存在指定元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要查找的值。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;存在则返回 true，否则返回 false。\u0026lt;/returns\u0026gt;  public bool Contains(int key) { return Rank(key, 0, this.a.Length - 1) != -1; } /// \u0026lt;summary\u0026gt;  /// 返回某个元素在数组中存在的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;关键值。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;返回某个元素在数组中存在的数量。\u0026lt;/returns\u0026gt;  public int HowMany(int key) { int hi = this.a.Length - 1; int lo = 0; return HowMany(key, lo, hi); } /// \u0026lt;summary\u0026gt;  /// 返回某个元素在数组中存在的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;关键值。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;查找起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;查找结束下标。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;返回某个元素在数组中存在的数量。\u0026lt;/returns\u0026gt;  private int HowMany(int key, int lo, int hi) { int mid = Rank(key, lo, hi); if (mid == -1) return 0; else { return 1 + HowMany(key, lo, mid - 1) + HowMany(key, mid + 1, hi); } } /// \u0026lt;summary\u0026gt;  /// 二分查找。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;关键值。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;查找的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;查找的结束下标。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;返回关键值的下标，如果不存在则返回 -1。\u0026lt;/returns\u0026gt;  public int Rank(int key, int lo, int hi) { while (lo \u0026lt;= hi) { int mid = (hi - lo) / 2 + lo; if (key \u0026lt; this.a[mid]) hi = mid - 1; else if (key \u0026gt; this.a[mid]) lo = mid + 1; else return mid; } return -1; } } } 另请参阅 #  Measurement 库\nStaticSETofInts.java\n"},{"id":119,"href":"/1-4-12/","title":"1.4.12","section":"帮助","content":"1.4.12 #  解答 #  由于两个数组都是有序的，可以同时进行比较。\n设 i, j 分别为两个数组的下标。\n如果 a[i] == a[j]，i 和 j 都向后移动一位。\n如果 a[i] != a[j]，比较小的那个向后移动一位。\n循环直到某个数组遍历完毕。\n这样最后的时间复杂度 ~2N\n代码 #  using System; namespace _1._4._12 { /* * 1.4.12 * * 编写一个程序，有序打印给定的两个有序数组（含有 N 个 int 值） 中的所有公共元素， * 程序在最坏情况下所需的运行时间应该和 N 成正比。 * */ class Program { static void Main(string[] args) { int[] a = new int[4] { 2, 3, 4, 10 }; int[] b = new int[6] { 1, 3, 3, 5, 10, 11 }; //2N 次数组访问，数组 a 和数组 b 各遍历一遍  for (int i = 0, j = 0; i \u0026lt; a.Length \u0026amp;\u0026amp; j \u0026lt; b.Length; ) { if (a[i] \u0026lt; b[j]) { i++; } else if (a[i] \u0026gt; b[j]) { j++; } else { Console.WriteLine($\u0026#34;Common Element:{a[i]}, First index: (a[{i}], b[{j}])\u0026#34;); i++; j++; } } } } } "},{"id":120,"href":"/1-4-13/","title":"1.4.13","section":"帮助","content":"1.4.13 #  解答 #  对象的固定开销用 Object 表示。\na. Accumulator\n使用 1.2.4.3 节给出的实现。\n= int * 1 + double + Object * 1\n= 4 * 1 + 8 + 16 * 1 = 32\nb. Transaction\n= string * 1 + Date * 1 + double * 1 + Object * 1\n= (40 + 16 + 4 + 4 + 2N) * 1 + (8 + 32) * 1 + 8 * 1 + 16 * 1\n= 128 + 2N\nc. FixedCapacityStackOfStrings\n= string[] * 1 + string * N + int * 1 + Object * 1\n= 24 * 1 + N * (64 + 2C) + 4 * 1 + 16 * 1\n= N * (64 + 2C) + 44\n= N * (64 + 2C) + 48（填充）\nd.Point2D\n= double * 2 + Object * 1\n= 8 * 2 + 16 * 1\n= 32\ne.Interval1D\n= double * 2 + Object * 1\n= 8 * 2 + 16 * 1\n= 32\nf.Interval2D\n= Interval1D * 2 + Object * 1\n= (8 + 24) * 2 + 16 * 1\n= 80\ng.Double\n= double * 1 + Object * 1\n= 8 * 1 + 16 * 1\n= 24\n"},{"id":121,"href":"/1-4-14/","title":"1.4.14","section":"帮助","content":"1.4.14 #  解答 #  这里给出暴力方法，将最内侧循环换成二分查找即为优化版本。\n代码 #  using System; namespace Measurement { /// \u0026lt;summary\u0026gt;  /// 用暴力方法查找数组中和为零的四元组。  /// \u0026lt;/summary\u0026gt;  public static class FourSum { /// \u0026lt;summary\u0026gt;  /// 输出数组中所有和为 0 的四元组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;包含所有元素的数组。\u0026lt;/param\u0026gt;  public static void PrintAll(long[] a) { int N = a.Length; for (int i = 0; i \u0026lt; N; ++i) { for (int j = i + 1; j \u0026lt; N; ++j) { for (int k = j + 1; k \u0026lt; N; ++k) { for (int l = k + 1; l \u0026lt; N; ++l) { if (a[i] + a[j] + a[k] + a[l] == 0) { Console.WriteLine($\u0026#34;{a[i]} + {a[j]} + {a[k]} + {a[l]} = 0\u0026#34;); } } } } } } /// \u0026lt;summary\u0026gt;  /// 计算和为零的四元组的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;包含所有元素的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static int Count(long[] a) { int N = a.Length; int cnt = 0; for (int i = 0; i \u0026lt; N; ++i) { for (int j = i + 1; j \u0026lt; N; ++j) { for (int k = j + 1; k \u0026lt; N; ++k) { for (int l = k + 1; l \u0026lt; N; ++l) { if (a[i] + a[j] + a[k] + a[l] == 0) { cnt++; } } } } } return cnt; } } } 另请参阅 #  Measurement 库\n"},{"id":122,"href":"/1-4-15/","title":"1.4.15","section":"帮助","content":"1.4.15 #  解答 #  由于数组已经排序（从小到大），负数在左侧，正数在右侧。\nTwoSumFaster\n设最左侧下标为 lo，最右侧下标为 hi。\n如果 a[lo] + a[hi] \u0026gt; 0, 说明正数太大，hi\u0026ndash;。\n如果 a[lo] + a[hi] \u0026lt; 0，说明负数太小，lo++。\n否则就找到了一对和为零的整数对，lo++, hi\u0026ndash;。\nThreeSumFaster\n对于数组中的每一个数 a，ThreeSum 问题就等于求剩余数组中所有和为 -a 的 TwoSum 问题。\n只要在 TwoSumFaster 外层再套一个循环即可。\n代码 #  /// \u0026lt;summary\u0026gt; /// TwoSum 的快速实现。（线性级别） /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要查找的数组范围。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;数组中和为零的整数对数量。\u0026lt;/returns\u0026gt; static int TwoSumFaster(int[] a) { int lo = 0; int hi = a.Length - 1; int count = 0; while (lo \u0026lt; hi) { if (a[lo] + a[hi] == 0) { count++; lo++; hi--; } else if (a[lo] + a[hi] \u0026lt; 0) { lo++; } else { hi--; } } return count; } /// \u0026lt;summary\u0026gt; /// ThreeSum 的快速实现。（平方级别） /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要查找的数组范围。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;数组中和为零的三元组数量。\u0026lt;/returns\u0026gt; static int ThreeSumFaster(int[] a) { int count = 0; for (int i = 0; i \u0026lt; a.Length; ++i) { int lo = i + 1; int hi = a.Length - 1; while (lo \u0026lt;= hi) { if (a[lo] + a[hi] + a[i] == 0) { count++; lo++; hi--; } else if (a[lo] + a[hi] + a[i] \u0026lt; 0) { lo++; } else { hi--; } } } return count; } "},{"id":123,"href":"/1-4-16/","title":"1.4.16","section":"帮助","content":"1.4.16 #  解答 #  先将数组从小到大排序，再遍历一遍即可得到差距最小的两个数。\n排序算法需要消耗 NlogN，具体见 MSDN：Array.Sort 方法 (Array)。\n代码 #  using System; namespace _1._4._16 { /* * 1.4.16 * * 最接近一对（一维）。 * 编写一个程序，给定一个含有 N 个 double 值的数组 a[]， * 在其中找到一对最接近的值：两者之差（绝对值）最小的两个数。 * 程序在最坏情况下所需的运行时间应该是线性对数级别的。 * */ class Program { //总运行时间： NlogN + N = NlogN  static void Main(string[] args) { double[] a = new double[5] { 0.1, 0.3, 0.6, 0.8, 0 }; Array.Sort(a);//Nlog(N) 具体见 https://msdn.microsoft.com/zh-cn/library/6tf1f0bc(v=vs.110).aspx 备注部分  double minDiff = double.MaxValue; double minA = 0; double minB = 0; for (int i = 0; i \u0026lt; a.Length - 1; ++i)//N  { if (a[i + 1] - a[i] \u0026lt; minDiff) { minA = a[i]; minB = a[i + 1]; minDiff = a[i + 1] - a[i]; } } Console.WriteLine($\u0026#34;Min Pair: {minA} {minB}, Min Value: {minDiff}\u0026#34;); } } } 另请参阅 #  MSDN-Array.Sort 方法 (Array)\n"},{"id":124,"href":"/1-4-17/","title":"1.4.17","section":"帮助","content":"1.4.17 #  解答 #  遍历找到最小值和最大值即可。\n代码 #  using System; namespace _1._4._17 { /* * 1.4.17 * * 最遥远的一对（一维）。 * 编写一个程序，给定一个含有 N 个 double 值的数组 a[]， * 在其中找到一对最遥远的值：两者之差（绝对值）最大的两个数。 * 程序在最坏情况下所需的运行时间应该是线性级别的。 * */ class Program { static void Main(string[] args) { double[] a = new double[5] { 0.1, 0.3, 0.6, 0.8, 0 }; double min = int.MaxValue; double max = int.MinValue; for (int i = 0; i \u0026lt; a.Length; ++i) { if (a[i] \u0026gt; max) { max = a[i]; } if (a[i] \u0026lt; min) { min = a[i]; } } Console.WriteLine($\u0026#34;MaxDiff Pair: {min} {max}, Max Difference: {Math.Abs(max - min)}\u0026#34;); } } } "},{"id":125,"href":"/1-4-18/","title":"1.4.18","section":"帮助","content":"1.4.18 #  解答 #  和二分查找的方式类似，先确认中间的值是否是局部最小，如果不是，则向较小的一侧二分查找。\n在三个数中比较得到最小值需要两次比较，因此最坏情况下为 $~2\\lg N$ 次比较。\n代码 #  using System; namespace _1._4._18 { class Program { static void Main(string[] args) { var a = new int[5] { 1, 2, 5, 3, 5 }; Console.WriteLine(LocalMinimum(a)); } /// \u0026lt;summary\u0026gt;  /// 寻找数组的局部最小元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;寻找范围。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;局部最小元素的值。\u0026lt;/returns\u0026gt;  static int LocalMinimum(int[] a) { int lo = 0; int hi = a.Length - 1; while (lo \u0026lt;= hi) { int mid = (hi - lo) / 2 + lo; int min = mid; // 取左中右最小值的下标  if (mid != hi \u0026amp;\u0026amp; a[min] \u0026gt;= a[mid + 1]) min = mid + 1; if (mid != lo \u0026amp;\u0026amp; a[min] \u0026gt;= a[mid - 1]) min = mid - 1; if (min == mid) return mid; if (min \u0026gt; mid) lo = min; else hi = min; } return -1; } } } "},{"id":126,"href":"/1-4-19/","title":"1.4.19","section":"帮助","content":"1.4.19 #  解答 #  问题类似于 POJ 上的一道题「滑雪」，从数值较高的一侧向周围数值较小的一侧移动，直到到达「山谷」（局部最小）。\n首先在中间行搜索最小值，再将最小值与其上下两个元素比较，如果不满足题意，则“滑向”较小的一侧，矩阵被分为了两半（上下两侧）。\n在较小的一侧，找到中间列的最小值，再将最小值与其左右两个元素比较，如果不满足题意，类似的移动到较小的一侧（左右两侧）。\n现在查找范围缩小到了原来矩阵的四分之一，递归的进行上述操作，最后可以得到答案。\n每次查找最小值都是对行/列进行遍历，遍历耗时和 N 成正比。\n代码 #  using System; namespace _1._4._19 { /* * 1.4.19 * * 矩阵的局部最小元素。 * 给定一个含有 N^2 个不同整数的 N×N 数组 a[]。 * 设计一个运行时间和 N 成正比的算法来找出一个局部最小元素： * 满足 a[i][j] \u0026lt; a[i+1][j]、a[i][j] \u0026lt; a[i][j+1]、a[i][j] \u0026lt; a[i-1][j] 以及 a[i][j] \u0026lt; a[i][j-1] 的索引 i 和 j。 * 程序运行时间在最坏情况下应该和 N 成正比。 * */ class Program { // 先查找 N/2 行中的最小元素，并令其与上下元素比较，  // 如果不满足题意，则向相邻的最小元素靠近再次查找  static void Main(string[] args) { int[,] matrix = new int[5, 5] { { 26, 3, 4 , 10, 11 }, { 5, 1, 6, 12, 13 }, { 7, 8, 9 , 14, 15 }, { 16, 17, 18, 27, 20 }, { 21, 22, 23, 24, 25 } }; Console.WriteLine(MinimumRow(matrix, 0, 5, 0, 5)); } /// \u0026lt;summary\u0026gt;  /// 在矩阵中间行查找局部最小。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;matrix\u0026#34;\u0026gt;矩阵。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;rowStart\u0026#34;\u0026gt;实际查找范围的行起始。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;rowLength\u0026#34;\u0026gt;实际查找范围的行结尾。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;colStart\u0026#34;\u0026gt;实际查找范围的列起始。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;colLength\u0026#34;\u0026gt;实际查找范围的列结尾。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;矩阵中的局部最小元素。\u0026lt;/returns\u0026gt;  static int MinimumRow(int[,] matrix, int rowStart, int rowLength, int colStart, int colLength) { int min = int.MaxValue; if (rowLength \u0026lt; 3) return int.MaxValue; int mid = rowStart + rowLength / 2; int minCol = 0; // 获取矩阵中间行的最小值  for (int i = 0; i \u0026lt; colLength; ++i) { if (min \u0026gt; matrix[mid, colStart + i]) { min = matrix[mid, colStart + i]; minCol = i; } } // 检查是否满足条件  if (matrix[mid, minCol] \u0026lt; matrix[mid - 1, minCol] \u0026amp;\u0026amp; matrix[mid, minCol] \u0026lt; matrix[mid + 1, minCol]) { return matrix[mid, minCol]; } // 如果不满足则向较小一侧移动  if (matrix[mid - 1, minCol] \u0026gt; matrix[mid + 1, minCol]) { return MinimumCol(matrix, rowStart, rowLength, mid + 1, colLength / 2 + 1); } else { return MinimumCol(matrix, rowStart, rowLength, colStart, colLength / 2 + 1); } } /// \u0026lt;summary\u0026gt;  /// 在矩阵中间列查找局部最小。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;matrix\u0026#34;\u0026gt;矩阵。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;rowStart\u0026#34;\u0026gt;实际查找范围的行起始。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;rowLength\u0026#34;\u0026gt;实际查找范围的行结尾。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;colStart\u0026#34;\u0026gt;实际查找范围的列起始。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;colLength\u0026#34;\u0026gt;实际查找范围的列结尾。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;矩阵中的局部最小元素。\u0026lt;/returns\u0026gt;  static int MinimumCol(int[,] matrix, int rowStart, int rowLength, int colStart, int colLength) { int min = int.MaxValue; int n = matrix.GetLength(0); int mid = n / 2; int minRow = 0; // 获取矩阵中间列最小值  for (int i = 0; i \u0026lt; n; ++i) { if (min \u0026gt; matrix[i, mid]) { min = matrix[i, mid]; minRow = i; } } // 检查是否满足条件  if (matrix[minRow, mid] \u0026lt; matrix[minRow, mid - 1] \u0026amp;\u0026amp; matrix[minRow, mid] \u0026lt; matrix[minRow, mid + 1]) { return matrix[minRow, mid]; } // 如果不满足则向较小一侧移动  if (matrix[minRow, mid - 1] \u0026gt; matrix[minRow, mid + 1]) { return MinimumRow(matrix, mid + 1, rowLength / 2 + 1, colStart, colLength); } else { return MinimumRow(matrix, rowStart, rowLength / 2 + 1, colStart, colLength); } } } } 另请参阅 #  POJ-滑雪\n"},{"id":127,"href":"/1-4-20/","title":"1.4.20","section":"帮助","content":"1.4.20 #  解答 #  首先给出 BitMax 类的官方 Java 实现：BitonicMax.java。\n我们使用这个类生成双调数组，并使用其中的 Max() 方法找到双调数组的最大值。\n找到最大值之后分别对左右两侧进行二分查找，注意对于升序和降序的数组二分查找的实现有所不同。\n代码 #  BitonicMax 类 #  using System; namespace _1._4._20 { /// \u0026lt;summary\u0026gt;  /// 双调查找类。  /// \u0026lt;/summary\u0026gt;  public class BitonicMax { /// \u0026lt;summary\u0026gt;  /// 生成双调数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;N\u0026#34;\u0026gt;数组的大小。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static int[] Bitonic(int N) { Random random = new Random(); int mid = random.Next(N); int[] a = new int[N]; for (int i = 1; i \u0026lt; mid; ++i) { a[i] = a[i - 1] + 1 + random.Next(9); } if (mid \u0026gt; 0) { a[mid] = a[mid - 1] + random.Next(10) - 5; } for (int i = mid + 1; i \u0026lt; N; ++i) { a[i] = a[i - 1] - 1 - random.Next(9); } return a; } /// \u0026lt;summary\u0026gt;  /// 寻找数组中的最大值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;查找范围。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;查找起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;查找结束下标。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;返回数组中最大值的下标。\u0026lt;/returns\u0026gt;  public static int Max(int[] a, int lo, int hi) { if (lo == hi) { return hi; } int mid = lo + (hi - lo) / 2; if (a[mid] \u0026lt; a[mid + 1]) { return Max(a, mid + 1, hi); } if (a[mid] \u0026gt; a[mid + 1]) { return Max(a, lo, mid); } return mid; } } } 主程序 #  using System; namespace _1._4._20 { /* * 1.4.20 * * 双调查找。 * 如果一个数组中的所有元素是先递增后递减的，则称这个数组为双调的。 * 编写一个程序，给定一个含有 N 个不同 int 值的双调数组，判断它是否含有给定的整数。 * 程序在最坏情况下所需的比较次数为 ~3lgN * */ class Program { static void Main(string[] args) { int[] a = BitonicMax.Bitonic(100); int max = BitonicMax.Max(a, 0, a.Length - 1); int key = a[50]; int leftside = BinarySearchAscending(a, key, 0, max); int rightside = BinarySearchDescending(a, key, max, a.Length - 1); if (leftside != -1) { Console.WriteLine(leftside); } else if (rightside != -1) { Console.WriteLine(rightside); } else { Console.WriteLine(\u0026#34;No Result\u0026#34;); } } /// \u0026lt;summary\u0026gt;  /// 对升序数组的二分查找。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;升序数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;关键值。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;查找的左边界。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;查找的右边界。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;返回找到关键值的下标，如果没有找到则返回 -1。\u0026lt;/returns\u0026gt;  static int BinarySearchAscending(int[] a, int key, int lo, int hi) { while (lo \u0026lt;= hi) { int mid = lo + (hi - lo) / 2; if (a[mid] \u0026lt; key) { lo = mid + 1; } else if (a[mid] \u0026gt; key) { hi = mid - 1; } else { return mid; } } return -1; } /// \u0026lt;summary\u0026gt;  /// 对降序数组的二分查找。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;升序数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;关键值。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;查找的左边界。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;查找的右边界。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;返回找到关键值的下标，如果没有找到则返回 -1。\u0026lt;/returns\u0026gt;  static int BinarySearchDescending(int[] a, int key, int lo, int hi) { while (lo \u0026lt; hi) { int mid = lo + (hi - lo) / 2; if (a[mid] \u0026gt; key) { lo = mid + 1; } else if (a[mid] \u0026lt; key) { hi = mid - 1; } else { return mid; } } return -1; } } } 另请参阅 #  BitonicMax.java\n"},{"id":128,"href":"/1-4-21/","title":"1.4.21","section":"帮助","content":"1.4.21 #  解答 #  直接将 Contains() 实现为二分查找即可。\n代码 #  /// \u0026lt;summary\u0026gt; /// 检查数组中是否存在指定元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要查找的值。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;存在则返回 true，否则返回 false。\u0026lt;/returns\u0026gt; public bool Contains(int key) { return Rank(key, 0, this.a.Length - 1) != -1; } /// \u0026lt;summary\u0026gt; /// 二分查找。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;关键值。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;查找的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;查找的结束下标。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;返回关键值的下标，如果不存在则返回 -1。\u0026lt;/returns\u0026gt; public int Rank(int key, int lo, int hi) { while (lo \u0026lt;= hi) { int mid = (hi - lo) / 2 + lo; if (key \u0026lt; this.a[mid]) hi = mid - 1; else if (key \u0026gt; this.a[mid]) lo = mid + 1; else return mid; } return -1; } "},{"id":129,"href":"/1-4-22/","title":"1.4.22","section":"帮助","content":"1.4.22 #  解答 #  普通二分查找是通过除法不断减半缩小搜索范围。\n这里我们用斐波那契数列来缩小范围。\n举个例子，例如数组大小是 100，比它大的最小斐波那契数是 144。\n斐波那契数列如下：0 1 1 2 3 5 8 13 21 34 55 89 144\n我们记 F(n) = 144,F(n-1) = 89, F(n-2) = 55。\n我们先查看第 0 + F(n-2) 个数，如果比关键值小则直接将范围缩小到 [55, 100]；否则则在[0, 55]之间查找。\n之后我们令 n = n-1。\n递归上述过程即可完成查找。\n代码 #  /// \u0026lt;summary\u0026gt; /// 使用斐波那契数列进行的查找。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;查找范围。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;关键字。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;返回查找到的关键值下标，没有结果则返回 -1。\u0026lt;/returns\u0026gt; static int rank(int[] a, int key) { // 使用斐波那契数列作为缩减范围的依据  int Fk = 1; int Fk_1 = 1; int Fk_2 = 0; // 获得 Fk，Fk需要大于等于数组的大小，复杂度 lgN  while (Fk \u0026lt; a.Length) { Fk = Fk + Fk_1; Fk_1 = Fk_1 + Fk_2; Fk_2 = Fk - Fk_1; } int lo = 0; // 按照斐波那契数列缩减查找范围，复杂度 lgN  while (Fk_2 \u0026gt;= 0) { int i = lo + Fk_2 \u0026gt; a.Length - 1 ? a.Length - 1 : lo + Fk_2; if (a[i] \u0026lt; key) { lo = lo + Fk_2; } else if (a[i] == key) { return i; } Fk = Fk_1; Fk_1 = Fk_2; Fk_2 = Fk - Fk_1; } return -1; } "},{"id":130,"href":"/1-4-23/","title":"1.4.23","section":"帮助","content":"1.4.23 #  解答 #  根据书中的提示，将二分查找中判断相等的条件改为两个数的差小于等于 $1/N^2$。\n代码 #  // 将二分查找中的相等判定条件修改为差值小于 x，其中 x = 1/N^2。 /// \u0026lt;summary\u0026gt; /// 二分查找。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;查找范围。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;关键字。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;结果的下标，没有结果时返回 -1。\u0026lt;/returns\u0026gt; static int BinarySearch(double[] a, double key) { int lo = 0; int hi = a.Length - 1; double threshold = 1.0 / (a.Length * a.Length); while (lo \u0026lt;= hi) { int mid = lo + (hi - lo) / 2; if (Math.Abs(a[mid] - key) \u0026lt;= threshold) { return mid; } else if (a[mid] \u0026lt; key) { lo = mid + 1; } else { hi = mid - 1; } } return -1; } "},{"id":131,"href":"/1-4-24/","title":"1.4.24","section":"帮助","content":"1.4.24 #  解答 #  第一问：二分查找即可。\n第二问：\n按照第 1, 2, 4, 8,\u0026hellip;, 2^k 层顺序查找，一直到 2^k \u0026gt; F，\n随后在 [2^(k - 1), 2^k] 范围中二分查找。\n代码 #  这里建立了一个结构体用于返回测试结果：\nstruct testResult { public int F;// 找到的 F 值。  public int BrokenEggs;// 打碎的鸡蛋数。 } 用于测试的方法：\n/// \u0026lt;summary\u0026gt; /// 扔鸡蛋，没碎返回 true，碎了返回 false。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;floor\u0026#34;\u0026gt;扔鸡蛋的高度。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static bool ThrowEgg(int floor) { return floor \u0026lt;= F; } /// \u0026lt;summary\u0026gt; /// 第一种方案。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;大楼。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static testResult PlanA(int[] a) { int lo = 0; int hi = a.Length - 1; int mid = 0; int eggs = 0; testResult result = new testResult(); while (lo \u0026lt;= hi) { mid = lo + (hi - lo) / 2; if (ThrowEgg(mid)) { lo = mid + 1; } else { eggs++; hi = mid - 1; } } result.BrokenEggs = eggs; result.F = hi; return result; } /// \u0026lt;summary\u0026gt; /// 第二种方案。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;大楼。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static testResult PlanB(int[] a) { int lo = 0; int hi = 1; int mid = 0; int eggs = 0; testResult result = new testResult(); while (ThrowEgg(hi)) { lo = hi; hi *= 2; } eggs++; if (hi \u0026gt; a.Length - 1) { hi = a.Length - 1; } while (lo \u0026lt;= hi) { mid = lo + (hi - lo) / 2; if (ThrowEgg(mid)) { lo = mid + 1; } else { eggs++; hi = mid - 1; } } result.BrokenEggs = eggs; result.F = hi; return result; } "},{"id":132,"href":"/1-4-25/","title":"1.4.25","section":"帮助","content":"1.4.25 #  解答 #  第一问：\n第一个蛋按照 √(N), 2√(N), 3√(N), 4√(N),\u0026hellip;, √(N) * √(N) 顺序查找直至碎掉。这里扔了 k 次，k \u0026lt;= √(N)。\nk-1√(N) ~ k√(N) 顺序查找直至碎掉，F 值就找到了。这里最多扔 √(N) 次。\n第二问：\n按照第 1, 3, 6, 10,\u0026hellip;, 1/2k^2 层顺序查找，一直到 1/2k^2 \u0026gt; F，\n随后在 [1/2k^2 - k, 1/2k^2] 范围中顺序查找。\n代码 #  这里我们同样定义了一个结构体：\nstruct testResult { public int F;// 测试得出的 F 值  public int BrokenEggs;// 碎掉的鸡蛋数。  public int ThrowTimes;// 扔鸡蛋的次数。 } 之后是测试用的方法：\n/// \u0026lt;summary\u0026gt; /// 扔鸡蛋，没碎返回 true，碎了返回 false。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;floor\u0026#34;\u0026gt;扔鸡蛋的高度。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static bool ThrowEgg(int floor) { return floor \u0026lt;= F; } /// \u0026lt;summary\u0026gt; /// 第一种方案。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;大楼。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static testResult PlanA(int[] a) { int lo = 0; int hi = 0; int eggs = 0; int throwTimes = 0; testResult result = new testResult(); while (ThrowEgg(hi)) { throwTimes++; lo = hi; hi += (int)Math.Sqrt(a.Length); } eggs++; if (hi \u0026gt; a.Length - 1) { hi = a.Length - 1; } while (lo \u0026lt;= hi) { if (!ThrowEgg(lo)) { eggs++; break; } throwTimes++; lo++; } result.BrokenEggs = eggs; result.F = lo - 1; result.ThrowTimes = throwTimes; return result; } /// \u0026lt;summary\u0026gt; /// 第二种方案。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;大楼。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static testResult PlanB(int[] a) { int lo = 0; int hi = 0; int eggs = 0; int throwTimes = 0; testResult result = new testResult(); for (int i = 0; ThrowEgg(hi); ++i) { throwTimes++; lo = hi; hi += i; } eggs++; if (hi \u0026gt; a.Length - 1) { hi = a.Length - 1; } while (lo \u0026lt;= hi) { if (!ThrowEgg(lo)) { eggs++; break; } lo++; throwTimes++; } result.BrokenEggs = eggs; result.F = lo - 1; result.ThrowTimes = throwTimes; return result; } "},{"id":133,"href":"/1-4-26/","title":"1.4.26","section":"帮助","content":"1.4.26 #  解答 #  首先，我们将问题转化为证明三点\n$$\nA(a,a^3),B(b,b^3),C(c,c^3)\n$$\n共线，当且仅当满足\n$$\na+b+c=0\n$$\n证明：\n若 $A,B,C$ 三点共线，则直线 $AB$ 和 $BC$ 的斜率必定相等，有方程：\n$$\n\\frac{b^3-a^3}{b-a}=\\frac{c^3-b^3}{c-b}\n$$\n由立方差公式：\n$$\n\\frac{(b-a)(b^2+ba+a^2)}{b-a}=\\frac{(c-b)(c^2+cb+b^2)}{c-b}\n$$\n化简有：\n$$\nb^2+ba+a^2=c^2+cb+b^2\\\nba+a^2=c^2+cb\n$$\n移项，将 $c$ 视为未知数：\n$$\nc^2+cb-ba-a^2=0\n$$\n利用十字相乘法进行因式分解：\n$$\n(a+b+c)(c-a)=0\n$$\n解得：\n$$\nc_1=-a-b,c_2=a\n$$\n显然 $c\\ne a$ ，因此当且仅当 $a+b+c=0$ 时 $A,B,C$ 三点共线。\n证毕。\n"},{"id":134,"href":"/1-4-27/","title":"1.4.27","section":"帮助","content":"1.4.27 #  解答 #  实现比较简单，想象两个栈背靠背接在一起，左侧栈负责出队，右侧栈负责入队。\n当左侧栈为空时就把右侧栈中的元素倒到左侧栈，这个过程是 O(n) 的。\n但在这个过程之前必然有 n 个元素入栈，均摊后即为 O(1)。\n代码 #  namespace _1._4._27 { /// \u0026lt;summary\u0026gt;  /// 用两个栈模拟的队列。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Item\u0026#34;\u0026gt;队列中的元素。\u0026lt;/typeparam\u0026gt;  class StackQueue\u0026lt;Item\u0026gt; { Stack\u0026lt;Item\u0026gt; H;//用于保存出队元素  Stack\u0026lt;Item\u0026gt; T;//用于保存入队元素  /// \u0026lt;summary\u0026gt;  /// 构造一个队列。  /// \u0026lt;/summary\u0026gt;  public StackQueue() { this.H = new Stack\u0026lt;Item\u0026gt;(); this.T = new Stack\u0026lt;Item\u0026gt;(); } /// \u0026lt;summary\u0026gt;  /// 将栈 T 中的元素依次弹出并压入栈 H 中。  /// \u0026lt;/summary\u0026gt;  private void Reverse() { while (!this.T.IsEmpty()) { this.H.Push(this.T.Pop()); } } /// \u0026lt;summary\u0026gt;  /// 将一个元素出队。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Dequeue() { //如果没有足够的出队元素，则将 T 中的元素移动过来  if (this.H.IsEmpty()) { Reverse(); } return this.H.Pop(); } /// \u0026lt;summary\u0026gt;  /// 将一个元素入队。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要入队的元素。\u0026lt;/param\u0026gt;  public void Enqueue(Item item) { this.T.Push(item); } } } "},{"id":135,"href":"/1-4-28/","title":"1.4.28","section":"帮助","content":"1.4.28 #  解答 #  每次入队的时候将队列倒转，这样入队的元素就是第一个了。\n代码 #  namespace _1._4._28 { /// \u0026lt;summary\u0026gt;  /// 用一条队列模拟的栈。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Item\u0026#34;\u0026gt;栈中保存的元素。\u0026lt;/typeparam\u0026gt;  class QueueStack\u0026lt;Item\u0026gt; { Queue\u0026lt;Item\u0026gt; queue; /// \u0026lt;summary\u0026gt;  /// 初始化一个栈。  /// \u0026lt;/summary\u0026gt;  public QueueStack() { this.queue = new Queue\u0026lt;Item\u0026gt;(); } /// \u0026lt;summary\u0026gt;  /// 向栈中添加一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  public void Push(Item item) { this.queue.Enqueue(item); int size = this.queue.Size(); // 倒转队列  for (int i = 0; i \u0026lt; size - 1; ++i) { this.queue.Enqueue(this.queue.Dequeue()); } } /// \u0026lt;summary\u0026gt;  /// 从栈中弹出一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Pop() { return this.queue.Dequeue(); } /// \u0026lt;summary\u0026gt;  /// 确定栈是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.queue.IsEmpty(); } } } "},{"id":136,"href":"/1-4-29/","title":"1.4.29","section":"帮助","content":"1.4.29 #  解答 #  和用两个栈实现队列的方法类似。\npush 的时候把右侧栈内容倒到左侧栈，之后再入栈。\npop 的时候也做相同操作，右侧栈内容进左侧栈，之后再出栈。\nenqueue 的时候则将左侧栈内容倒到右侧栈，之后再入队。\n代码 #  namespace _1._4._29 { /// \u0026lt;summary\u0026gt;  /// 用两个栈模拟的 Steque。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Item\u0026#34;\u0026gt;Steque 中的元素类型。\u0026lt;/typeparam\u0026gt;  class StackSteque\u0026lt;Item\u0026gt; { Stack\u0026lt;Item\u0026gt; H; Stack\u0026lt;Item\u0026gt; T; /// \u0026lt;summary\u0026gt;  /// 初始化一个 Steque  /// \u0026lt;/summary\u0026gt;  public StackSteque() { this.H = new Stack\u0026lt;Item\u0026gt;(); this.T = new Stack\u0026lt;Item\u0026gt;(); } /// \u0026lt;summary\u0026gt;  /// 向栈中添加一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  public void Push(Item item) { ReverseT(); this.H.Push(item); } /// \u0026lt;summary\u0026gt;  /// 将 T 中的元素弹出并压入到 H 中。  /// \u0026lt;/summary\u0026gt;  private void ReverseT() { while (!this.T.IsEmpty()) { this.H.Push(this.T.Pop()); } } /// \u0026lt;summary\u0026gt;  /// 将 H 中的元素弹出并压入到 T 中。  /// \u0026lt;/summary\u0026gt;  private void ReverseH() { while (!this.H.IsEmpty()) { this.T.Push(this.H.Pop()); } } /// \u0026lt;summary\u0026gt;  /// 从 Steque 中弹出一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Pop() { ReverseT(); return this.H.Pop(); } /// \u0026lt;summary\u0026gt;  /// 在 Steque 尾部添加一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  public void Enqueue(Item item) { ReverseH(); this.T.Push(item); } /// \u0026lt;summary\u0026gt;  /// 检查 Steque 是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.H.IsEmpty() \u0026amp;\u0026amp; this.T.IsEmpty(); } } } "},{"id":137,"href":"/1-4-30/","title":"1.4.30","section":"帮助","content":"1.4.30 #  解答 #  steque 作为队列的头部，stack 作为队列的尾部。\npushLeft：直接 push 到 steque 中即可。\npushRight：如果 stack 为空，则直接 enqueue 到 steque 中，否则就 push 到 stack 中。\npopLeft：如果 steque 为空，则将 stack 中的元素倒到 steque 中去（steque.push(stack.pop())），然后再从 steque 中 pop。\npopRight：如果 stack 为空，则将 steque 中的元素倒到 stack 中去，然后再从 stack 中 pop。\n代码 #  namespace _1._4._30 { /// \u0026lt;summary\u0026gt;  /// 用一个栈和一个 Steque 模拟的双向队列。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Item\u0026#34;\u0026gt;双向队列中保存的元素类型。\u0026lt;/typeparam\u0026gt;  class Deque\u0026lt;Item\u0026gt; { Stack\u0026lt;Item\u0026gt; stack;//代表队列尾部  Steque\u0026lt;Item\u0026gt; steque;//代表队列头部  /// \u0026lt;summary\u0026gt;  /// 创建一条空的双向队列。  /// \u0026lt;/summary\u0026gt;  public Deque() { this.stack = new Stack\u0026lt;Item\u0026gt;(); this.steque = new Steque\u0026lt;Item\u0026gt;(); } /// \u0026lt;summary\u0026gt;  /// 在左侧插入一个新元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要插入的元素。\u0026lt;/param\u0026gt;  public void PushLeft(Item item) { this.steque.Push(item); } /// \u0026lt;summary\u0026gt;  /// 将栈中的内容移动到 Steque 中。  /// \u0026lt;/summary\u0026gt;  private void StackToSteque() { while (!this.stack.IsEmpty()) { this.steque.Push(this.stack.Pop()); } } /// \u0026lt;summary\u0026gt;  /// 将 Steque 中的内容移动到栈中。  /// \u0026lt;/summary\u0026gt;  private void StequeToStack() { while (!this.steque.IsEmpty()) { this.stack.Push(this.steque.Pop()); } } /// \u0026lt;summary\u0026gt;  /// 从双向队列左侧弹出一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item PopLeft() { if (this.steque.IsEmpty()) { StackToSteque(); } return this.steque.Pop(); } /// \u0026lt;summary\u0026gt;  /// 向双向队列右侧添加一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要插入的元素。\u0026lt;/param\u0026gt;  public void PushRight(Item item) { if (this.stack.IsEmpty()) { this.steque.Enqueue(item); } else { this.stack.Push(item); } } /// \u0026lt;summary\u0026gt;  /// 从双向队列右侧弹出一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item PopRight() { if (this.stack.IsEmpty()) { StequeToStack(); } return this.stack.Pop(); } /// \u0026lt;summary\u0026gt;  /// 判断队列是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.stack.IsEmpty() \u0026amp;\u0026amp; this.steque.IsEmpty(); } /// \u0026lt;summary\u0026gt;  /// 返回队列中元素的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() { return this.stack.Size() + this.steque.Size(); } } } "},{"id":138,"href":"/1-4-31/","title":"1.4.31","section":"帮助","content":"1.4.31 #  解答 #  三个栈分别命名为左中右。\n左侧栈和右侧栈负责模拟队列，和用两个栈模拟队列的方法类似。\n由于是双向队列，左栈和右栈会频繁的倒来倒去，因此每次都只倒一半的元素可以有效减少开销。\n有一侧栈为空时，另一侧栈中上半部分先移动到中间栈中，下半部分倒到另一侧栈里，再从中间栈拿回上半部分元素。\n这样可以确保接下来的 pop 操作一定是常数级别的。\n代码 #  namespace _1._4._31 { /// \u0026lt;summary\u0026gt;  /// 用三个栈模拟的双向队列。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Item\u0026#34;\u0026gt;双向队列中的元素。\u0026lt;/typeparam\u0026gt;  class Deque\u0026lt;Item\u0026gt; { Stack\u0026lt;Item\u0026gt; left; Stack\u0026lt;Item\u0026gt; middle; Stack\u0026lt;Item\u0026gt; right; /// \u0026lt;summary\u0026gt;  /// 构造一条新的双向队列。  /// \u0026lt;/summary\u0026gt;  public Deque() { this.left = new Stack\u0026lt;Item\u0026gt;(); this.middle = new Stack\u0026lt;Item\u0026gt;(); this.right = new Stack\u0026lt;Item\u0026gt;(); } /// \u0026lt;summary\u0026gt;  /// 向双向队列左侧插入一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要插入的元素。\u0026lt;/param\u0026gt;  public void PushLeft(Item item) { this.left.Push(item); } /// \u0026lt;summary\u0026gt;  /// 向双向队列右侧插入一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要插入的元素。\u0026lt;/param\u0026gt;  public void PushRight(Item item) { this.right.Push(item); } /// \u0026lt;summary\u0026gt;  /// 当一侧栈为空时，将另一侧的下半部分元素移动过来。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;source\u0026#34;\u0026gt;不为空的栈。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;destination\u0026#34;\u0026gt;空栈。\u0026lt;/param\u0026gt;  private void Move(Stack\u0026lt;Item\u0026gt; source, Stack\u0026lt;Item\u0026gt; destination) { int n = source.Size(); // 将上半部分元素移动到临时栈 middle  for (int i = 0; i \u0026lt; n / 2; ++i) { this.middle.Push(source.Pop()); } // 将下半部分移动到另一侧栈中  while (!source.IsEmpty()) { destination.Push(source.Pop()); } // 从 middle 取回上半部分元素  while (!this.middle.IsEmpty()) { source.Push(this.middle.Pop()); } } /// \u0026lt;summary\u0026gt;  /// 检查双端队列是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.right.IsEmpty() \u0026amp;\u0026amp; this.middle.IsEmpty() \u0026amp;\u0026amp; this.left.IsEmpty(); } /// \u0026lt;summary\u0026gt;  /// 从右侧弹出一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item PopRight() { if (this.right.IsEmpty()) { Move(this.left, this.right); } return this.right.Pop(); } /// \u0026lt;summary\u0026gt;  /// 从左侧弹出一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item PopLeft() { if (this.left.IsEmpty()) { Move(this.right, this.left); } return this.left.Pop(); } /// \u0026lt;summary\u0026gt;  /// 返回双端队列的大小。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() { return this.left.Size() + this.middle.Size() + this.right.Size(); } } } "},{"id":139,"href":"/1-4-32/","title":"1.4.32","section":"帮助","content":"1.4.32 #  解答 #  首先，不需要扩容数组的的操作都只需访问数组一次，$M$ 次操作就是 $M$ 次访问。\n随后我们有性质， $M$ 次栈操作后额外复制访问数组的次数小于 $2M$。\n这里简单证明，设 $M$ 次操作之后栈的大小为 $n$，那么额外访问数组的次数为：\n$S = \\frac{n}{2} + \\frac{n}{4} + \\frac{n}{8} +\u0026hellip;+ 2 \u0026lt; n$\n为了能使栈大小达到 $n$，$M$ 必须大于等于 $\\frac{n}{2}$\n因此 $2M \\ge n \u0026gt; S$，得证。\n因此我们可以得到 $M$ 次操作后访问数组次数的总和 $S' = S + M \u0026lt; 3M$。\n"},{"id":140,"href":"/1-4-33/","title":"1.4.33","section":"帮助","content":"1.4.33 #  解答 #  Integer = 4(int) + 8(对象开销) = 12\nDate = 3 * 4(int * 3) + 8(对象开销) = 20\nCounter = 4(String 的引用) + 4(int) + 8(对象开销) = 16\nint[] = 8(对象开销) + 4(数组长度) + 4N = 12 + 4N\ndouble[] = 8(对象开销) + 4(数组长度) + 8N = 12 + 8N\ndouble[][] = 8(对象开销) + 4(数组长度) + 4M(引用) + M(12 + 8N)(M 个一维数组) = 12 + 16M + 8MN\nString = 8(对象开销) + 34(int * 3) + 4(字符数组的引用) = 24\nNode = 8(对象开销) + 42(引用*2) = 16\nStack = 8(对象开销) + 4(引用) + 4(int) = 16\n"},{"id":141,"href":"/1-4-34/","title":"1.4.34","section":"帮助","content":"1.4.34 #  解答 #  第一种方案，类似于二分查找，先猜测左边界(lo)，再猜测右边界(hi)，如果边界值猜中的话直接返回，否则：\n如果右边界比较热，那么左边界向右边界靠，lo=mid；否则，右边界向左边界靠，hi=mid。其中，mid = lo + (hi – lo)/2。\n每次二分查找都要猜测两次，~2lgN。\n第二种方案，假设上次猜测值为 $lastGuess$，本次即将要猜测的值为 $nowGuess$，通过方程：\n$(lastGuess + nowGuess)/2 = (lo + hi)/2$\n可以求得 $nowGuess$，具体可以查看示意图：\n数字是猜测顺序，黑色范围是猜测值的范围（$lastGuess$ 和 $nowGuess$），绿色的是实际查找的范围（lo 和 hi）。\n代码 #  首先是 Game 类\nusing System; namespace _1._4._34 { /// \u0026lt;summary\u0026gt;  /// 某次猜测的结果。  /// \u0026lt;/summary\u0026gt;  enum GuessResult { Hot = 1, // 比上次猜测更接近目标。  Equal = 0, // 猜中目标。  Cold = -1, // 比上次猜测更远离目标。  FirstGuess = -2 // 第一次猜测。  } /// \u0026lt;summary\u0026gt;  /// 游戏类。  /// \u0026lt;/summary\u0026gt;  class Game { public int N { get; } // 目标值的最大范围。  public int SecretNumber { get; } // 目标值。  public int LastGuess { get; private set; } // 上次猜测的值  /// \u0026lt;summary\u0026gt;  /// 构造函数，新开一局游戏。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;N\u0026#34;\u0026gt;目标值的最大范围。\u0026lt;/param\u0026gt;  public Game(int N) { Random random = new Random(); this.N = N; this.SecretNumber = random.Next(N - 1) + 1; this.LastGuess = -1; } /// \u0026lt;summary\u0026gt;  /// 猜测，根据与上次相比更为接近还是远离目标值返回结果。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;guess\u0026#34;\u0026gt;本次的猜测值\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;接近或不变返回 Hot，远离则返回 Cold，猜中返回 Equal。\u0026lt;/returns\u0026gt;  public GuessResult Guess(int guess) { if (guess == this.SecretNumber) { return GuessResult.Equal; } if (this.LastGuess == -1) { this.LastGuess = guess; return GuessResult.FirstGuess; } int lastDiff = Math.Abs(this.LastGuess - this.SecretNumber); this.LastGuess = guess; int nowDiff = Math.Abs(guess - this.SecretNumber); if (nowDiff \u0026gt; lastDiff) { return GuessResult.Cold; } else { return GuessResult.Hot; } } /// \u0026lt;summary\u0026gt;  /// 重置游戏，清空上次猜测的记录。目标值和最大值都不变。  /// \u0026lt;/summary\u0026gt;  public void Restart() { this.LastGuess = -1; } } } 之后是实际测试的方法：\nusing System; namespace _1._4._34 { /* * 1.4.34 * * 热还是冷。 * 你的目标是猜出 1 到 N 之间的一个秘密的整数。 * 每次猜完一个整数后，你会直到你的猜测距离该秘密整数是否相等（如果是则游戏结束）。 * 如果不相等，你会知道你的猜测相比上一次猜测距离秘密整数是比较热（接近），还是比较冷（远离）。 * 设计一个算法在 ~2lgN 之内找到这个秘密整数，然后设计一个算法在 ~1lgN 之内找到这个秘密整数。 * */ class Program { /// \u0026lt;summary\u0026gt;  /// 某种方案的测试结果，包含猜测结果和尝试次数。  /// \u0026lt;/summary\u0026gt;  struct TestResult { public int SecretNumber;// 猜测到的数字。  public int TryTimes;// 尝试次数。  } static void Main(string[] args) { Game game = new Game(1000); TestResult A = PlayGameA(game); game.Restart(); TestResult B = PlayGameB(game); Console.WriteLine($\u0026#34;SecretNumber:{game.SecretNumber}\u0026#34;); Console.WriteLine(\u0026#34;TestResultA:\u0026#34;); Console.WriteLine($\u0026#34;SecretNumber:{A.SecretNumber}, TryTimes:{A.TryTimes}\u0026#34;); Console.WriteLine(); Console.WriteLine(\u0026#34;TestResultB:\u0026#34;); Console.WriteLine($\u0026#34;SecretNumber:{B.SecretNumber}, TryTimes:{B.TryTimes}\u0026#34;); } /// \u0026lt;summary\u0026gt;  /// 方案一，用二分查找实现，需要猜测 2lgN 次。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;game\u0026#34;\u0026gt;用于猜测的游戏对象。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;返回测试结果，包含猜测结果和尝试次数。\u0026lt;/returns\u0026gt;  static TestResult PlayGameA(Game game) { TestResult result; result.TryTimes = 0; result.SecretNumber = 0; GuessResult guessResult; int hi = game.N; int lo = 1; // 利用二分查找猜测，2lgN  while (lo \u0026lt;= hi) { int mid = lo + (hi - lo) / 2; guessResult = game.Guess(lo); result.TryTimes++; if (guessResult == GuessResult.Equal) { result.SecretNumber = lo; return result; } guessResult = game.Guess(hi); result.TryTimes++; if (guessResult == GuessResult.Equal) { result.SecretNumber = hi; return result; } else if (guessResult == GuessResult.Hot) { lo = mid; } else { hi = mid; } } return result; } /// \u0026lt;summary\u0026gt;  /// 方案二，根据 (lastGuess + nowGuess)/2 = (lo + hi) / 2 确定每次猜测的值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;game\u0026#34;\u0026gt;用于猜测的游戏对象。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;返回测试结果，包含猜测结果和尝试次数。\u0026lt;/returns\u0026gt;  static TestResult PlayGameB(Game game) { TestResult result; result.TryTimes = 0; result.SecretNumber = 0; GuessResult guessResult; int hi = game.N; int lo = 1; bool isRightSide = true; // 第一次猜测  guessResult = game.Guess(1); result.TryTimes++; if (guessResult == GuessResult.Equal) { result.SecretNumber = 1; return result; } while (lo \u0026lt; hi) { int mid = lo + (hi - lo) / 2; int nowGuess = (lo + hi) - game.LastGuess; guessResult = game.Guess(nowGuess); result.TryTimes++; if (guessResult == GuessResult.Equal) { result.SecretNumber = nowGuess; break; } else if (guessResult == GuessResult.Hot) { if (isRightSide) { lo = mid; } else { hi = mid; } } else { if (isRightSide) { hi = mid; } else { lo = mid; } } isRightSide = !isRightSide; if (hi - lo \u0026lt;= 1) { break; } } if (game.Guess(lo) == GuessResult.Equal) { result.TryTimes++; result.SecretNumber = lo; } else if (game.Guess(hi) == GuessResult.Equal) { result.TryTimes++; result.SecretNumber = hi; } return result; } } } "},{"id":142,"href":"/1-4-35/","title":"1.4.35","section":"帮助","content":"1.4.35 #  解答 #  1. 一个 Node 对象包含一个 int(泛型 Item) 的引用和下一个 Node 对象的引用。push 操作创建新 Node 对象时会创建一个引用。\n因此对于第一种情况，压入 n 个 int 类型的元素创建了 N 个 Node 对象，创建了 2N 个引用。\n2. 比起上一种情况，每个 Node 对象多包含了一个指向 Integer 的引用。\n因此对于第二中情况，压入 n 个 int 类型的元素创建了 N 个 Node 对象和 N 个 Integer 对象，比起第一种情况多创建了 N 个引用。\n3. 对于数组来说，创建对象只有扩容时重新创建数组对象一种情况，对于 N 次 push 操作只需要 lgN 次扩容，因此创建的对象为 lgN 个。\n每次扩容都需要重新创建引用，(4 + 8 +\u0026hellip;+ 2N)(扩容) + N(每次 push 操作) = 5N - 4 = ~5N\n4. 创建引用和上题一样，创建对象则多出了装箱过程，每次 push 都会新建一个 Integer 对象，N + lgN = ~N。\n"},{"id":143,"href":"/1-4-36/","title":"1.4.36","section":"帮助","content":"1.4.36 #  解答 #  1. N 个 Node对象的空间开销\n= N * (16(对象开销) + 4(int) + 8(下一个 Node 的引用) + 4(填充字节)) = 32N\n2. 比起上一题来说，空间开销变为\n= N * (16(Node 对象开销) + 8(Integer 对象引用) + (16(Integer 对象开销) + 4(int) + 4(填充字节)) + 8(下一个对象的引用) = 32N + 24N = 56N。\n3. 如果不扩容则是 4N，N 个元素最多可以维持 4N 的栈空间（少于四分之一将缩小）。\n4. 比起上一题，数组元素变成了引用每个占用 8 字节，还要额外加上 Integer 对象的每个 24 字节。\n= (8 + 24)N ~ (8 * 4 + 24)N\n"},{"id":144,"href":"/1-4-37/","title":"1.4.37","section":"帮助","content":"1.4.37 #  解答 #  数据量比较大时才会有比较明显的差距。\n代码 #  FixedCapacityStackOfInts\nusing System; using System.Collections; using System.Collections.Generic; namespace _1._4._37 { /// \u0026lt;summary\u0026gt;  /// 固定大小的整型数据栈。  /// \u0026lt;/summary\u0026gt;  class FixedCapacityStackOfInts : IEnumerable\u0026lt;int\u0026gt; { private int[] a; private int N; /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;栈的大小。\u0026lt;/param\u0026gt;  public FixedCapacityStackOfInts(int capacity) { this.a = new int[capacity]; this.N = 0; } /// \u0026lt;summary\u0026gt;  /// 检查栈是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.N == 0; } /// \u0026lt;summary\u0026gt;  /// 检查栈是否已满。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsFull() { return this.N == this.a.Length; } /// \u0026lt;summary\u0026gt;  /// 将一个元素压入栈中。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要压入栈中的元素。\u0026lt;/param\u0026gt;  public void Push(int item) { this.a[this.N] = item; this.N++; } /// \u0026lt;summary\u0026gt;  /// 从栈中弹出一个元素，返回被弹出的元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Pop() { this.N--; return this.a[this.N]; } /// \u0026lt;summary\u0026gt;  /// 返回栈顶元素（但不弹出它）。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Peek() { return this.a[this.N - 1]; } public IEnumerator\u0026lt;int\u0026gt; GetEnumerator() { return new ReverseEnmerator(this.a); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class ReverseEnmerator : IEnumerator\u0026lt;int\u0026gt; { private int current; private int[] a; public ReverseEnmerator(int[] a) { this.current = a.Length; this.a = a; } int IEnumerator\u0026lt;int\u0026gt;.Current =\u0026gt; this.a[this.current]; object IEnumerator.Current =\u0026gt; this.a[this.current]; void IDisposable.Dispose() { this.current = -1; this.a = null; } bool IEnumerator.MoveNext() { if (this.current == 0) return false; this.current--; return true; } void IEnumerator.Reset() { this.current = this.a.Length; } } } } FixedCapacityStack\u0026lt;Item\u0026gt;\nusing System; using System.Collections; using System.Collections.Generic; namespace _1._4._37 { /// \u0026lt;summary\u0026gt;  /// 固定大小的栈。  /// \u0026lt;/summary\u0026gt;  class FixedCapacityStack\u0026lt;Item\u0026gt; : IEnumerable\u0026lt;Item\u0026gt; { private Item[] a; private int N; /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;栈的大小。\u0026lt;/param\u0026gt;  public FixedCapacityStack(int capacity) { this.a = new Item[capacity]; this.N = 0; } /// \u0026lt;summary\u0026gt;  /// 检查栈是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return this.N == 0; } /// \u0026lt;summary\u0026gt;  /// 检查栈是否已满。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsFull() { return this.N == this.a.Length; } /// \u0026lt;summary\u0026gt;  /// 将一个元素压入栈中。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要压入栈中的元素。\u0026lt;/param\u0026gt;  public void Push(Item item) { this.a[this.N] = item; this.N++; } /// \u0026lt;summary\u0026gt;  /// 从栈中弹出一个元素，返回被弹出的元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Pop() { this.N--; return this.a[this.N]; } /// \u0026lt;summary\u0026gt;  /// 返回栈顶元素（但不弹出它）。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Item Peek() { return this.a[this.N - 1]; } public IEnumerator\u0026lt;Item\u0026gt; GetEnumerator() { return new ReverseEnmerator(this.a); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class ReverseEnmerator : IEnumerator\u0026lt;Item\u0026gt; { private int current; private Item[] a; public ReverseEnmerator(Item[] a) { this.current = a.Length; this.a = a; } Item IEnumerator\u0026lt;Item\u0026gt;.Current =\u0026gt; this.a[this.current]; object IEnumerator.Current =\u0026gt; this.a[this.current]; void IDisposable.Dispose() { this.current = -1; this.a = null; } bool IEnumerator.MoveNext() { if (this.current == 0) return false; this.current--; return true; } void IEnumerator.Reset() { this.current = this.a.Length; } } } } 测试函数：\nusing System; using Measurement; namespace _1._4._37 { /// \u0026lt;summary\u0026gt;  /// FixedCapacityStackOfInts 测试类。  /// \u0026lt;/summary\u0026gt;  public static class DoubleTest { private static readonly int MAXIMUM_INTEGER = 1000000; /// \u0026lt;summary\u0026gt;  /// 返回对 n 个随机整数的栈进行 n 次 push 和 n 次 pop 所需的时间。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;随机数组的长度。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static double TimeTrial(int n) { int[] a = new int[n]; FixedCapacityStackOfInts stack = new FixedCapacityStackOfInts(n); Random random = new Random(DateTime.Now.Millisecond); for (int i = 0; i \u0026lt; n; ++i) { a[i] = random.Next(-MAXIMUM_INTEGER, MAXIMUM_INTEGER); } Stopwatch timer = new Stopwatch(); for (int i = 0; i \u0026lt; n; ++i) { stack.Push(a[i]); } for (int i = 0; i \u0026lt; n; ++i) { stack.Pop(); } return timer.ElapsedTimeMillionSeconds(); } /// \u0026lt;summary\u0026gt;  /// 返回对 n 个随机整数的栈进行 n 次 push 和 n 次 pop 所需的时间。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;随机数组的长度。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static double TimeTrialGeneric(int n) { int[] a = new int[n]; FixedCapacityStack\u0026lt;int\u0026gt; stack = new FixedCapacityStack\u0026lt;int\u0026gt;(n); Random random = new Random(DateTime.Now.Millisecond); for (int i = 0; i \u0026lt; n; ++i) { a[i] = random.Next(-MAXIMUM_INTEGER, MAXIMUM_INTEGER); } Stopwatch timer = new Stopwatch(); for (int i = 0; i \u0026lt; n; ++i) { stack.Push(a[i]); } for (int i = 0; i \u0026lt; n; ++i) { stack.Pop(); } return timer.ElapsedTimeMillionSeconds(); } } } 主函数\nusing System; namespace _1._4._37 { /* * 1.4.37 * * 自动装箱的性能代价。 * 通过实验在你的计算机上计算使用自动装箱所付出的性能代价。 * 实现一个 FixedCapacityStackOfInts， * 并使用类似 DoublingRatio 的用例比较它和泛型 FixedCapacityStack 在进行大量 push() 和 pop() 时的性能。 * */ class Program { static void Main(string[] args) { Console.WriteLine(\u0026#34;测试量\\t非泛型耗时（毫秒）\\t泛型耗时（毫秒）\\t差值\u0026#34;); for (int n = 250; true; n += n) { double time = DoubleTest.TimeTrial(n); double timeGeneric = DoubleTest.TimeTrialGeneric(n); Console.WriteLine($\u0026#34;{n}\\t{time}\\t{timeGeneric}\\t{Math.Abs(time - timeGeneric)}\u0026#34;); } } } } 另请参阅 #  Measurement 库\n"},{"id":145,"href":"/1-4-38/","title":"1.4.38","section":"帮助","content":"1.4.38 #  解答 #  把 DoublingTest 中调用的函数稍作修改即可。\n代码 #  ThreeSum 测试类\nusing System; namespace _1._4._38 { /// \u0026lt;summary\u0026gt;  /// ThreeSum 测试类。  /// \u0026lt;/summary\u0026gt;  public static class DoubleTest { private static readonly int MAXIMUM_INTEGER = 1000000; /// \u0026lt;summary\u0026gt;  /// 返回对 n 个随机整数的数组进行一次 ThreeSum 所需的时间。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;随机数组的长度。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static double TimeTrial(int n) { int[] a = new int[n]; Random random = new Random(DateTime.Now.Millisecond); for (int i = 0; i \u0026lt; n; ++i) { a[i] = random.Next(-MAXIMUM_INTEGER, MAXIMUM_INTEGER); } Measurement.Stopwatch timer = new Measurement.Stopwatch(); ThreeSum.Count(a); return timer.ElapsedTime(); } } } ThreeSum\nusing System; namespace _1._4._38 { /// \u0026lt;summary\u0026gt;  /// 用暴力方法寻找数组中和为零的三元组。  /// \u0026lt;/summary\u0026gt;  public static class ThreeSum { /// \u0026lt;summary\u0026gt;  /// 输出所有和为零的三元组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;输入数组。\u0026lt;/param\u0026gt;  public static void PrintAll(int[] a) { int n = a.Length; for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j) { for (int k = 0; k \u0026lt; n; ++k) { if (i \u0026lt; j \u0026amp;\u0026amp; j \u0026lt; k) { if ((long)a[i] + a[j] + a[k] == 0) { Console.WriteLine($\u0026#34;{a[i]} + {a[j]} + {a[k]}\u0026#34;); } } } } } } /// \u0026lt;summary\u0026gt;  /// 计算和为零的三元组的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;输入数组。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static int Count(int[] a) { int n = a.Length; int count = 0; for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j) { for (int k = 0; k \u0026lt; n; ++k) { if (i \u0026lt; j \u0026amp;\u0026amp; j \u0026lt; k) { if ((long)a[i] + a[j] + a[k] == 0) { count++; } } } } } return count; } } } "},{"id":146,"href":"/1-4-39/","title":"1.4.39","section":"帮助","content":"1.4.39 #  解答 #  执行 N 次后取平均即可。\n代码 #  修改后的 DoublingTest：\nusing System; using Measurement; namespace _1._4._39 { /// \u0026lt;summary\u0026gt;  /// ThreeSum 测试类。  /// \u0026lt;/summary\u0026gt;  public static class DoubleTest { private static readonly int MAXIMUM_INTEGER = 1000000; /// \u0026lt;summary\u0026gt;  /// 返回对 n 个随机整数的数组进行一次 ThreeSum 所需的时间。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;随机数组的长度。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;repeatTimes\u0026#34;\u0026gt;重复测试的次数。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static double TimeTrial(int n, int repeatTimes) { int[] a = new int[n]; double sum = 0; Random random = new Random(DateTime.Now.Millisecond); for (int i = 0; i \u0026lt; n; ++i) { a[i] = random.Next(-MAXIMUM_INTEGER, MAXIMUM_INTEGER); } for (int i = 0; i \u0026lt; repeatTimes; ++i) { Stopwatch timer = new Stopwatch(); ThreeSum.Count(a); sum += timer.ElapsedTime(); } return sum / repeatTimes; } } } 另请参阅 #  Measurement 库\n"},{"id":147,"href":"/1-4-40/","title":"1.4.40","section":"帮助","content":"1.4.40 #  解答 #  N 个数可组成的三元组的总数为：\n$C(N, 3) = N(N-1)(N-2)/3! = ~ (N^3)/6​$ （组合数公式）\n$[-M, M]​$ 中随机 $N​$ 次，有 $(2M+1)^N​$ 种随机序列（每次随机都有 $2M+1​$ 种可能）\n按照分步计数方法，将随机序列分为和为零的三元组和其余 $N-3​$ 个数\n这些序列中，和为零的三元组有 $3M^2 + 3M + 1​$ 种可能。\n其他不为零的 $N-3​$ 个位置有 $(2M+1)^{(N-3)}​$ 种可能。\n总共有 $((N^3)/6) \\times (3M^2 + 3M + 1) \\times (2M+1)^{(N-3)}​$ 种可能性\n平均值为：\n$[((N^3)/6) \\times (3M^2 + 3M + 1) \\times (2M+1)^{(N-3)}] / (2M+1)^N​$\n$=N^3/16M​$\n$3M^2 + 3M + 1$ 的推导：\n在 $[-M,M]$ 中取三个数，和为零的序列有几个？\n假设第一个数取 $0$， 取 $(0, 0, 0)$ 的情况最后加上。\n剩下两个数只能以 $0$ 为中心对称配对，总共 $2M / 2$ 种组合。\n换成排列数（例如 (0 ,1 ,-1) 和 (0 ,-1 ,1) 是两种不同的排列）就是 $2M$ 种。\n加上 $(0, 0, 0)$ 就是 $2M+1$ 种序列。\n假设第一个数取 $1$，那么 $M$ 就不能再取（剩下的数不能获得 $M+1$），剩下 $2M$ 个数对称配对。\n总共 $(2M)/2 * 2 = 2M$ 种排列。\n假设第一个数取 $2$，那么 $M$ 和 $M-1$ 就不能再取，剩下 $2M-1$ 个数配对。\n总共 $2M-1$ 种序列。\n以此类推，第一个数取 $M $ 时，只能在 $-M$ 到 $0$ 之间配对，总共 $M+1$ 种序列。\n$-M$ 到 $-1$ 之间的序列数计算完全一样，于是由等差数列求和公式：\n$$\n\\frac{(M+1+2M)M}{2} \\times 2 + 2M+1=3M^2+3M+1\n$$\n第一项为 $1$ 到 $M$ 之间的序列数，乘上 $2$ 再加上取 $ 0 ​$ 时的序列数即为所求的全部序列数。\n代码 #  using System; namespace _1._4._40 { /* * 1.4.40 * * 随机输入下的 3-sum 问题。 * 猜测找出 N 个随机 int 值中和为 0 的整数三元组的数量所需的时间并验证你的猜想。 * 如果你擅长数学分析，请为此问题给出一个合适的数学模型， * 其中所有值均匀的分布在 -M 和 M 之间，且 M 不能是一个小整数。 * */ class Program { static void Main(string[] args) { int M = 10000; for (int n = 125; n \u0026lt; 10000; n += n) { Random random = new Random(); int[] a = new int[n]; for (int i = 0; i \u0026lt; n; ++i) { a[i] = random.Next(2 * M) - M; } Console.WriteLine($\u0026#34;N={n}, 计算值={Math.Pow(n, 3) / (16 * M)}, 实际值={ThreeSum.Count(a)}\u0026#34;); } } } } "},{"id":148,"href":"/1-4-41/","title":"1.4.41","section":"帮助","content":"1.4.41 #  解答 #  代码 #  这里使用了委托来简化代码。\nDoublingRatio\nusing System; using Measurement; namespace _1._4._41 { public delegate int Count(int[] a); static class DoublingRatio { /// \u0026lt;summary\u0026gt;  /// 从指定字符串中读入按行分割的整型数据。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;inputString\u0026#34;\u0026gt;源字符串。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;读入的整型数组\u0026lt;/returns\u0026gt;  private static int[] ReadAllInts(string inputString) { char[] split = new char[1] { \u0026#39;\\n\u0026#39; }; string[] input = inputString.Split(split, StringSplitOptions.RemoveEmptyEntries); int[] a = new int[input.Length]; for (int i = 0; i \u0026lt; a.Length; ++i) { a[i] = int.Parse(input[i]); } return a; } /// \u0026lt;summary\u0026gt;  /// 使用给定的数组进行一次测试，返回耗时（毫秒）。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;Count\u0026#34;\u0026gt;要测试的方法。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;测试用的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;耗时（秒）。\u0026lt;/returns\u0026gt;  public static double TimeTrial(Count Count, int[] a) { Stopwatch timer = new Stopwatch(); Count(a); return timer.ElapsedTimeMillionSeconds(); } /// \u0026lt;summary\u0026gt;  /// 对 TwoSum、TwoSumFast、ThreeSum 或 ThreeSumFast 的 Count 方法做测试。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;Count\u0026#34;\u0026gt;相应类的 Count 方法\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;随着数据量倍增，方法耗时增加的比率。\u0026lt;/returns\u0026gt;  public static double Test(Count Count) { double ratio = 0; double times = 3; // 1K  int[] a = ReadAllInts(TestCase.Properties.Resources._1Kints); double prevTime = TimeTrial(Count, a); Console.WriteLine(\u0026#34;数据量\\t耗时\\t比值\u0026#34;); Console.WriteLine($\u0026#34;1000\\t{prevTime / 1000}\\t\u0026#34;); // 2K  a = ReadAllInts(TestCase.Properties.Resources._2Kints); double time = TimeTrial(Count, a); Console.WriteLine($\u0026#34;2000\\t{time / 1000}\\t{time / prevTime}\u0026#34;); if (prevTime != 0) { ratio += time / prevTime; } else { times--; } prevTime = time; // 4K  a = ReadAllInts(TestCase.Properties.Resources._4Kints); time = TimeTrial(Count, a); Console.WriteLine($\u0026#34;4000\\t{time / 1000}\\t{time / prevTime}\u0026#34;); if (prevTime != 0) { ratio += time / prevTime; } else { times--; } prevTime = time; // 8K  a = ReadAllInts(TestCase.Properties.Resources._8Kints); time = TimeTrial(Count, a); Console.WriteLine($\u0026#34;8000\\t{time / 1000}\\t{time / prevTime}\u0026#34;); if (prevTime != 0) { ratio += time / prevTime; } else { times--; } prevTime = time; return ratio / times; } public static double TestTwoSumFast(Count Count) { double ratio = 0; double times = 2; // 8K  int[] a = ReadAllInts(TestCase.Properties.Resources._8Kints); double prevTime = TimeTrial(Count, a); Console.WriteLine(\u0026#34;数据量\\t耗时\\t比值\u0026#34;); Console.WriteLine($\u0026#34;8000\\t{prevTime / 1000}\\t\u0026#34;); // 16K  a = ReadAllInts(TestCase.Properties.Resources._16Kints); double time = TimeTrial(Count, a); Console.WriteLine($\u0026#34;16000\\t{time / 1000}\\t{time / prevTime}\u0026#34;); if (prevTime != 0) { ratio += time / prevTime; } else { times--; } prevTime = time; // 32K  a = ReadAllInts(TestCase.Properties.Resources._32Kints); time = TimeTrial(Count, a); Console.WriteLine($\u0026#34;32000\\t{time / 1000}\\t{time / prevTime}\u0026#34;); if (prevTime != 0) { ratio += time / prevTime; } else { times--; } prevTime = time; return ratio / times; } } } 主函数\nusing System; using Measurement; namespace _1._4._41 { /* * 1.4.41 * * 运行时间。 * 使用 DoublingRatio 估计在你的计算机上用 TwoSumFast、TwoSum、ThreeSumFast 以及 ThreeSum 处理一个含有 100 万个整数的文件所需的时间。 * */ class Program { static void Main(string[] args) { int[] a = new int[977]; Random random = new Random(); for (int i = 0; i \u0026lt; 977; ++i) { a[i] = random.Next(977) - 489; } // ThreeSum  Console.WriteLine(\u0026#34;ThreeSum\u0026#34;); double time = DoublingRatio.TimeTrial(ThreeSum.Count, a); Console.WriteLine($\u0026#34;数据量：977 耗时：{time / 1000}\u0026#34;); double doubleRatio = DoublingRatio.Test(ThreeSum.Count); Console.WriteLine($\u0026#34;数据量：1000000 估计耗时：{time * doubleRatio * 1024 / 1000}\u0026#34;); Console.WriteLine(); //// ThreeSumFast  Console.WriteLine(\u0026#34;ThreeSumFast\u0026#34;); time = DoublingRatio.TimeTrial(ThreeSumFast.Count, a); doubleRatio = DoublingRatio.Test(ThreeSumFast.Count); Console.WriteLine($\u0026#34;数据量：977 耗时：{time / 1000}\u0026#34;); Console.WriteLine($\u0026#34;数据量：1000000 估计耗时：{time * doubleRatio * 1024 / 1000}\u0026#34;); Console.WriteLine(); //// TwoSum  Console.WriteLine(\u0026#34;TwoSum\u0026#34;); time = DoublingRatio.TimeTrial(TwoSum.Count, a); doubleRatio = DoublingRatio.Test(TwoSum.Count); Console.WriteLine($\u0026#34;数据量：977 耗时：{time / 1000}\u0026#34;); Console.WriteLine($\u0026#34;数据量：1000000 估计耗时：{time * doubleRatio * 1024 / 1000}\u0026#34;); Console.WriteLine(); // TwoSumFast  // 速度太快，加大数据量  a = new int[62500]; for (int i = 0; i \u0026lt; 977; ++i) { a[i] = random.Next(62500) - 31250; } Console.WriteLine(\u0026#34;TwoSumFast\u0026#34;); time = DoublingRatio.TimeTrial(TwoSumFast.Count, a); doubleRatio = DoublingRatio.TestTwoSumFast(TwoSumFast.Count); Console.WriteLine($\u0026#34;数据量：62500 耗时：{time / 1000}\u0026#34;); Console.WriteLine($\u0026#34;数据量：1000000 估计耗时：{time * doubleRatio * 16 / 1000}\u0026#34;); Console.WriteLine(); } } } 另请参阅 #  委托-C#语言介绍\nMeasurement 库\n"},{"id":149,"href":"/1-4-42/","title":"1.4.42","section":"帮助","content":"1.4.42 #  解答 #  这里我们把时限设置为一小时，使用上一题的数据估计。\n1.ThreeSum 暴力方法在输入倍增时耗时增加 2^3 = 8 倍。\n1K 数据耗费了 1.15 秒，在一小时内（3600 秒）可以完成 2^3 = 8K 数据。\n2.ThreeSumFast 方法在输入倍增时耗时增加 2^2 = 4 倍。\n1K 数据耗费了 0.05 秒，在一小时内（3600 秒）可以完成 2^8 = 256K 数据。\n3.TwoSum 暴力方法在输入倍增时耗时增加 2^2 = 4 倍。\n8K 数据耗费了 0.14 秒，在一小时内（3600 秒）可以完成 2^10 = 1024K 数据。\n4.TwoSumFast 在输入倍增时耗时增加 2^1 = 2 倍。\n32K 数据耗费了 0.008 秒，在一小时内（3600 秒）可以完成 2^16 = 65536K 数据。\n"},{"id":150,"href":"/1-4-43/","title":"1.4.43","section":"帮助","content":"1.4.43 #  解答 #  代码 #  修改后的 DoublingRatio\nusing System; using Measurement; namespace _1._4._43 { static class DoublingRatio { /// \u0026lt;summary\u0026gt;  /// 从指定字符串中读入按行分割的整型数据。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;inputString\u0026#34;\u0026gt;源字符串。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;读入的整型数组\u0026lt;/returns\u0026gt;  private static int[] ReadAllInts(string inputString) { char[] split = new char[1] { \u0026#39;\\n\u0026#39; }; string[] input = inputString.Split(split, StringSplitOptions.RemoveEmptyEntries); int[] a = new int[input.Length]; for (int i = 0; i \u0026lt; a.Length; ++i) { a[i] = int.Parse(input[i]); } return a; } /// \u0026lt;summary\u0026gt;  /// 使用给定的数组对链栈进行一次测试，返回耗时（毫秒）。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;测试用的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;耗时（毫秒）。\u0026lt;/returns\u0026gt;  public static double TimeTrialLinkedStack(int[] a) { LinkedStack\u0026lt;int\u0026gt; stack = new LinkedStack\u0026lt;int\u0026gt;(); int n = a.Length; Stopwatch timer = new Stopwatch(); for (int i = 0; i \u0026lt; n; ++i) { stack.Push(a[i]); } for (int i = 0; i \u0026lt; n; ++i) { stack.Pop(); } return timer.ElapsedTimeMillionSeconds(); } /// \u0026lt;summary\u0026gt;  /// 使用给定的数组对数组栈进行一次测试，返回耗时（毫秒）。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;测试用的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;耗时（毫秒）。\u0026lt;/returns\u0026gt;  public static double TimeTrialDoublingStack(int[] a) { DoublingStack\u0026lt;int\u0026gt; stack = new DoublingStack\u0026lt;int\u0026gt;(); int n = a.Length; Stopwatch timer = new Stopwatch(); for (int i = 0; i \u0026lt; n; ++i) { stack.Push(a[i]); } for (int i = 0; i \u0026lt; n; ++i) { stack.Pop(); } return timer.ElapsedTimeMillionSeconds(); } /// \u0026lt;summary\u0026gt;  /// 对链栈和基于大小可变的数组栈做测试。  /// \u0026lt;/summary\u0026gt;  public static void Test() { double linkedTime = 0; double arrayTime = 0; Console.WriteLine(\u0026#34;数据量\\t链栈\\t数组\\t比值\\t单位：毫秒\u0026#34;); // 16K  int[] a = ReadAllInts(TestCase.Properties.Resources._16Kints); linkedTime = TimeTrialLinkedStack(a); arrayTime = TimeTrialDoublingStack(a); Console.WriteLine($\u0026#34;16000\\t{linkedTime}\\t{arrayTime}\\t{linkedTime / arrayTime}\u0026#34;); // 32K  a = ReadAllInts(TestCase.Properties.Resources._32Kints); linkedTime = TimeTrialLinkedStack(a); arrayTime = TimeTrialDoublingStack(a); Console.WriteLine($\u0026#34;32000\\t{linkedTime}\\t{arrayTime}\\t{linkedTime / arrayTime}\u0026#34;); // 1M  a = ReadAllInts(TestCase.Properties.Resources._1Mints); linkedTime = TimeTrialLinkedStack(a); arrayTime = TimeTrialDoublingStack(a); Console.WriteLine($\u0026#34;1000000\\t{linkedTime}\\t{arrayTime}\\t{linkedTime / arrayTime}\u0026#34;); } } } 另请参阅 #  Measurement 库\n"},{"id":151,"href":"/1-4-44/","title":"1.4.44","section":"帮助","content":"1.4.44 #  解答 #  每生成一个随机数都和之前生成过的随机数相比较。\n代码 #  using System; namespace _1._4._44 { /* * 1.4.44 * * 生日问题。 * 编写一个程序， * 从命令行接受一个整数 N 作为参数并使用 StdRandom.uniform() 生成一系列 0 到 N-1 之间的随机整数。 * 通过实验验证产生第一个重复的随机数之前生成的整数数量为 ~√(πN/2)。 * */ class Program { static void Main(string[] args) { Random random = new Random(); int N = 10000; int[] a = new int[N]; int dupNum = 0; int times = 0; for (times = 0; times \u0026lt; 500; ++times) { for (int i = 0; i \u0026lt; N; ++i) { a[i] = random.Next(N); if (IsDuplicated(a, i)) { dupNum += i; Console.WriteLine($\u0026#34;生成{i + 1}个数字后发生重复\u0026#34;); break; } } } Console.WriteLine($\u0026#34;√(πN/2)={Math.Sqrt(Math.PI * N / 2.0)}，平均生成{dupNum / times}个数字后出现重复\u0026#34;); } /// \u0026lt;summary\u0026gt;  /// 检查是否有重复的数字出现。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要检查的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;当前加入数组元素的下标。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;有重复则返回 true，否则返回 false。\u0026lt;/returns\u0026gt;  static bool IsDuplicated(int[] a, int i) { for (int j = 0; j \u0026lt; i; ++j) { if (a[j] == a[i]) { return true; } } return false; } } } "},{"id":152,"href":"/1-4-45/","title":"1.4.45","section":"帮助","content":"1.4.45 #  解答 #  建立一个布尔数组，将每次随机出来的数作为下标，将相应位置的布尔值改为 true，每次随机都检查一遍这个数组是否都是 true。\n代码 #  using System; namespace _1._4._45 { /* * 1.4.45 * * 优惠券收集问题。 * 用和上一题相同的方式生成随机整数。 * 通过实验验证生成所有可能的整数值所需生成的随机数总量为 ~NHN。 * （这里的 HN 中 N 是下标） * */ class Program { // HN 指的是调和级数  static void Main(string[] args) { Random random = new Random(); int N = 10000; bool[] a = new bool[N]; int randomSize = 0; int times = 0; for (times = 0; times \u0026lt; 20; ++times) { for (int i = 0; i \u0026lt; N; ++i) { a[i] = false; } for(int i = 0; true; ++i) { int now = random.Next(N); a[now] = true; if (IsAllGenerated(a)) { randomSize += i; Console.WriteLine($\u0026#34;生成{i}次后所有可能均出现过了\u0026#34;); break; } } } Console.WriteLine($\u0026#34;\\nNHN={N * HarmonicSum(N)}，平均生成{randomSize / times}个数字后所有可能都出现\u0026#34;); } /// \u0026lt;summary\u0026gt;  /// 计算 N 阶调和级数的和。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;N\u0026#34;\u0026gt;调和级数的 N 值\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;N 阶调和级数的和。\u0026lt;/returns\u0026gt;  static double HarmonicSum(int N) { double sum = 0; for (int i = 1; i \u0026lt;= N; ++i) { sum += 1.0 / i; } return sum; } /// \u0026lt;summary\u0026gt;  /// 检查所有数字是否都生成过了。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;布尔数组。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;全都生成则返回 true，否则返回 false。\u0026lt;/returns\u0026gt;  static bool IsAllGenerated(bool[] a) { foreach (bool i in a) { if (!i) return false; } return true; } } } "},{"id":153,"href":"/1-5-1/","title":"1.5.1","section":"帮助","content":"1.5.1 #  解答 #  quick-find 的官方实现：QuickFindUF.java。\n只要实现相应并查集，然后输入内容即可。\n增加一个记录访问数组次数的类成员变量，在每次访问数组的语句执行后自增即可。\n样例输出：\n1 2 3 4 5 6 7 8 0 数组访问：13 1 2 4 4 5 6 7 8 0 数组访问：13 1 2 4 4 8 6 7 8 0 数组访问：13 1 2 4 4 8 6 2 8 0 数组访问：13 1 1 4 4 8 6 1 8 0 数组访问：14 1 1 4 4 1 6 1 1 0 数组访问：14 1 1 4 4 1 6 1 1 4 数组访问：14 1 1 1 1 1 6 1 1 1 数组访问：16 代码 #  QuickFindUF.cs，这个类继承了 UF.cs，重新实现了 Union() 和 Find() 等方法。\n关于 UF.cs 可以参见原书中文版 P138 或英文版 P221 的算法 1.5。\nnamespace UnionFind { /// \u0026lt;summary\u0026gt;  /// 用 QuickFind 算法实现的并查集。  /// \u0026lt;/summary\u0026gt;  public class QuickFindUF : UF { public int ArrayVisitCount { get; private set; } //记录数组访问的次数。  /// \u0026lt;summary\u0026gt;  /// 新建一个使用 quick-find 实现的并查集。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;并查集的大小。\u0026lt;/param\u0026gt;  public QuickFindUF(int n) : base(n) { } /// \u0026lt;summary\u0026gt;  /// 重置数组访问计数。  /// \u0026lt;/summary\u0026gt;  public void ResetArrayCount() { this.ArrayVisitCount = 0; } /// \u0026lt;summary\u0026gt;  /// 寻找 p 所在的连通分量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要寻找的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;返回 p 所在的连通分量。\u0026lt;/returns\u0026gt;  public override int Find(int p) { Validate(p); this.ArrayVisitCount++; return this.parent[p]; } /// \u0026lt;summary\u0026gt;  /// 判断两个结点是否属于同一个连通分量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要判断的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;q\u0026#34;\u0026gt;需要判断的另一个结点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;如果属于同一个连通分量则返回 true，否则返回 false。\u0026lt;/returns\u0026gt;  public override bool IsConnected(int p, int q) { Validate(p); Validate(q); this.ArrayVisitCount += 2; return this.parent[p] == this.parent[q]; } /// \u0026lt;summary\u0026gt;  /// 将两个结点所在的连通分量合并。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要合并的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;q\u0026#34;\u0026gt;需要合并的另一个结点。\u0026lt;/param\u0026gt;  public override void Union(int p, int q) { Validate(p); Validate(q); int pID = this.parent[p]; int qID = this.parent[q]; this.ArrayVisitCount += 2; // 如果两个结点同属于一个连通分量，那么什么也不做。  if (pID == qID) { return; } for (int i = 0; i \u0026lt; this.parent.Length; ++i) { if (this.parent[i] == pID) { this.parent[i] = qID; this.ArrayVisitCount++; } } this.ArrayVisitCount += this.parent.Length; this.count--; return; } /// \u0026lt;summary\u0026gt;  /// 获得 parent 数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;id 数组。\u0026lt;/returns\u0026gt;  public int[] GetParent() { return this.parent; } } } 另请参阅 #  UnionFind 库\n"},{"id":154,"href":"/1-5-2/","title":"1.5.2","section":"帮助","content":"1.5.2 #  解答 #  quick-union 的官方实现：QuickUnionUF.java。\n和上题一样的方式，增加一个记录访问数组次数的类成员变量，在每次访问数组的语句执行后自增即可。\n程序输出的森林，用缩进表示子树：\n|---- 0 |---- 9 |---- 1 |---- 2 |---- 3 |---- 4 |---- 5 |---- 6 |---- 7 |---- 8 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 4 |---- 3 |---- 5 |---- 6 |---- 7 |---- 8 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 4 |---- 3 |---- 6 |---- 7 |---- 8 |---- 5 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 7 |---- 4 |---- 3 |---- 6 |---- 8 |---- 5 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 7 |---- 4 |---- 3 |---- 6 |---- 8 |---- 5 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 7 |---- 8 |---- 5 |---- 4 |---- 3 |---- 6 数组访问：7 |---- 1 |---- 2 |---- 7 |---- 8 |---- 5 |---- 4 |---- 0 |---- 9 |---- 3 |---- 6 数组访问：3 |---- 1 |---- 2 |---- 7 |---- 4 |---- 0 |---- 9 |---- 3 |---- 8 |---- 5 |---- 6 数组访问：3 代码 #  QuickUnionUF.cs，这个类继承了 UF.cs，重新实现了 Union() 和 Find() 等方法。\n关于 UF.cs 可以参见原书中文版 P138 或英文版 P221 的算法 1.5。\nnamespace UnionFind { /// \u0026lt;summary\u0026gt;  /// 用 QuickUnion 算法实现的并查集。  /// \u0026lt;/summary\u0026gt;  public class QuickUnionUF : UF { public int ArrayVisitCount { get; private set; } //记录数组访问的次数。  /// \u0026lt;summary\u0026gt;  /// 建立使用 QuickUnion 的并查集。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;并查集的大小。\u0026lt;/param\u0026gt;  public QuickUnionUF(int n) : base(n) { } /// \u0026lt;summary\u0026gt;  /// 重置数组访问计数。  /// \u0026lt;/summary\u0026gt;  public virtual void ResetArrayCount() { this.ArrayVisitCount = 0; } /// \u0026lt;summary\u0026gt;  /// 获得 parent 数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;返回 parent 数组。\u0026lt;/returns\u0026gt;  public int[] GetParent() { return this.parent; } /// \u0026lt;summary\u0026gt;  /// 寻找一个结点所在的连通分量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要寻找的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;该结点所属的连通分量。\u0026lt;/returns\u0026gt;  public override int Find(int p) { Validate(p); while (p != this.parent[p]) { p = this.parent[p]; this.ArrayVisitCount += 2; } return p; } /// \u0026lt;summary\u0026gt;  /// 将两个结点所属的连通分量合并。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要合并的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;q\u0026#34;\u0026gt;需要合并的另一个结点。\u0026lt;/param\u0026gt;  public override void Union(int p, int q) { int rootP = Find(p); int rootQ = Find(q); if (rootP == rootQ) { return; } this.parent[rootP] = rootQ; this.ArrayVisitCount++; this.count--; } } } Main 方法\nusing System; using UnionFind; namespace _1._5._2 { /* * 1.5.2 * * 使用 quick-union 算法（请见 1.5.2.3 节代码框）完成练习 1.5.1。 * 另外，在处理完输入的每对整数之后画出 id[] 数组表示的森林。 * */ class Program { static void Main(string[] args) { string[] input = \u0026#34;9-0 3-4 5-8 7-2 2-1 5-7 0-3 4-2\u0026#34;.Split(\u0026#39; \u0026#39;); var quickUnion = new QuickUnionUF(10); foreach (string s in input) { quickUnion.ResetArrayCount(); string[] numbers = s.Split(\u0026#39;-\u0026#39;); int p = int.Parse(numbers[0]); int q = int.Parse(numbers[1]); quickUnion.Union(p, q); int[] parent = quickUnion.GetParent(); for (int i = 0; i \u0026lt; parent.Length; ++i) { if (parent[i] == i) { Console.WriteLine(\u0026#34;|---- \u0026#34; + i); DFS(parent, i, 1); } } Console.WriteLine(\u0026#34;数组访问：\u0026#34; + quickUnion.ArrayVisitCount); } } static void DFS(int[] parent, int root, int level) { for (int i = 0; i \u0026lt; parent.Length; ++i) { if (parent[i] == root \u0026amp;\u0026amp; i != root) { for (int j = 0; j \u0026lt; level; ++j) { Console.Write(\u0026#34; \u0026#34;); } Console.WriteLine(\u0026#34;|---- \u0026#34; + i); DFS(parent, i, level + 1); } } } } } 另请参阅 #  UnionFind 库\n"},{"id":155,"href":"/1-5-3/","title":"1.5.3","section":"帮助","content":"1.5.3 #  解答 #  加权 quick-union 的官方实现：WeightedQuickUnionUF.java。\n样例输出：\n1 2 3 4 5 6 7 8 9 数组访问：3 1 2 3 3 5 6 7 8 9 数组访问：3 1 2 3 3 5 6 7 5 9 数组访问：3 1 7 3 3 5 6 7 5 9 数组访问：3 7 7 3 3 5 6 7 5 9 数组访问：5 7 7 3 3 7 6 7 5 9 数组访问：3 7 7 9 3 7 6 7 5 9 数组访问：5 7 7 9 3 7 6 7 5 7 数组访问：9 代码 #  WeightedQuickUnionUF.cs，这个类继承了 QuickUnion.cs，重新实现了 Union() 和 Find() 等方法。\n关于 QuickUnion.cs 可以参见 1.5.2 的代码部分。\nnamespace UnionFind { /// \u0026lt;summary\u0026gt;  /// 使用加权 quick-union 算法的并查集。  /// \u0026lt;/summary\u0026gt;  public class WeightedQuickUnionUF : QuickUnionUF { protected int[] size; // 记录各个树的大小。  public int ArrayParentVisitCount { get; private set; } // 记录 parent 数组的访问次数。  public int ArraySizeVisitCount { get; private set; } //记录 size 数组的访问次数。  /// \u0026lt;summary\u0026gt;  /// 建立使用加权 quick-union 的并查集。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;并查集的大小。\u0026lt;/param\u0026gt;  public WeightedQuickUnionUF(int n) : base(n) { this.size = new int[n]; for (int i = 0; i \u0026lt; n; ++i) { this.size[i] = 1; } this.ArrayParentVisitCount = 0; this.ArraySizeVisitCount = 0; } /// \u0026lt;summary\u0026gt;  /// 清零数组访问计数。  /// \u0026lt;/summary\u0026gt;  public override void ResetArrayCount() { this.ArrayParentVisitCount = 0; this.ArraySizeVisitCount = 0; } /// \u0026lt;summary\u0026gt;  /// 获取 size 数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;返回 size 数组。\u0026lt;/returns\u0026gt;  public int[] GetSize() { return this.size; } /// \u0026lt;summary\u0026gt;  /// 寻找一个结点所在的连通分量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要寻找的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;该结点所属的连通分量。\u0026lt;/returns\u0026gt;  public override int Find(int p) { Validate(p); while (p != this.parent[p]) { p = this.parent[p]; this.ArrayParentVisitCount += 2; } this.ArrayParentVisitCount++; return p; } /// \u0026lt;summary\u0026gt;  /// 将两个结点所属的连通分量合并。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要合并的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;q\u0026#34;\u0026gt;需要合并的另一个结点。\u0026lt;/param\u0026gt;  public override void Union(int p, int q) { int rootP = Find(p); int rootQ = Find(q); if (rootP == rootQ) { return; } if (this.size[rootP] \u0026lt; this.size[rootQ]) { this.parent[rootP] = rootQ; this.size[rootQ] += this.size[rootP]; } else { this.parent[rootQ] = rootP; this.size[rootP] += this.size[rootQ]; } this.ArrayParentVisitCount++; this.ArraySizeVisitCount += 4; this.count--; } } } Main 方法\nusing System; using UnionFind; namespace _1._5._3 { /* * 1.5.3 * * 使用加权 quick-union 算法（请见算法 1.5）完成练习 1.5.1 。 * */ class Program { static void Main(string[] args) { string[] input = \u0026#34;9-0 3-4 5-8 7-2 2-1 5-7 0-3 4-2\u0026#34;.Split(\u0026#39; \u0026#39;); var weightedQuickUnion = new WeightedQuickUnionUF(10); foreach (string s in input) { weightedQuickUnion.ResetArrayCount(); string[] numbers = s.Split(\u0026#39;-\u0026#39;); int p = int.Parse(numbers[0]); int q = int.Parse(numbers[1]); weightedQuickUnion.Union(p, q); int[] parent = weightedQuickUnion.GetParent(); for (int i = 0; i \u0026lt; parent.Length; ++i) { Console.Write(parent[i] + \u0026#34; \u0026#34;); } Console.WriteLine(\u0026#34;数组访问：\u0026#34; + weightedQuickUnion.ArrayParentVisitCount); } } } } 另请参阅 #  UnionFind 库\n"},{"id":156,"href":"/1-5-4/","title":"1.5.4","section":"帮助","content":"1.5.4 #  解答 #  对照输入和最坏输入均在书中出现，中文版见：P146，英文版见：P229。\n样例输出：\n3 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 5 6 7 8 9 size: 1 1 1 1 2 1 1 1 1 1 parent visit count:3 size visit count:4 8 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 5 6 7 4 9 size: 1 1 1 1 3 1 1 1 1 1 parent visit count:5 size visit count:4 5 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 6 6 7 4 9 size: 1 1 1 1 3 1 2 1 1 1 parent visit count:3 size visit count:4 4 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 6 6 7 4 4 size: 1 1 1 1 4 1 2 1 1 1 parent visit count:3 size visit count:4 1 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 2 2 4 4 6 6 7 4 4 size: 1 1 2 1 4 1 2 1 1 1 parent visit count:3 size visit count:4 9 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 2 2 4 4 6 6 7 4 4 size: 1 1 2 1 4 1 2 1 1 1 parent visit count:6 size visit count:0 0 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 2 4 4 6 6 7 4 4 size: 1 1 2 1 4 1 3 1 1 1 parent visit count:5 size visit count:4 2 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 2 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 3 1 1 1 parent visit count:3 size visit count:4 1 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 6 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 6 1 1 1 parent visit count:5 size visit count:4 0 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 6 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 6 1 1 1 parent visit count:8 size visit count:0 7 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 6 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 6 1 1 1 parent visit count:6 size visit count:0 ------------------------------------- 1 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 2 3 4 5 6 7 8 9 size: 2 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 2 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 3 4 5 6 7 8 9 size: 3 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 3 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 4 5 6 7 8 9 size: 4 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 4 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 5 6 7 8 9 size: 5 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 5 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 6 7 8 9 size: 6 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 6 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 7 8 9 size: 7 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 7 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 0 8 9 size: 8 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 8 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 0 0 9 size: 9 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 9 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 0 0 0 size: 10 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 代码 #  Main 方法：\nusing System; using UnionFind; namespace _1._5._4 { /* * 1.5.4 * * 在正文的加权 quick-union 算法示例中， * 对于输入的每一对整数（包括对照输入和最坏情况下的输入）， * 给出 id[] 和 sz[] 数组的内容以及访问数组的次数。 * */ class Program { static void Main(string[] args) { char[] split = { \u0026#39;\\n\u0026#39;, \u0026#39;\\r\u0026#39; }; string[] inputReference = TestCase.Properties.Resources.tinyUF.Split(split, StringSplitOptions.RemoveEmptyEntries); string[] inputWorst = TestCase.Properties.Resources.worstUF.Split(split, StringSplitOptions.RemoveEmptyEntries); RunTest(inputReference); Console.WriteLine(\u0026#34;-------------------------------------\u0026#34;); RunTest(inputWorst); } static void RunTest(string[] input) { var weightedQuickUnion = new WeightedQuickUnionUF(10); int n = int.Parse(input[0]); int[] parent = weightedQuickUnion.GetParent(); int[] size = weightedQuickUnion.GetSize(); for (int i = 1; i \u0026lt; input.Length; ++i) { string[] unit = input[i].Split(\u0026#39; \u0026#39;); int p = int.Parse(unit[0]); int q = int.Parse(unit[1]); Console.WriteLine($\u0026#34;{p} {q}\u0026#34;); weightedQuickUnion.Union(p, q); Console.Write(\u0026#34;index:\\t\u0026#34;); for (int j = 0; j \u0026lt; 10; ++j) { Console.Write(j + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.Write(\u0026#34;parent:\\t\u0026#34;); foreach (int m in parent) { Console.Write(m + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.Write(\u0026#34;size:\\t\u0026#34;); foreach (int m in size) { Console.Write(m + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.WriteLine(\u0026#34;parent visit count:\u0026#34; + weightedQuickUnion.ArrayParentVisitCount); Console.WriteLine(\u0026#34;size visit count:\u0026#34; + weightedQuickUnion.ArraySizeVisitCount); Console.WriteLine(); weightedQuickUnion.ResetArrayCount(); } } } } 另请参阅 #  UnionFind 库\n"},{"id":157,"href":"/1-5-5/","title":"1.5.5","section":"帮助","content":"1.5.5 #  解答 #  $10^6$ 条连接 = $10^6$ 组输入。\n对于 quick-find 算法，每次 union() 都要遍历整个数组。\n因此总共进行了 $10^9 \\times 10^6 = 10^{15}$ 次 for 循环迭代。\n每次 for 循环迭代都需要 $10$ 条机器指令，\n因此总共执行了 $10 \\times10^{15} = 10^{16}$ 条机器指令。\n已知计算机每秒能够执行 $10^9$ 条机器指令，\n因此执行完所有指令需要 $10^{16} / 10^9 = 10^7$ 秒 = $115.74$ 天。\n"},{"id":158,"href":"/1-5-6/","title":"1.5.6","section":"帮助","content":"1.5.6 #  解答 #  加权 quick-union 算法最多只需要 $lgN $次迭代就可以完成一次 union()。\n因此按照上题思路，总共需要 $(lg(10^9) \\times 10^6 \\times 10) / 10^9 = 0.299$ 秒。\n"},{"id":159,"href":"/1-5-7/","title":"1.5.7","section":"帮助","content":"1.5.7 #  解答 #  见 1.5.1 和 1.5.2 的解答。\n"},{"id":160,"href":"/1-5-8/","title":"1.5.8","section":"帮助","content":"1.5.8 #  解答 #  当有多个元素需要修改的时候，这个直观算法可能会出现错误。\n例如如下情况：\nindex 0 1 2 3 4 5 6 7 8 9\nid 0 0 0 0 0 5 5 5 5 5\n输入 0, 5\ni = 0 时，id[i] == id[p]，此时 id[i] = id[q]。\n数组变为 5 0 0 0 0 5 5 5 5 5\ni = 1 时，id[i] != id[p]，算法出现错误。\n如果在 id[p] 之后还有需要修改的元素，那么这个算法就会出现错误。\n"},{"id":161,"href":"/1-5-9/","title":"1.5.9","section":"帮助","content":"1.5.9 #  解答 #  不可能。 树如下所示。\n由于加权 quick-union 算法任意节点的最大深度为 lgN （节点总数为 N）。\n（这个结论可以在中文版 P146，或者英文版 P228 找到）\n上面这个树的最大深度为 4 \u0026gt; lg10\n因此这棵树不可能是通过加权 quick-union 算法得到的。\n"},{"id":162,"href":"/1-5-10/","title":"1.5.10","section":"帮助","content":"1.5.10 #  解答 #  本题答案已经给出，也很好理解。\n如果合并时只是把子树挂到结点 q 上而非其根节点，\n树的高度会明显增加，进而增加每次 Find() 操作的开销。\n"},{"id":163,"href":"/1-5-11/","title":"1.5.11","section":"帮助","content":"1.5.11 #  解答 #  类似于加权 quick-union 的做法，新增一个 size[] 数组以记录各个根节点的大小。\n每次合并时先比较一下两棵树的大小，再进行合并。\n这样会略微减少赋值语句的执行次数，提升性能。\n代码 #  WeightedQuickFindUF.cs\nusing System; namespace _1._5._11 { /// \u0026lt;summary\u0026gt;  /// 用加权 QuickFind 算法实现的并查集。  /// \u0026lt;/summary\u0026gt;  public class WeightedQuickFindUF { private int[] size; // 记录每个连通分量的大小。  private int[] id; // 记录每个结点的连通分量。  private int count;// 连通分量总数。  public int ArrayVisitCount { get; private set; } //记录数组访问的次数。  /// \u0026lt;summary\u0026gt;  /// 新建一个使用加权 quick-find 实现的并查集。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;并查集的大小。\u0026lt;/param\u0026gt;  public WeightedQuickFindUF(int n) { this.count = n; this.id = new int[n]; this.size = new int[n]; for (int i = 0; i \u0026lt; n; ++i) { this.id[i] = i; this.size[i] = 1; } } /// \u0026lt;summary\u0026gt;  /// 重置数组访问计数。  /// \u0026lt;/summary\u0026gt;  public void ResetArrayCount() { this.ArrayVisitCount = 0; } /// \u0026lt;summary\u0026gt;  /// 表示并查集中连通分量的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;返回并查集中连通分量的数量。\u0026lt;/returns\u0026gt;  public int Count() { return this.count; } /// \u0026lt;summary\u0026gt;  /// 寻找 p 所在的连通分量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要寻找的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;返回 p 所在的连通分量。\u0026lt;/returns\u0026gt;  public int Find(int p) { Validate(p); this.ArrayVisitCount++; return this.id[p]; } /// \u0026lt;summary\u0026gt;  /// 判断两个结点是否属于同一个连通分量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要判断的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;q\u0026#34;\u0026gt;需要判断的另一个结点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;如果属于同一个连通分量则返回 true，否则返回 false。\u0026lt;/returns\u0026gt;  public bool IsConnected(int p, int q) { Validate(p); Validate(q); this.ArrayVisitCount += 2; return this.id[p] == this.id[q]; } /// \u0026lt;summary\u0026gt;  /// 将两个结点所在的连通分量合并。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要合并的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;q\u0026#34;\u0026gt;需要合并的另一个结点。\u0026lt;/param\u0026gt;  public void Union(int p, int q) { Validate(p); Validate(q); int pID = this.id[p]; int qID = this.id[q]; this.ArrayVisitCount += 2; // 如果两个结点同属于一个连通分量，那么什么也不做。  if (pID == qID) { return; } // 判断较大的连通分量和较小的连通分量。  int larger = 0; int smaller = 0; if (this.size[pID] \u0026gt; this.size[qID]) { larger = pID; smaller = qID; this.size[pID] += this.size[qID]; } else { larger = qID; smaller = pID; this.size[qID] += this.size[pID]; } // 将较小的连通分量连接到较大的连通分量上，  // 这会减少赋值语句的执行次数，略微减少数组访问。  for (int i = 0; i \u0026lt; this.id.Length; ++i) { if (this.id[i] == smaller) { this.id[i] = larger; this.ArrayVisitCount++; } } this.ArrayVisitCount += this.id.Length; this.count--; return; } /// \u0026lt;summary\u0026gt;  /// 获得 id 数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;id 数组。\u0026lt;/returns\u0026gt;  public int[] GetID() { return this.id; } /// \u0026lt;summary\u0026gt;  /// 验证输入的结点是否有效。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要验证的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;exception cref=\u0026#34;ArgumentException\u0026#34;\u0026gt;输入的 p 值无效。\u0026lt;/exception\u0026gt;  private void Validate(int p) { int n = this.id.Length; if (p \u0026lt; 0 || p \u0026gt; n) { throw new ArgumentException(\u0026#34;index \u0026#34; + p + \u0026#34; is not between 0 and \u0026#34; + (n - 1)); } } } } Main 方法\nusing System; using UnionFind; namespace _1._5._11 { /* * 1.5.11 * * 实现加权 quick-find 算法，其中我们总是将较小的分量重命名为较大分量的标识符。 * 这种改变会对性能产生怎样的影响？ * */ class Program { static void Main(string[] args) { char[] split = { \u0026#39;\\n\u0026#39;, \u0026#39;\\r\u0026#39; }; string[] input = TestCase.Properties.Resources.mediumUF.Split(split, StringSplitOptions.RemoveEmptyEntries); int size = int.Parse(input[0]); QuickFindUF quickFind = new QuickFindUF(size); WeightedQuickFindUF weightedQuickFind = new WeightedQuickFindUF(size); int p, q; string[] pair; for (int i = 1; i \u0026lt; size; ++i) { pair = input[i].Split(\u0026#39; \u0026#39;); p = int.Parse(pair[0]); q = int.Parse(pair[1]); quickFind.Union(p, q); weightedQuickFind.Union(p, q); } Console.WriteLine(\u0026#34;quick-find: \u0026#34; + quickFind.ArrayVisitCount); Console.WriteLine(\u0026#34;weighted quick-find: \u0026#34; + weightedQuickFind.ArrayVisitCount); } } } 另请参阅 #  UnionFind 库\n"},{"id":164,"href":"/1-5-12/","title":"1.5.12","section":"帮助","content":"1.5.12 #  解答 #  QuickUnionPathCompression 的官方实现：QuickUnionPathCompressionUF.java\n在找到根节点之后，再访问一遍 p 到根节点这条路径上的所有结点，将它们直接和根节点相连。\n重写过后的 Find() 方法：\n/// \u0026lt;summary\u0026gt; /// 寻找结点所属的连通分量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要寻找的结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;结点所属的连通分量。\u0026lt;/returns\u0026gt; public override int Find(int p) { int root = p; while (root != this.parent[root]) { root = this.parent[root]; } while (p != root) { int newp = this.parent[p]; this.parent[p] = root; p = newp; } return p; } 由于路径压缩是在 Find() 方法中实现的，\n只要输入保证是根节点两两相连即可构造较长的路径。\n代码 #  QuickUnionPathCompressionUF.cs 直接从 QuickUnionUF.cs 继承而来。\n关于 QuickUnionUF.cs，参见 1.5.2 的解答。\nnamespace UnionFind { /// \u0026lt;summary\u0026gt;  /// 使用路径压缩的 quick-union 并查集。  /// \u0026lt;/summary\u0026gt;  public class QuickUnionPathCompressionUF : QuickFindUF { /// \u0026lt;summary\u0026gt;  /// 新建一个大小为 n 的并查集。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;新建并查集的大小。\u0026lt;/param\u0026gt;  public QuickUnionPathCompressionUF(int n) : base(n) { } /// \u0026lt;summary\u0026gt;  /// 寻找结点所属的连通分量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要寻找的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;结点所属的连通分量。\u0026lt;/returns\u0026gt;  public override int Find(int p) { int root = p; while (root != this.parent[root]) { root = this.parent[root]; } while (p != root) { int newp = this.parent[p]; this.parent[p] = root; p = newp; } return p; } } } Main 方法\nusing System; using UnionFind; namespace _1._5._12 { /* * 1.5.12 * * 使用路径压缩的 quick-union 算法。 * 根据路径压缩修改 quick-union 算法（请见 1.5.2.3 节）， * 在 find() 方法中添加一个循环来将从 p 到根节点的路径上的每个触点都连接到根节点。 * 给出一列输入，使该方法能够产生一条长度为 4 的路径。 * 注意：该算法的所有操作的均摊成本已知为对数级别。 * */ class Program { static void Main(string[] args) { var UF = new QuickUnionPathCompressionUF(10); // 使用书中提到的最坏情况，0 连 1，1 连 2，2 连 3……  for (int i = 0; i \u0026lt; 4; ++i) { UF.Union(i, i + 1); } int[] id = UF.GetParent(); for (int i = 0; i \u0026lt; id.Length; ++i) { Console.Write(id[i]); } Console.WriteLine(); } } } 另请参阅 #  UnionFind 库\n"},{"id":165,"href":"/1-5-13/","title":"1.5.13","section":"帮助","content":"1.5.13 #  解答 #  官方实现：WeightedQuickUnionPathCompressionUF。\n加权 quick-union 中，两个大小相等的树合并可以有效增加高度，同时输入必须保证是根节点以规避路径压缩。\n代码 #  WeightedQuickUnionPathCompressionUF.cs 从 WeightedQuickUnionUF.cs 继承，详情参见 1.5.3 的解答。\nnamespace UnionFind { /// \u0026lt;summary\u0026gt;  /// 使用路径压缩的加权 quick-union 并查集。  /// \u0026lt;/summary\u0026gt;  public class WeightedQuickUnionPathCompressionUF : WeightedQuickUnionUF { /// \u0026lt;summary\u0026gt;  /// 新建一个大小为 n 的并查集。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;新建并查集的大小。\u0026lt;/param\u0026gt;  public WeightedQuickUnionPathCompressionUF(int n) : base(n) { this.size = new int[n]; for (int i = 0; i \u0026lt; n; ++i) { this.size[i] = 1; } } /// \u0026lt;summary\u0026gt;  /// 寻找一个结点所在的连通分量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要寻找的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;该结点所属的连通分量。\u0026lt;/returns\u0026gt;  public override int Find(int p) { Validate(p); int root = p; while (root != this.parent[p]) { root = this.parent[p]; } while (p != root) { int newP = this.parent[p]; this.parent[p] = root; p = newP; } return root; } } } Main 方法\nusing System; using UnionFind; namespace _1._5._13 { /* * 1.5.13 * * 使用路径压缩的加权 quick-union 算法。 * 修改加权 quick-union 算法（算法 1.5）， * 实现如练习 1.5.12 所述的路径压缩。给出一列输入， * 使该方法能产生一棵高度为 4 的树。 * 注意：该算法的所有操作的均摊成本已知被限制在反 Ackermann 函数的范围之内， * 且对于实际应用中可能出现的所有 N 值均小于 5。 * */ class Program { static void Main(string[] args) { var UF = new WeightedQuickUnionPathCompressionUF(10); // 见中文版 P146 或英文版 P229 中加权 quick-union 的最坏输入。  UF.Union(0, 1); UF.Union(2, 3); UF.Union(4, 5); UF.Union(6, 7); UF.Union(0, 2); UF.Union(4, 6); UF.Union(0, 4); int[] id = UF.GetParent(); for (int i = 0; i \u0026lt; id.Length; ++i) { Console.Write(id[i]); } Console.WriteLine(); } } } 另请参阅 #  UnionFind 库\n"},{"id":166,"href":"/1-5-14/","title":"1.5.14","section":"帮助","content":"1.5.14 #  解答 #  WeightedQuickUnionByHeight 的官方实现：WeightedQuickUnionByHeightUF.java。\n证明：\n一次 Union 操作只可能发生如下两种情况。\n1.两棵树的高度相同，这样合并后的新树的高度等于较大那棵树的高度 + 1。\n2.两棵树的高度不同，这样合并后的新树高度等于较大那棵树的高度。\n现在证明通过加权 quick-union 算法构造的高度为 h 的树至少包含 2h 个结点。\n基础情况，高度 h = 0, 结点数 k = 1。\n为了使高度增加，必须用一棵高度相同的树合并，而 h = 0 时结点数一定是 1，则：\nh = 1, k = 2\n由于两棵大小不同的树合并，最大高度不会增加，只会增加结点数。\n因此，每次都使用相同高度的最小树进行合并，有：\nh = 2, k = 4\nh = 3, k = 8\nh = 4, k = 16\n\u0026hellip;\u0026hellip;\n递推即可得到结论，k ≥ 2^h\n因此 h \u0026lt;= lgk\n代码 #  namespace UnionFind { public class WeightedQuickUnionByHeightUF : QuickUnionUF { private int[] height; /// \u0026lt;summary\u0026gt;  /// 新建一个以高度作为判断依据的加权 quick-union 并查集。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;新建并查集的大小。\u0026lt;/param\u0026gt;  public WeightedQuickUnionByHeightUF(int n) : base(n) { this.height = new int[n]; for (int i = 0; i \u0026lt; n; ++i) { this.height[i] = 0; } } /// \u0026lt;summary\u0026gt;  /// 将两个结点所属的连通分量合并。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要合并的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;q\u0026#34;\u0026gt;需要合并的另一个结点。\u0026lt;/param\u0026gt;  public override void Union(int p, int q) { int rootP = Find(p); int rootQ = Find(q); if (rootP == rootQ) { return; } if (this.height[rootP] \u0026lt; this.height[rootQ]) { this.parent[rootP] = rootQ; } else if (this.height[rootP] \u0026gt; this.height[rootQ]) { this.parent[rootQ] = rootP; } else { this.parent[rootQ] = rootP; this.height[rootP]++; } this.count--; } } } 另请参阅 #  UnionFind 库\n"},{"id":167,"href":"/1-5-15/","title":"1.5.15","section":"帮助","content":"1.5.15 #  解答 #  首先证明在最坏情况下加权 quick-union 算法生成的树中的每一层结点数均为二项式系数。\n最坏情况下，每次 union 操作都是合并相同大小的树，如下图所示：\n设第 i 层的结点数为 ki，那么最坏情况下每次合并后的 ki’ = ki + ki-1 。\n这符合二项式系数的构造特点（详情可以搜索杨辉三角），\n第一个结论证明完毕。\n接下来求平均深度，首先根据二项式的求和公式，一棵深度为 n 的树（根结点的深度为零）结点总数为：\n$$\n\\sum_{k=0}^{n}\n\\begin{pmatrix}\nn \\\nk\n\\end{pmatrix}\n=2^n\n$$\n每层结点数 × 该层深度后的和为：\n$$\n\\sum_{k=0}^{n}k \\cdot\n\\begin{pmatrix}\nn \\\nk\n\\end{pmatrix}=n\\sum_{k=1}^{n}\n\\begin{pmatrix}\nn-1 \\\nk-1\n\\end{pmatrix}=n\\sum_{s=0}^{n-1}\n\\begin{pmatrix}\nn-1 \\\ns\n\\end{pmatrix}=n2^{n-1}\n$$\n这里用到了这个公式化简：\n$$\n\\begin{pmatrix}\nn \\\nk\n\\end{pmatrix}=\\frac{n}{k}\n\\begin{pmatrix}\nn-1 \\\nk-1\n\\end{pmatrix}\n$$\n相除可以求得平均深度：\n$$\n\\bar{D} = \\frac{\\sum_{k=0}^{n}k\\cdot\\begin{pmatrix}n\\k\\end{pmatrix}}{\\sum_{k=0}^{n}\\begin{pmatrix}n\\k\\end{pmatrix}}=\\frac{n2^{n-1}}{2^n}=\\frac{n}{2}\n$$\n"},{"id":168,"href":"/1-5-16/","title":"1.5.16","section":"帮助","content":"1.5.16 #  解答 #  给出绘图结果样例：\n代码 #  仅给出绘图相关的代码，窗体部分见 github 上的代码：\nusing System; using System.Linq; using System.Windows.Forms; using System.Drawing; using UnionFind; namespace _1._5._16 { /* * 1.5.16 * * 均摊成本的图像。 * 修改你为练习 1.5.7 给出的实现， * 绘出如正文所示的均摊成本的图像。 * */ static class Program { [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Compute(); Application.Run(new Form1()); } static void Compute() { char[] split = { \u0026#39;\\n\u0026#39;, \u0026#39;\\r\u0026#39; }; string[] input = TestCase.Properties.Resources.mediumUF.Split(split, StringSplitOptions.RemoveEmptyEntries); int size = int.Parse(input[0]); QuickFindUF quickFind = new QuickFindUF(size); QuickUnionUF quickUnion = new QuickUnionUF(size); string[] pair; int p, q; int[] quickFindResult = new int[size]; int[] quickUnionResult = new int[size]; for (int i = 1; i \u0026lt; size; ++i) { pair = input[i].Split(\u0026#39; \u0026#39;); p = int.Parse(pair[0]); q = int.Parse(pair[1]); quickFind.Union(p, q); quickUnion.Union(p, q); quickFindResult[i - 1] = quickFind.ArrayVisitCount; quickUnionResult[i - 1] = quickUnion.ArrayVisitCount; quickFind.ResetArrayCount(); quickUnion.ResetArrayCount(); } Draw(quickFindResult); Draw(quickUnionResult); } static void Draw(int[] cost) { // 构建 total 数组。  int[] total = new int[cost.Length]; total[0] = cost[0]; for (int i = 1; i \u0026lt; cost.Length; ++i) { total[i] = total[i - 1] + cost[i]; } // 获得最大值。  int costMax = cost.Max(); // 新建绘图窗口。  Form2 plot = new Form2(); plot.Show(); Graphics graphics = plot.CreateGraphics(); // 获得绘图区矩形。  RectangleF rect = plot.ClientRectangle; float unitX = rect.Width / 10; float unitY = rect.Width / 10; // 添加 10% 边距作为文字区域。  RectangleF center = new RectangleF (rect.X + unitX, rect.Y + unitY, rect.Width - 2 * unitX, rect.Height - 2 * unitY); // 绘制坐标系。  graphics.DrawLine(Pens.Black, center.Left, center.Top, center.Left, center.Bottom); graphics.DrawLine(Pens.Black, center.Left, center.Bottom, center.Right, center.Bottom); graphics.DrawString(costMax.ToString(), plot.Font, Brushes.Black, rect.Location); graphics.DrawString(cost.Length.ToString(), plot.Font, Brushes.Black, center.Right, center.Bottom); graphics.DrawString(\u0026#34;0\u0026#34;, plot.Font, Brushes.Black, rect.Left, center.Bottom); // 初始化点。  PointF[] grayPoints = new PointF[cost.Length]; PointF[] redPoints = new PointF[cost.Length]; unitX = center.Width / cost.Length; unitY = center.Width / costMax; for (int i = 0; i \u0026lt; cost.Length; ++i) { grayPoints[i] = new PointF(center.Left + unitX * (i + 1), center.Bottom - (cost[i] * unitY)); redPoints[i] = new PointF(center.Left + unitX * (i + 1), center.Bottom - ((total[i] / (i + 1)) * unitY)); } // 绘制点。  for (int i = 0; i \u0026lt; cost.Length; ++i) { graphics.DrawEllipse(Pens.Gray, new RectangleF(grayPoints[i], new SizeF(2, 2))); graphics.DrawEllipse(Pens.Red, new RectangleF(redPoints[i], new SizeF(2, 2))); } graphics.Dispose(); } } } "},{"id":169,"href":"/1-5-17/","title":"1.5.17","section":"帮助","content":"1.5.17 #  解答 #  官方给出的 ErdosRenyi：ErdosRenyi.java。\n为了方便之后做题，除了 Count() 之外，这个类还包含其他方法，具体可以查看注释。\n代码 #  ErdosRenyi.cs\nusing System; using System.Collections.Generic; namespace UnionFind { /// \u0026lt;summary\u0026gt;  /// 提供一系列对并查集进行随机测试的静态方法。  /// \u0026lt;/summary\u0026gt;  public class ErdosRenyi { /// \u0026lt;summary\u0026gt;  /// 随机生成一组能让并查集只剩一个连通分量的连接。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;并查集大小。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;一组能让并查集只剩一个连通分量的连接。\u0026lt;/returns\u0026gt;  public static Connection[] Generate(int n) { Random random = new Random(); List\u0026lt;Connection\u0026gt; connections = new List\u0026lt;Connection\u0026gt;(); WeightedQuickUnionPathCompressionUF uf = new WeightedQuickUnionPathCompressionUF(n); while (uf.Count() \u0026gt; 1) { int p = random.Next(n); int q = random.Next(n); uf.Union(p, q); connections.Add(new Connection(p, q)); } return connections.ToArray(); } /// \u0026lt;summary\u0026gt;  /// 随机生成连接，返回令并查集中只剩一个连通分量所需的连接总数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;uf\u0026#34;\u0026gt;用于测试的并查集。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;需要的连接总数。\u0026lt;/returns\u0026gt;  public static int Count(UF uf) { Random random = new Random(); int size = uf.Count(); int edges = 0; while (uf.Count() \u0026gt; 1) { int p = random.Next(size); int q = random.Next(size); uf.Union(p, q); edges++; } return edges; } /// \u0026lt;summary\u0026gt;  /// 使用指定的连接按顺序合并。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;uf\u0026#34;\u0026gt;需要测试的并查集。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;connections\u0026#34;\u0026gt;用于输入的连接集合。\u0026lt;/param\u0026gt;  public static void Count(UF uf, Connection[] connections) { foreach (Connection c in connections) { uf.Union(c.P, c.Q); } } } } Main 方法：\nusing System; using UnionFind; namespace _1._5._17 { /* * 1.5.17 * * 随机链接。 * 设计 UF 的一个用例 ErdosRenyi， * 从命令行接受一个整数 N，在 0 到 N-1 之间产生随机整数对， * 调用 connected() 判断它们是否相连， * 如果不是则调用 union() 方法（和我们的开发用例一样）。 * 不断循环直到所有触点均相互连通并打印出生成的连接总数。 * 将你的程序打包成一个接受参数 N 并返回连接总数的静态方法 count()， * 添加一个 main() 方法从命令行接受 N，调用 count() 并打印它的返回值。 * */ class Program { static void Main(string[] args) { int N = 10; int[] edges = new int[5]; for (int i = 0; i \u0026lt; 5; ++i) { var uf = new UF(N); Console.WriteLine(N + \u0026#34;\\t\u0026#34; + ErdosRenyi.Count(uf)); N *= 10; } } } } 另请参阅 #  UnionFind 库\n"},{"id":170,"href":"/1-5-18/","title":"1.5.18","section":"帮助","content":"1.5.18 #  解答 #  具体生成的连接样式见下题，这里给出 RandomGrid 的实现，需要使用 1.3 节中的随机背包辅助。\n代码 #  RandomGrid.cs\nusing System; using System.Collections.Generic; namespace UnionFind { public class RandomGrid { /// \u0026lt;summary\u0026gt;  /// 随机生成 n × n 网格中的所有连接。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;网格边长。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;随机排序的连接。\u0026lt;/returns\u0026gt;  public static RandomBag\u0026lt;Connection\u0026gt; Generate(int n) { var result = new RandomBag\u0026lt;Connection\u0026gt;(); var random = new Random(); // 建立横向连接  for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n - 1; ++j) { if (random.Next(10) \u0026gt; 4) { result.Add(new Connection(i * n + j, (i * n) + j + 1)); } else { result.Add(new Connection((i * n) + j + 1, i * n + j)); } } } // 建立纵向连接  for (int j = 0; j \u0026lt; n; ++j) { for (int i = 0; i \u0026lt; n - 1; ++i) { if (random.Next(10) \u0026gt; 4) { result.Add(new Connection(i * n + j, ((i + 1) * n) + j)); } else { result.Add(new Connection(((i + 1) * n) + j, i * n + j)); } } } return result; } /// \u0026lt;summary\u0026gt;  /// 随机生成 n × n 网格中的所有连接，返回一个连接数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;网格边长。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;连接数组。\u0026lt;/returns\u0026gt;  public static Connection[] GetConnections(int n) { RandomBag\u0026lt;Connection\u0026gt; bag = Generate(n); List\u0026lt;Connection\u0026gt; connections = new List\u0026lt;Connection\u0026gt;(); foreach (Connection c in bag) { connections.Add(c); } return connections.ToArray(); } } } 另请参阅 #  UnionFind 库\nGenerics 库\n"},{"id":171,"href":"/1-5-19/","title":"1.5.19","section":"帮助","content":"1.5.19 #  解答 #  最后绘出的图像：\n代码 #  给出绘图部分的代码，窗体部分见 GitHub。\nusing System; using System.Drawing; using System.Collections.Generic; using System.Windows.Forms; using UnionFind; namespace _1._5._19 { /* * 1.5.19 * * 动画。 * 编写一个 RandomGrid（请见练习 1.5.18）的用例， * 和我们开发用例一样使用 UnionFind 来检查触点的连通性并在处理时用 StdDraw 将它们绘出。 * */ static class Program { static RandomBag\u0026lt;Connection\u0026gt; bag; static Graphics graphics; static TextBox logBox; static PointF[] points; static Timer timer; static List\u0026lt;Connection\u0026gt; connections; static int count = 0; /// \u0026lt;summary\u0026gt;  /// 应用程序的主入口点。  /// \u0026lt;/summary\u0026gt; [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Application.Run(new Form1()); } /// \u0026lt;summary\u0026gt;  /// 绘制连接图像。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;矩阵边长。\u0026lt;/param\u0026gt;  public static void Draw(int n, TextBox log, Log WinBox) { logBox = log; // 生成路径。  log.AppendText(\u0026#34;\\r\\n开始生成连接……\u0026#34;); bag = RandomGrid.Generate(n); log.AppendText(\u0026#34;\\r\\n生成连接完成\u0026#34;); // 新建画布窗口。  log.AppendText(\u0026#34;\\r\\n启动画布……\u0026#34;); Form2 matrix = new Form2(); matrix.StartPosition = FormStartPosition.Manual; matrix.Location = new Point(WinBox.Left - matrix.ClientRectangle.Width, WinBox.Top); matrix.Show(); log.AppendText(\u0026#34;\\r\\n画布已启动，开始绘图……\u0026#34;); graphics = matrix.CreateGraphics(); // 获取绘图区域。  RectangleF rect = matrix.ClientRectangle; float unitX = rect.Width / (n + 1); float unitY = rect.Height / (n + 1); // 绘制点。  log.AppendText(\u0026#34;\\r\\n绘制点……\u0026#34;); points = new PointF[n * n]; for (int row = 0; row \u0026lt; n; ++row) { for (int col = 0; col \u0026lt; n; ++col) { points[row * n + col] = new PointF(unitX * (col + 1), unitY * (row + 1)); graphics.FillEllipse(Brushes.Black, unitX * (col + 1), unitY * (row + 1), 5, 5); } } log.AppendText(\u0026#34;\\r\\n绘制点完成\u0026#34;); // 绘制连接。  log.AppendText(\u0026#34;\\r\\n开始绘制连接……\u0026#34;); connections = new List\u0026lt;Connection\u0026gt;(); foreach (Connection c in bag) { connections.Add(c); } timer = new Timer { Interval = 500 }; timer.Tick += DrawOneLine; timer.Start(); } private static void DrawOneLine(object sender, EventArgs e) { Connection c = connections[count]; count++; graphics.DrawLine(Pens.Black, points[c.P], points[c.Q]); logBox.AppendText(\u0026#34;\\r\\n绘制\u0026#34; + \u0026#34;(\u0026#34; + c.P + \u0026#34;, \u0026#34; + c.Q + \u0026#34;)\u0026#34;); if (count == bag.Size()) { timer.Stop(); logBox.AppendText(\u0026#34;\\r\\n绘制结束\u0026#34;); count = 0; } } } } 另请参阅 #  UnionFind 库\n"},{"id":172,"href":"/1-5-20/","title":"1.5.20","section":"帮助","content":"1.5.20 #  解答 #  将 parent 数组和 size 数组用链表代替即可，很容易实现。\n代码 #  修改后的 WeightedQuickUnionUF.cs\nusing System; namespace _1._5._20 { /// \u0026lt;summary\u0026gt;  /// 使用加权 quick-union 算法的并查集。  /// \u0026lt;/summary\u0026gt;  public class WeightedQuickUnionUF { protected LinkedList\u0026lt;int\u0026gt; parent; // 记录各个结点的父级。  protected LinkedList\u0026lt;int\u0026gt; size; // 记录各个树的大小。  protected int count; // 分量数目。  /// \u0026lt;summary\u0026gt;  /// 建立使用加权 quick-union 的并查集。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;并查集的大小。\u0026lt;/param\u0026gt;  public WeightedQuickUnionUF() { this.parent = new LinkedList\u0026lt;int\u0026gt;(); this.size = new LinkedList\u0026lt;int\u0026gt;(); } /// \u0026lt;summary\u0026gt;  /// 获取 parent 数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;parent 数组。\u0026lt;/returns\u0026gt;  public LinkedList\u0026lt;int\u0026gt; GetParent() { return this.parent; } /// \u0026lt;summary\u0026gt;  /// 获取 size 数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;返回 size 数组。\u0026lt;/returns\u0026gt;  public LinkedList\u0026lt;int\u0026gt; GetSize() { return this.size; } /// \u0026lt;summary\u0026gt;  /// 在并查集中增加一个新的结点。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;新结点的下标。\u0026lt;/returns\u0026gt;  public int NewSite() { this.parent.Insert(this.parent.Size(), this.parent.Size()); this.size.Insert(1, this.size.Size()); this.count++; return this.parent.Size() - 1; } /// \u0026lt;summary\u0026gt;  /// 寻找一个结点所在的连通分量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要寻找的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;该结点所属的连通分量。\u0026lt;/returns\u0026gt;  public int Find(int p) { Validate(p); while (p != this.parent.Find(p)) { p = this.parent.Find(p); } return p; } /// \u0026lt;summary\u0026gt;  /// 将两个结点所属的连通分量合并。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要合并的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;q\u0026#34;\u0026gt;需要合并的另一个结点。\u0026lt;/param\u0026gt;  public void Union(int p, int q) { int rootP = Find(p); int rootQ = Find(q); if (rootP == rootQ) { return; } if (this.size.Find(rootP) \u0026lt; this.size.Find(rootQ)) { this.parent.Motify(rootP, rootQ); this.size.Motify(rootQ, this.size.Find(rootQ) + this.size.Find(rootP)); } else { this.parent.Motify(rootQ, rootP); this.size.Motify(rootP, this.size.Find(rootQ) + this.size.Find(rootP)); } this.count--; } /// \u0026lt;summary\u0026gt;  /// 检查输入的 p 是否符合条件。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;输入的 p 值。\u0026lt;/param\u0026gt;  protected void Validate(int p) { int n = this.parent.Size(); if (p \u0026lt; 0 || p \u0026gt;= n) { throw new ArgumentException(\u0026#34;index\u0026#34; + p + \u0026#34; is not between 0 and \u0026#34; + (n - 1)); } } } } "},{"id":173,"href":"/1-5-21/","title":"1.5.21","section":"帮助","content":"1.5.21 #  解答 #  给出我电脑上的结果：\n实验结果：10 1/2NlnN：11.5129254649702 实验结果：29 1/2NlnN：29.9573227355399 实验结果：132 1/2NlnN：73.7775890822787 实验结果：164 1/2NlnN：175.281065386955 实验结果：418 1/2NlnN：406.013905218706 实验结果：1143 1/2NlnN：922.931359327004 实验结果：2004 1/2NlnN：2067.66981643319 实验结果：4769 1/2NlnN：4578.95382842474 实验结果：10422 1/2NlnN：10045.1360479662 实验结果：21980 1/2NlnN：21864.7288781659 代码 #  using System; using UnionFind; namespace _1._5._21 { /* * 1.5.21 * * Erdös-Renyi 模型。 * 使用练习 1.5.17 的用例验证这个猜想： * 得到单个连通分量所需生成的整数对数量为 ~1/2NlnN。 * */ class Program { static void Main(string[] args) { for (int n = 10; n \u0026lt; 10000; n *= 2) { int total = 0; for (int i = 0; i \u0026lt; 100; ++i) { UF uf = new UF(n); total += ErdosRenyi.Count(uf); } Console.WriteLine(\u0026#34;实验结果：\u0026#34; + total / 100); Console.WriteLine(\u0026#34;1/2NlnN：\u0026#34; + Math.Log(n) * n * 0.5); Console.WriteLine(); } } } } 另请参阅 #  UnionFind 库\n"},{"id":174,"href":"/1-5-22/","title":"1.5.22","section":"帮助","content":"1.5.22 #  解答 #  平方级别算法在输入加倍后耗时应该增加四倍，线性则是两倍。\n下面给出我电脑上的结果，数据量较大时比较明显：\nN:16000 quick-find 平均次数：8452 用时：143 比值：4.46875 quick-union 平均次数：7325 用时：202 比值：3.25806451612903 weighted-quick-union 平均次数：6889 用时：1 N:32000 quick-find 平均次数：15747 用时：510 比值：3.56643356643357 quick-union 平均次数：15108 用时：801 比值：3.96534653465347 weighted-quick-union 平均次数：17575 用时：3 比值：3 N:64000 quick-find 平均次数：33116 用时：2069 比值：4.05686274509804 quick-union 平均次数：38608 用时：4635 比值：5.78651685393258 weighted-quick-union 平均次数：34850 用时：6 比值：2 代码 #  using System; using System.Diagnostics; using UnionFind; namespace _1._5._22 { /* * 1.5.22 * * Erdös-Renyi 的倍率实验。 * 开发一个性能测试用例， * 从命令行接受一个 int 值 T 并进行 T 次以下实验： * 使用练习 1.5.17 的用例生成随机连接， * 和我们的开发用例一样使用 UnionFind 来检查触点的连通性， * 不断循环知道所有触点都相互连通。 * 对于每个 N，打印出 N 值和平均所需的连接数以及前后两次运行时间的比值。 * 使用你的程序验证正文中的猜想： * quick-find 算法和 quick-union 算法的运行时间是平方级别的， * 加权 quick-union 算法则接近线性级别。 * */ class Program { static void Main(string[] args) { long lastTimeQuickFind = 0; long lastTimeQuickUnion = 0; long lastTimeWeightedQuickUnion = 0; long nowTime = 0; for (int n = 2000; n \u0026lt; 100000; n *= 2) { Console.WriteLine(\u0026#34;N:\u0026#34; + n); QuickFindUF quickFindUF = new QuickFindUF(n); QuickUnionUF quickUnionUF = new QuickUnionUF(n); WeightedQuickUnionUF weightedQuickUnionUF = new WeightedQuickUnionUF(n); // quick-find  Console.WriteLine(\u0026#34;quick-find\u0026#34;); nowTime = RunTest(quickFindUF); if (lastTimeQuickFind == 0) { Console.WriteLine(\u0026#34;用时：\u0026#34; + nowTime); lastTimeQuickFind = nowTime; } else { Console.WriteLine(\u0026#34;用时：\u0026#34; + nowTime + \u0026#34; 比值：\u0026#34; + (double)nowTime / lastTimeQuickFind); lastTimeQuickFind = nowTime; } Console.WriteLine(); // quick-union  Console.WriteLine(\u0026#34;quick-union\u0026#34;); nowTime = RunTest(quickUnionUF); if (lastTimeQuickUnion == 0) { Console.WriteLine(\u0026#34;用时：\u0026#34; + nowTime); lastTimeQuickUnion = nowTime; } else { Console.WriteLine(\u0026#34;用时：\u0026#34; + nowTime + \u0026#34; 比值：\u0026#34; + (double)nowTime / lastTimeQuickUnion); lastTimeQuickUnion = nowTime; } Console.WriteLine(); // weighted-quick-union  Console.WriteLine(\u0026#34;weighted-quick-union\u0026#34;); nowTime = RunTest(weightedQuickUnionUF); if (lastTimeWeightedQuickUnion == 0) { Console.WriteLine(\u0026#34;用时：\u0026#34; + nowTime); lastTimeWeightedQuickUnion = nowTime; } else { Console.WriteLine(\u0026#34;用时：\u0026#34; + nowTime + \u0026#34; 比值：\u0026#34; + (double)nowTime / lastTimeWeightedQuickUnion); lastTimeWeightedQuickUnion = nowTime; } Console.WriteLine(); Console.WriteLine(); } } /// \u0026lt;summary\u0026gt;  /// 进行若干次随机试验，输出平均 union 次数，返回平均耗时。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;uf\u0026#34;\u0026gt;用于测试的并查集。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;平均耗时。\u0026lt;/returns\u0026gt;  static long RunTest(UF uf) { Stopwatch timer = new Stopwatch(); int total = 0; int repeatTime = 10; timer.Start(); for (int i = 0; i \u0026lt; repeatTime; ++i) { total += ErdosRenyi.Count(uf); } timer.Stop(); Console.WriteLine(\u0026#34;平均次数：\u0026#34; + total / repeatTime); return timer.ElapsedMilliseconds / repeatTime; } } } 另请参阅 #  UnionFind 库\n"},{"id":175,"href":"/1-5-23/","title":"1.5.23","section":"帮助","content":"1.5.23 #  解答 #  先用速度最快的 WeightedQuickUnionUF 生成一系列连接，\n保存后用这些连接进行测试，生成连接的方法见 1.5.17 的解答。\n下面给出我电脑上的结果：\nN:2000 quick-find 耗时（毫秒）：4 quick-union 耗时（毫秒）：5 比值：0.8 N:4000 quick-find 耗时（毫秒）：19 quick-union 耗时（毫秒）：24 比值：0.791666666666667 N:8000 quick-find 耗时（毫秒）：57 quick-union 耗时（毫秒）：74 比值：0.77027027027027 N:16000 quick-find 耗时（毫秒）：204 quick-union 耗时（毫秒）：307 比值：0.664495114006515 N:32000 quick-find 耗时（毫秒）：1127 quick-union 耗时（毫秒）：1609 比值：0.700435052827843 代码 #  using System; using System.Diagnostics; using UnionFind; namespace _1._5._23 { /* * 1.5.23 * * 在 Erdös-Renyi 模型下比较 quick-find 算法和 quick-union 算法。 * 开发一个性能测试用例，从命令行接受一个 int 值 T 并进行 T 次以下实验： * 使用练习 1.5.17 的用例生成随机连接。 * 保存这些连接并和我们的开发用例一样分别用 quick-find 和 quick-union 算法检查触点的连通性， * 不断循环直到所有触点均相互连通。 * 对于每个 N，打印出 N 值和两种算法的运行时间比值。 * */ class Program { static void Main(string[] args) { int n = 1000; for (int t = 0; t \u0026lt; 5; ++t) { Connection[] input = ErdosRenyi.Generate(n); QuickFindUF quickFind = new QuickFindUF(n); QuickUnionUF quickUnion = new QuickUnionUF(n); Console.WriteLine(\u0026#34;N:\u0026#34; + n); long quickFindTime = RunTest(quickFind, input); long quickUnionTime = RunTest(quickUnion, input); Console.WriteLine(\u0026#34;quick-find 耗时（毫秒）：\u0026#34; + quickFindTime); Console.WriteLine(\u0026#34;quick-union 耗时（毫秒）：\u0026#34; + quickUnionTime); Console.WriteLine(\u0026#34;比值：\u0026#34; + (double)quickFindTime / quickUnionTime); Console.WriteLine(); n *= 2; } } /// \u0026lt;summary\u0026gt;  /// 进行若干次随机试验，输出平均 union 次数，返回平均耗时。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;uf\u0026#34;\u0026gt;用于测试的并查集。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;connections\u0026#34;\u0026gt;用于测试的输入。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;平均耗时。\u0026lt;/returns\u0026gt;  static long RunTest(UF uf, Connection[] connections) { Stopwatch timer = new Stopwatch(); int repeatTime = 5; timer.Start(); for (int i = 0; i \u0026lt; repeatTime; ++i) { ErdosRenyi.Count(uf, connections); } timer.Stop(); return timer.ElapsedMilliseconds / repeatTime; } } } 另请参阅 #  UnionFind 库\n"},{"id":176,"href":"/1-5-24/","title":"1.5.24","section":"帮助","content":"1.5.24 #  解答 #  根据上题的代码略作修改即可，路径压缩大概可以快 1/3。\nN:10000 加权 quick-find 耗时（毫秒）：9 带路径压缩的加权 quick-union 耗时（毫秒）：6 比值：1.5 N:20000 加权 quick-find 耗时（毫秒）：12 带路径压缩的加权 quick-union 耗时（毫秒）：8 比值：1.5 N:40000 加权 quick-find 耗时（毫秒）：18 带路径压缩的加权 quick-union 耗时（毫秒）：12 比值：1.5 N:80000 加权 quick-find 耗时（毫秒）：36 带路径压缩的加权 quick-union 耗时（毫秒）：30 比值：1.2 N:160000 加权 quick-find 耗时（毫秒）：67 带路径压缩的加权 quick-union 耗时（毫秒）：41 比值：1.63414634146341 代码 #  using System; using UnionFind; using System.Diagnostics; namespace _1._5._24 { /* * 1.5.24 * * 适用于 Erdös-Renyi 模型的快速算法。 * 在练习1.5.23 的测试中增加加权 quick-union 算法和使用路径压缩的加权 quick-union 算法。 * 你能分辨出这两种算法的区别吗？ * */ class Program { static void Main(string[] args) { int n = 5000; for (int t = 0; t \u0026lt; 5; ++t) { var input = ErdosRenyi.Generate(n); var weightedQuickUnionUF = new WeightedQuickUnionUF(n); var weightedQuickUnionPathCompressionUF = new WeightedQuickUnionPathCompressionUF(n); Console.WriteLine(\u0026#34;N:\u0026#34; + n); long weightedQuickUnionTime = RunTest(weightedQuickUnionUF, input); long weightedQuickUnionPathCompressionTime = RunTest(weightedQuickUnionPathCompressionUF, input); Console.WriteLine(\u0026#34;加权 quick-find 耗时（毫秒）：\u0026#34; + weightedQuickUnionTime); Console.WriteLine(\u0026#34;带路径压缩的加权 quick-union 耗时（毫秒）：\u0026#34; + weightedQuickUnionPathCompressionTime); Console.WriteLine(\u0026#34;比值：\u0026#34; + (double)weightedQuickUnionTime / weightedQuickUnionPathCompressionTime); Console.WriteLine(); n *= 2; } } /// \u0026lt;summary\u0026gt;  /// 进行若干次随机试验，输出平均 union 次数，返回平均耗时。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;uf\u0026#34;\u0026gt;用于测试的并查集。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;connections\u0026#34;\u0026gt;用于测试的输入。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;平均耗时。\u0026lt;/returns\u0026gt;  static long RunTest(UF uf, Connection[] connections) { Stopwatch timer = new Stopwatch(); int repeatTime = 5; timer.Start(); for (int i = 0; i \u0026lt; repeatTime; ++i) { ErdosRenyi.Count(uf, connections); } timer.Stop(); return timer.ElapsedMilliseconds / repeatTime; } } } 另请参阅 #  UnionFind 库\n"},{"id":177,"href":"/1-5-25/","title":"1.5.25","section":"帮助","content":"1.5.25 #  解答 #  略微修改 1.5.22 的代码即可。\n我电脑上的结果：\nQuick-Find N:1600 平均用时（毫秒）：4 N:6400 平均用时（毫秒）：67 比值：16.75 N:25600 平均用时（毫秒）：1268 比值：18.9253731343284 N:102400 平均用时（毫秒）：20554 比值：16.2097791798107 Quick-Union N:1600 平均用时（毫秒）：5 比值：0.000243261652233142 N:6400 平均用时（毫秒）：66 比值：13.2 N:25600 平均用时（毫秒）：1067 比值：16.1666666666667 N:102400 平均用时（毫秒）：18637 比值：17.4667291471415 Weighted Quick-Union N:1600 平均用时（毫秒）：0 比值：0 N:6400 平均用时（毫秒）：2 N:25600 平均用时（毫秒）：12 比值：6 N:102400 平均用时（毫秒）：64 比值：5.33333333333333 代码 #  using System; using System.Diagnostics; using UnionFind; namespace _1._5._25 { /* * 1.5.25 * * 随机网格的倍率测试。 * 开发一个性能测试用例， * 从命令行接受一个 int 值 T 并进行 T 次以下实验： * 使用练习 1.5.18 的用例生成一个 N×N 的随机网格， * 所有连接的方向随机且排列随机。 * 和我们的开发用例一样使用 UnionFind 来检查触点的连通性， * 不断循环直到所有触点均相互连通。 * 对于每个 N，打印出 N 值和平均所需的连接数以及前后两次运行时间的比值。 * 使用你的程序验证正文中的猜想： * quick-find 和 quick-union 算法的运行时间是平方级别的， * 加权 quick-union 算法则接近线性级别。 * * 注意：随着 N 值加倍，网格中触点的数量会乘以 4， * 因此平方级别的算法运行时间会变为原来的 16 倍， * 线性级别的算法的运行时间则变为原来的 4 倍 * */ class Program { static void Main(string[] args) { int n = 40; int t = 4; // quick-find  Console.WriteLine(\u0026#34;Quick-Find\u0026#34;); long last = 0; long now = 0; for (int i = 0; i \u0026lt; t; ++i, n *= 2) { Console.WriteLine(\u0026#34;N:\u0026#34; + n * n); var connections = RandomGrid.GetConnections(n); QuickFindUF quickFind = new QuickFindUF(n * n); now = RunTest(quickFind, connections); if (last == 0) { Console.WriteLine(\u0026#34;平均用时（毫秒）：\u0026#34; + now); last = now; } else { Console.WriteLine(\u0026#34;平均用时（毫秒）：\u0026#34; + now + \u0026#34;\\t比值：\u0026#34; + (double)now / last); last = now; } } // quick-union  Console.WriteLine(\u0026#34;Quick-Union\u0026#34;); n = 40; for (int i = 0; i \u0026lt; t; ++i, n *= 2) { Console.WriteLine(\u0026#34;N:\u0026#34; + n * n); var connections = RandomGrid.GetConnections(n); QuickUnionUF quickFind = new QuickUnionUF(n * n); now = RunTest(quickFind, connections); if (last == 0) { Console.WriteLine(\u0026#34;平均用时（毫秒）：\u0026#34; + now); last = now; } else { Console.WriteLine(\u0026#34;平均用时（毫秒）：\u0026#34; + now + \u0026#34;\\t比值：\u0026#34; + (double)now / last); last = now; } } // 加权 quick-union  Console.WriteLine(\u0026#34;Weighted Quick-Union\u0026#34;); n = 40; for (int i = 0; i \u0026lt; t; ++i, n *= 2) { Console.WriteLine(\u0026#34;N:\u0026#34; + n * n); var connections = RandomGrid.GetConnections(n); WeightedQuickUnionUF quickFind = new WeightedQuickUnionUF(n * n); now = RunTest(quickFind, connections); if (last == 0) { Console.WriteLine(\u0026#34;平均用时（毫秒）：\u0026#34; + now); last = now; } else { Console.WriteLine(\u0026#34;平均用时（毫秒）：\u0026#34; + now + \u0026#34;\\t比值：\u0026#34; + (double)now / last); last = now; } } } /// \u0026lt;summary\u0026gt;  /// 进行若干次随机试验，输出平均 union 次数，返回平均耗时。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;uf\u0026#34;\u0026gt;用于测试的并查集。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;connections\u0026#34;\u0026gt;用于测试的输入。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;平均耗时。\u0026lt;/returns\u0026gt;  static long RunTest(UF uf, Connection[] connections) { Stopwatch timer = new Stopwatch(); long repeatTime = 3; timer.Start(); for (int i = 0; i \u0026lt; repeatTime; ++i) { ErdosRenyi.Count(uf, connections); } timer.Stop(); return timer.ElapsedMilliseconds / repeatTime; } } } 另请参阅 #  UnionFind 库\n"},{"id":178,"href":"/1-5-26/","title":"1.5.26","section":"帮助","content":"1.5.26 #  解答 #  和 1.5.16 的程序类似，将测试的内容改为 Erdos-Renyi 即可。\n样例输出：\n代码 #  using System; using System.Linq; using System.Windows.Forms; using System.Drawing; using UnionFind; namespace _1._5._26 { /* * 1.5.26 * * Erdös-Renyi 模型的均摊成本图像。 * 开发一个用例， * 从命令行接受一个 int 值 N，在 0 到 N-1 之间产生随机整数对， * 调用 connected() 判断它们是否相连， * 如果不是则用 union() 方法（和我们的开发用例一样）。 * 不断循环直到所有触点互通。 * 按照正文的样式将所有操作的均摊成本绘制成图像。 * */ static class Program { /// \u0026lt;summary\u0026gt;  /// 应用程序的主入口点。  /// \u0026lt;/summary\u0026gt; [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Compute(); Application.Run(new Form1()); } static void Compute() { int size = 200; QuickFindUF quickFind = new QuickFindUF(size); QuickUnionUF quickUnion = new QuickUnionUF(size); WeightedQuickUnionUF weightedQuickUnion = new WeightedQuickUnionUF(size); Connection[] connections = ErdosRenyi.Generate(size); int[] quickFindResult = new int[size]; int[] quickUnionResult = new int[size]; int[] weightedQuickUnionResult = new int[size]; int p, q; for (int i = 0; i \u0026lt; size; ++i) { p = connections[i].P; q = connections[i].Q; quickFind.Union(p, q); quickUnion.Union(p, q); weightedQuickUnion.Union(p, q); quickFindResult[i] = quickFind.ArrayVisitCount; quickUnionResult[i] = quickUnion.ArrayVisitCount; weightedQuickUnionResult[i] = weightedQuickUnion.ArrayParentVisitCount + weightedQuickUnion.ArraySizeVisitCount; quickFind.ResetArrayCount(); quickUnion.ResetArrayCount(); weightedQuickUnion.ResetArrayCount(); } Draw(quickFindResult, \u0026#34;Quick-Find\u0026#34;); Draw(quickUnionResult, \u0026#34;Quick-Union\u0026#34;); Draw(weightedQuickUnionResult, \u0026#34;Weighted Quick-Union\u0026#34;); } static void Draw(int[] cost, string title) { // 构建 total 数组。  int[] total = new int[cost.Length]; total[0] = cost[0]; for (int i = 1; i \u0026lt; cost.Length; ++i) { total[i] = total[i - 1] + cost[i]; } // 获得最大值。  int costMax = cost.Max(); // 新建绘图窗口。  Form2 plot = new Form2(); plot.Text = title; plot.Show(); Graphics graphics = plot.CreateGraphics(); // 获得绘图区矩形。  RectangleF rect = plot.ClientRectangle; float unitX = rect.Width / 10; float unitY = rect.Width / 10; // 添加 10% 边距作为文字区域。  RectangleF center = new RectangleF (rect.X + unitX, rect.Y + unitY, rect.Width - 2 * unitX, rect.Height - 2 * unitY); // 绘制坐标系。  graphics.DrawLine(Pens.Black, center.Left, center.Top, center.Left, center.Bottom); graphics.DrawLine(Pens.Black, center.Left, center.Bottom, center.Right, center.Bottom); graphics.DrawString(costMax.ToString(), plot.Font, Brushes.Black, rect.Location); graphics.DrawString(cost.Length.ToString(), plot.Font, Brushes.Black, center.Right, center.Bottom); graphics.DrawString(\u0026#34;0\u0026#34;, plot.Font, Brushes.Black, rect.Left, center.Bottom); // 初始化点。  PointF[] grayPoints = new PointF[cost.Length]; PointF[] redPoints = new PointF[cost.Length]; unitX = center.Width / cost.Length; unitY = center.Width / costMax; for (int i = 0; i \u0026lt; cost.Length; ++i) { grayPoints[i] = new PointF(center.Left + unitX * (i + 1), center.Bottom - (cost[i] * unitY)); redPoints[i] = new PointF(center.Left + unitX * (i + 1), center.Bottom - ((total[i] / (i + 1)) * unitY)); } // 绘制点。  for (int i = 0; i \u0026lt; cost.Length; ++i) { graphics.FillEllipse(Brushes.Gray, new RectangleF(grayPoints[i], new SizeF(5, 5))); graphics.FillEllipse(Brushes.Red, new RectangleF(redPoints[i], new SizeF(5, 5))); } graphics.Dispose(); } } } 另请参阅 #  UnionFind 库\n"},{"id":179,"href":"/2-1-1/","title":"2.1.1","section":"帮助","content":"2.1.1 #  解答 #  "},{"id":180,"href":"/2-1-2/","title":"2.1.2","section":"帮助","content":"2.1.2 #  解答 #  最多会被交换 n 次，只要将一个有序数列循环右移一位就可以构造这样的情况。\n例如：\n平均每个元素被交换了 N/N=1 次。（总共 N 个元素，总共发生了 N 次交换）。\n"},{"id":181,"href":"/2-1-3/","title":"2.1.3","section":"帮助","content":"2.1.3 #  解答 #  你需要一个逆序的数组。\n例如：\n9 8 7 6 5 4 3 2 1\ni=0 条件满足 8 次，1 和 9 交换，1 8 7 6 5 4 3 2 9。\ni=1 条件满足 6 次，2 和 8 交换，1 2 7 6 5 4 3 8 9。\ni=2 条件满足 4 次，3 和 7 交换，1 2 3 6 5 4 7 8 9。\ni=3 条件满足 2 次，4 和 6 交换。1 2 3 4 5 6 7 8 9。\n一共满足了 8+6+4+2=20 次\n"},{"id":182,"href":"/2-1-4/","title":"2.1.4","section":"帮助","content":"2.1.4 #  解答 #  "},{"id":183,"href":"/2-1-5/","title":"2.1.5","section":"帮助","content":"2.1.5 #  解答 #  条件是：\nj \u0026gt; 0 \u0026amp;\u0026amp; less(a[j], a[j - 1]) 第一个条件属于循环计数用的条件，与数组元素无关；\n第二个条件当 a[j] 和 a[j - 1] 是一组逆序对时满足，因此这个条件总是为假 = 数组没有逆序对 = 数组有序。\n因此只要输入已经排好序的数组即可。\n逆序对：指序列中顺序相反的两个数，例如 1 2 3 4 5 7 6 8 9 中的 7 6。\n另请参阅 #  逆序对-维基百科\n"},{"id":184,"href":"/2-1-6/","title":"2.1.6","section":"帮助","content":"2.1.6 #  解答 #  插入排序更快。\n选择排序无论如何都需要 $n + (n-1) + (n-2) + … + 1 = \\frac{n^2}{2}$ 次比较。\n插入排序在这种情况下只需要 n 次比较。（所有主键相同 = 数组已排序）\n"},{"id":185,"href":"/2-1-7/","title":"2.1.7","section":"帮助","content":"2.1.7 #  解答 #  假设比较的开销小于等于交换的开销，此时选择排序更快，具体比较见下表。\n   排序方法 比较次数 交换次数     插入排序 ~N^2/2 ~N^2/2   选择排序 ~N^2/2 N    "},{"id":186,"href":"/2-1-8/","title":"2.1.8","section":"帮助","content":"2.1.8 #  解答 #  平方级别。\n如果数组中元素各不相同，那么这个结论很容易证明（一般的插入排序）。\n接下来我们证明有重复元素的情况下，这个结论仍然成立：\n首先对于插入排序过程中的某一时刻，我们有下图这样的一般情况：\n$$\n\\underbrace{11\u0026hellip;1}{a} \\ \\underbrace{22\u0026hellip;2}{b} \\ \\underbrace{33\u0026hellip;3}{c} \\ \\underbrace{13121123}{unsorted}\n$$\n其中，1，2，3 分别代表三种不同的取值及其先后顺序。\n假设这是第 i 次插入前，如果第 i 次插入的是 1，我们需要交换 b+c 次，插入 2 则需要交换 c 次，插入 3 则不需要交换。\n根据题意，这是一个随机数组，我们假设其为均匀分布，那么三种取值的出现几率相等。\n第 i 次插入所需要的平均交换次数即为：\n$$\n\\frac{b+c+c}{3}=\\frac{b+2c}{3}\n$$\n第 i 次插入后，b + 2c 视插入的元素不同会出现不同的变化：\n如果插入的是 1，那么 b+2c 的值不会变化。\n如果插入的是 2，那么 b+2c 的值增加 1。\n如果插入的是 3，那么 b+2c 的值增加 2。\n同样由于三种取值的概率相等，我们得出第 i + 1 次插入平均需要交换的次数为：\n$$\n\\frac{b+2c+\\frac{0+1+2}{3}}{3}=\\frac{b+2c+1}{3}\n$$\n也就是说，平均每次插入都会使下一次插入的交换次数增加 1/3。\n令 i=0，此时交换次数为 0，i+1 的交换次数即为 1/3，i+2 的交换次数即为 2/3，以此类推。\n我们可以得出总交换次数：\n$$\n\\frac{1+2+3+4+\u0026hellip;+N}{3}=\\frac{N(N-1)}{6}\n$$\n由此证明，在元素取值为 3 种且出现概率相等时，插入排序的交换开销时平方级别的。\n比较开销和交换开销类似，一般情况下比较次数=交换次数+1，除非插入的数是已知最小的数（移动到最左侧），这个时候比较次数和交换次数相等。\n因此比较次数=交换次数+N-e，e 是一个不大于 N 的数，代表插入的数是已知最小的数这种情况发生的次数。\n根据上式可以得出结论：在元素取值为 3 种且出现概率相等时，插入排序的比较开销也是平方级别的。\n综合两个结论即可证明插入排序的开销在题目描述的情况下是平方级别的。\n证明完毕。\n"},{"id":187,"href":"/2-1-9/","title":"2.1.9","section":"帮助","content":"2.1.9 #  解答 #  "},{"id":188,"href":"/2-1-10/","title":"2.1.10","section":"帮助","content":"2.1.10 #  解答 #  对于部分有序的数组，插入排序比选择排序快。\n这个结论可以在中文版 P158， 英文版 P252 找到。\n"},{"id":189,"href":"/2-1-11/","title":"2.1.11","section":"帮助","content":"2.1.11 #  解答 #  希尔排序的官方实现：https://algs4.cs.princeton.edu/21elementary/Shell.java.html\n只要稍作修改即可，详情见代码。\n代码 #  /// \u0026lt;summary\u0026gt; /// 利用希尔排序将数组按升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { int n = a.Length; int[] h = new int[2]; // 预先准备好的 h 值数组  int hTemp = 1; int sequenceSize = 0; for (sequenceSize = 0; hTemp \u0026lt; n; sequenceSize++) { if (sequenceSize \u0026gt;= h.Length) // 如果数组不够大则双倍扩容  { int[] expand = new int[h.Length * 2]; for (int j = 0; j \u0026lt; h.Length; j++) { expand[j] = h[j]; } h = expand; } h[sequenceSize] = hTemp; hTemp = hTemp * 3 + 1; } for (int t = sequenceSize - 1; t \u0026gt;= 0; t--) { for (int i = h[t]; i \u0026lt; n; i++) { for (int j = i; j \u0026gt;= h[t] \u0026amp;\u0026amp; Less(a[j], a[j - h[t]]); j -= h[t]) { Exch(a, j, j - h[t]); } } Debug.Assert(IsHSorted(a, h[t])); } Debug.Assert(IsSorted(a)); } 另请参阅 #  Sort 库\n"},{"id":190,"href":"/2-1-12/","title":"2.1.12","section":"帮助","content":"2.1.12 #  解答 #  结果截图如下，同一个 h 值对应的比值在数组大小不同时保持为一个小常数：\n代码 #  class Program { // 查看最后结果  // 可以发现相同的 h 在数组大小不同时所产生的比值十分接近。  static void Main(string[] args) { Random random = new Random(); ShellSort sort = new ShellSort(); int size = 100; for (int i = 0; i \u0026lt; 5; i++) { double[] a = new double[size]; for (int j = 0; j \u0026lt; size; j++) { a[j] = random.NextDouble() * 100; } Console.WriteLine(\u0026#34;ArraySize:\u0026#34; + size); sort.Sort(a); size *= 10; } } } 另请参阅 #  Sort 库\n"},{"id":191,"href":"/2-1-13/","title":"2.1.13","section":"帮助","content":"2.1.13 #  解答 #  可以用冒泡排序做，具体方法如下：\n翻一二两张，是逆序对就交换，否则什么也不做\n翻二三两张，是逆序对就交换，否则什么也不做\n一直到最后，可以保证最右侧的是最大花色的牌\n然后不断重复上述过程，就可以完全排序\n"},{"id":192,"href":"/2-1-14/","title":"2.1.14","section":"帮助","content":"2.1.14 #  解答 #  用一种类似于冒泡的方法做，具体步骤为：\n重复以下步骤，直到全部完成一遍之后没有发生交换 重复以下步骤 n-1 次 如果顶端两张牌逆序，那么交换它们。 将第一张牌放到牌堆底部。 具体步骤图：\n我们将牌排成一个环，用一支笔隔开，这里我们标记笔的左侧是牌堆顶部，右侧是牌堆底部。\n那么我们能做的三个操作在这里即为：\n查看最上面两张牌 = 从笔的位置开始，逆时针查看两张牌。\n交换最上面两张牌 = 从笔的位置开始，逆时针选择两张牌并交换。\n将最上面的一张牌放到最下面 = 将笔的位置逆时针移动一位。\n下面我们开始执行开始说过的操作，目标顺序是自顶向下从小到大排列。\n初始情况如图所示：\n梅花7 和 红桃4 不是逆序对，直接将笔逆时针移动一位。\n红桃4 和 黑桃6 不是逆序对，我们将笔逆时针移动一位。\n再看 黑桃6 和 方片A，是逆序对，我们交换并将笔逆时针移动一位。\n再看 黑桃6 和 红桃J，是逆序对，我们交换并将笔逆时针移动一位。\n现在我们已经操作了 4 次，内部循环结束，我们将笔放回初始位置。\n这样一次循环之后，我们就把最大的牌放在了最下面，依次类推即可完全排序。\n另请参阅 #  Sorting a deque using limited operations?-Stock Overflow\n"},{"id":193,"href":"/2-1-15/","title":"2.1.15","section":"帮助","content":"2.1.15 #  解答 #  选择排序\n交换（也就是 Exch() 方法）需要一个额外空间，这里的条件满足。\n现在我们应该使交换次数最少，选择排序只需要 N 次交换，比插入排序平均 N^2/4 少（N \u0026gt; 2）。\n"},{"id":194,"href":"/2-1-16/","title":"2.1.16","section":"帮助","content":"2.1.16 #  解答 #  如果移动数据时新建了对象，那么虽然值没有改变，但是数组中的对象被修改了。\n代码 #  插入排序中的 Exch() 换成了如下方式：\nstring temp = new string(s[i].ToCharArray()); s[i] = s[min]; s[min] = temp; 全部程序代码如下：\nusing System; namespace _2._1._16 { /* * 2.1.16 * * 验证。 * 编写一个 check() 方法， * 调用 sort() 对任意数组排序。 * 如果排序成功而且数组中的所有对象均没有被修改则返回 true， * 否则返回 false。 * 不要假设 sort() 只能通过 exch() 来移动数据， * 可以信任并使用 Array.sort()。 * */ public class Program { static void Main(string[] args) { string[] test = new string[5] { \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;e\u0026#34; }; Console.WriteLine(CheckArraySort(test)); Console.WriteLine(CheckSelectionSort(test)); } /// \u0026lt;summary\u0026gt;  /// 测试 Array.Sort() 方法。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;用于测试的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;如果数组对象没有改变，返回 true，否则返回 false。\u0026lt;/returns\u0026gt;  static bool CheckArraySort(string[] a) { string[] backup = new string[a.Length]; a.CopyTo(backup, 0); Array.Sort(a); foreach (string n in a) { bool isFind = false; for (int i = 0; i \u0026lt; a.Length; i++) { if (ReferenceEquals(n, backup[i])) { isFind = true; break; } } if (!isFind) { return false; } } return true; } /// \u0026lt;summary\u0026gt;  /// 测试选择排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;用于测试的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;如果数组对象没有改变，返回 true，否则返回 false。\u0026lt;/returns\u0026gt;  static bool CheckSelectionSort(string[] a) { string[] backup = new string[a.Length]; a.CopyTo(backup, 0); SelectionSort(a); foreach (string n in a) { bool isFind = false; for (int i = 0; i \u0026lt; a.Length; i++) { if (ReferenceEquals(n, backup[i])) { isFind = true; break; } } if (!isFind) { return false; } } return true; } /// \u0026lt;summary\u0026gt;  /// 选择排序，其中的交换部分使用新建对象并复制的方法。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;s\u0026#34;\u0026gt;用于排序的数组。\u0026lt;/param\u0026gt;  public static void SelectionSort(string[] s) { for (int i = 0; i \u0026lt; s.Length; i++) { int min = i; for (int j = i + 1; j \u0026lt; s.Length; j++) { if (s[j].CompareTo(s[min]) \u0026lt; 0) { min = j; } } string temp = new string(s[i].ToCharArray()); s[i] = s[min]; s[min] = temp; } } } } "},{"id":195,"href":"/2-1-17/","title":"2.1.17","section":"帮助","content":"2.1.17 #  解答 #  选择排序：\n插入排序：\n代码 #  使用一个 timer 按一定时间重绘数组，排序算法里面一次循环后等待一段时间再进行下一次循环。（这并不是一个很好的方法，但对于演示来说足够了）\n这里排序算法是另开线程运行的，防止 Sleep 的时候让程序无响应。\n选择排序：\nusing System; using System.Drawing; using System.Windows.Forms; using System.Threading; namespace _2._1._17 { public partial class Form2 : Form { double[] randomDoubles; public Form2(int N) { InitializeComponent(); this.randomDoubles = new double[N]; Random random = new Random(); for (int i = 0; i \u0026lt; N; i++) { this.randomDoubles[i] = random.NextDouble() * 0.8 + 0.2; } drawPanel(); this.timer1.Interval = 60; this.timer1.Start(); Thread thread = new Thread(new ThreadStart(this.SelectionSort)); thread.IsBackground = true; thread.Start(); } /// \u0026lt;summary\u0026gt;  /// 选择排序。  /// \u0026lt;/summary\u0026gt;  private void SelectionSort() { for (int i = 0; i \u0026lt; this.randomDoubles.Length; i++) { int min = i; for (int j = i; j \u0026lt; this.randomDoubles.Length; j++) { if (this.randomDoubles[min] \u0026gt; this.randomDoubles[j]) { min = j; } } double temp = this.randomDoubles[i]; this.randomDoubles[i] = this.randomDoubles[min]; this.randomDoubles[min] = temp; Thread.Sleep(1000); } } /// \u0026lt;summary\u0026gt;  /// 在屏幕上用柱形图绘制数组。  /// \u0026lt;/summary\u0026gt;  private void drawPanel() { Graphics graphics = this.CreateGraphics(); graphics.Clear(this.BackColor); graphics.TranslateTransform(0, this.Height); graphics.ScaleTransform(1, -1); Rectangle clientRect = this.ClientRectangle; Rectangle drawRect = new Rectangle(clientRect.X + 10, clientRect.Y + 10, clientRect.Width - 10, clientRect.Height - 10); PointF[] barX = new PointF[this.randomDoubles.Length]; float unitX = (float)drawRect.Width / this.randomDoubles.Length; unitX -= 4; barX[0] = new PointF(4, drawRect.Top); for (int i = 1; i \u0026lt; this.randomDoubles.Length; i++) { barX[i] = new PointF(2 + unitX + barX[i - 1].X, drawRect.Top); } RectangleF[] bars = new RectangleF[this.randomDoubles.Length]; for (int i = 0; i \u0026lt; this.randomDoubles.Length; i++) { SizeF size = new SizeF(unitX, (float)this.randomDoubles[i] * drawRect.Height); bars[i] = new RectangleF(barX[i], size); } graphics.FillRectangles(Brushes.Black, bars); graphics.Dispose(); } private void timer1_Tick(object sender, EventArgs e) { drawPanel(); } } } 插入排序：\nusing System; using System.Drawing; using System.Windows.Forms; using System.Threading; namespace _2._1._17 { public partial class Form3 : Form { double[] randomDoubles; public Form3(int N) { InitializeComponent(); this.randomDoubles = new double[N]; Random random = new Random(); for (int i = 0; i \u0026lt; N; i++) { this.randomDoubles[i] = random.NextDouble() * 0.8 + 0.2; } drawPanel(); this.timer1.Interval = 60; this.timer1.Start(); Thread thread = new Thread(new ThreadStart(this.InsertionSort)); thread.IsBackground = true; thread.Start(); } /// \u0026lt;summary\u0026gt;  /// 插入排序。  /// \u0026lt;/summary\u0026gt;  private void InsertionSort() { for (int i = 0; i \u0026lt; this.randomDoubles.Length; i++) { for (int j = i; j \u0026gt; 0 \u0026amp;\u0026amp; this.randomDoubles[j] \u0026lt; this.randomDoubles[j - 1]; j--) { double temp = this.randomDoubles[j]; this.randomDoubles[j] = this.randomDoubles[j - 1]; this.randomDoubles[j - 1] = temp; Thread.Sleep(500); } } } /// \u0026lt;summary\u0026gt;  /// 在屏幕上用柱形图绘制数组。  /// \u0026lt;/summary\u0026gt;  private void drawPanel() { Graphics graphics = this.CreateGraphics(); graphics.Clear(this.BackColor); graphics.TranslateTransform(0, this.Height); graphics.ScaleTransform(1, -1); Rectangle clientRect = this.ClientRectangle; Rectangle drawRect = new Rectangle(clientRect.X + 10, clientRect.Y + 10, clientRect.Width - 10, clientRect.Height - 10); PointF[] barX = new PointF[this.randomDoubles.Length]; float unitX = (float)drawRect.Width / this.randomDoubles.Length; unitX -= 4; barX[0] = new PointF(4, drawRect.Top); for (int i = 1; i \u0026lt; this.randomDoubles.Length; i++) { barX[i] = new PointF(2 + unitX + barX[i - 1].X, drawRect.Top); } RectangleF[] bars = new RectangleF[this.randomDoubles.Length]; for (int i = 0; i \u0026lt; this.randomDoubles.Length; i++) { SizeF size = new SizeF(unitX, (float)this.randomDoubles[i] * drawRect.Height); bars[i] = new RectangleF(barX[i], size); } graphics.FillRectangles(Brushes.Black, bars); graphics.Dispose(); } private void timer1_Tick(object sender, EventArgs e) { drawPanel(); } } } "},{"id":196,"href":"/2-1-18/","title":"2.1.18","section":"帮助","content":"2.1.18 #  解答 #  选择排序\n插入排序\n代码 #  与上题类似，但要特别标出移动的元素。\n选择排序：\nusing System; using System.Drawing; using System.Windows.Forms; using System.Threading; namespace _2._1._18 { public partial class Form2 : Form { double[] randomDoubles; int sortI; int sortJ; int sortMin; public Form2(int N) { InitializeComponent(); this.randomDoubles = new double[N]; Random random = new Random(); for (int i = 0; i \u0026lt; N; i++) { this.randomDoubles[i] = random.NextDouble() * 0.8 + 0.2; } } /// \u0026lt;summary\u0026gt;  /// 选择排序。  /// \u0026lt;/summary\u0026gt;  private void SelectionSort() { for (this.sortI = 0; this.sortI \u0026lt; this.randomDoubles.Length; this.sortI++) { this.sortMin = this.sortI; for (this.sortJ = this.sortI; this.sortJ \u0026lt; this.randomDoubles.Length; this.sortJ++) { if (this.randomDoubles[this.sortMin] \u0026gt; this.randomDoubles[this.sortJ]) { this.sortMin = this.sortJ; } } drawPanel(); double temp = this.randomDoubles[this.sortI]; this.randomDoubles[this.sortI] = this.randomDoubles[this.sortMin]; this.randomDoubles[this.sortMin] = temp; Thread.Sleep(1000); } } /// \u0026lt;summary\u0026gt;  /// 绘制柱形图。  /// \u0026lt;/summary\u0026gt;  private void drawPanel() { Graphics graphics = this.CreateGraphics(); graphics.Clear(this.BackColor); graphics.TranslateTransform(0, this.Height); graphics.ScaleTransform(1, -1); Rectangle clientRect = this.ClientRectangle; Rectangle drawRect = new Rectangle(clientRect.X + 10, clientRect.Y + 10, clientRect.Width - 10, clientRect.Height - 10); PointF[] barX = new PointF[this.randomDoubles.Length]; float unitX = (float)drawRect.Width / this.randomDoubles.Length; unitX -= 4; barX[0] = new PointF(4, drawRect.Top); for (int i = 1; i \u0026lt; this.randomDoubles.Length; i++) { barX[i] = new PointF(2 + unitX + barX[i - 1].X, drawRect.Top); } RectangleF[] bars = new RectangleF[this.randomDoubles.Length]; for (int i = 0; i \u0026lt; this.randomDoubles.Length; i++) { SizeF size = new SizeF(unitX, (float)this.randomDoubles[i] * drawRect.Height); bars[i] = new RectangleF(barX[i], size); } for (int i = 0; i \u0026lt; bars.Length; i++) { if (i == this.sortMin) { graphics.FillRectangle(Brushes.Red, bars[i]); } else if (i \u0026lt; this.sortI) { graphics.FillRectangle(Brushes.Gray, bars[i]); } else { graphics.FillRectangle(Brushes.Black, bars[i]); } } graphics.Dispose(); } private void Form2_Shown(object sender, EventArgs e) { SelectionSort(); } } } 插入排序\nusing System; using System.Drawing; using System.Windows.Forms; using System.Threading; namespace _2._1._18 { public partial class Form3 : Form { double[] randomDoubles; int sortI; int sortJ; int n = 0; public Form3(int N) { InitializeComponent(); this.randomDoubles = new double[N]; Random random = new Random(); for (int i = 0; i \u0026lt; N; i++) { this.randomDoubles[i] = random.NextDouble() * 0.8 + 0.2; } } /// \u0026lt;summary\u0026gt;  /// 插入排序。  /// \u0026lt;/summary\u0026gt;  private void InsertionSort() { for (this.sortI = 0; this.sortI \u0026lt; this.randomDoubles.Length; this.sortI++) { for (this.sortJ = this.sortI; this.sortJ \u0026gt; 0 \u0026amp;\u0026amp; this.randomDoubles[this.sortJ] \u0026lt; this.randomDoubles[this.sortJ - 1]; this.sortJ--) { double temp = this.randomDoubles[this.sortJ]; this.randomDoubles[this.sortJ] = this.randomDoubles[this.sortJ - 1]; this.randomDoubles[this.sortJ - 1] = temp; } drawPanel(); Thread.Sleep(1000); } } /// \u0026lt;summary\u0026gt;  /// 绘制柱形图。  /// \u0026lt;/summary\u0026gt;  private void drawPanel() { Graphics graphics = this.CreateGraphics(); graphics.Clear(this.BackColor); graphics.TranslateTransform(0, this.Height); graphics.ScaleTransform(1, -1); Rectangle clientRect = this.ClientRectangle; Rectangle drawRect = new Rectangle(clientRect.X + 10, clientRect.Y + 10, clientRect.Width - 10, clientRect.Height - 10); PointF[] barX = new PointF[this.randomDoubles.Length]; float unitX = (float)drawRect.Width / this.randomDoubles.Length; unitX -= 4; barX[0] = new PointF(4, drawRect.Top); for (int i = 1; i \u0026lt; this.randomDoubles.Length; i++) { barX[i] = new PointF(2 + unitX + barX[i - 1].X, drawRect.Top); } RectangleF[] bars = new RectangleF[this.randomDoubles.Length]; for (int i = 0; i \u0026lt; this.randomDoubles.Length; i++) { SizeF size = new SizeF(unitX, (float)this.randomDoubles[i] * drawRect.Height); bars[i] = new RectangleF(barX[i], size); } for (int i = 0; i \u0026lt; bars.Length; i++) { if (i == this.sortJ) { graphics.FillRectangle(Brushes.Red, bars[i]); } else if (i \u0026lt;= this.sortI \u0026amp;\u0026amp; i \u0026gt; this.sortJ) { graphics.FillRectangle(Brushes.Black, bars[i]); } else { graphics.FillRectangle(Brushes.Gray, bars[i]); } } graphics.Dispose(); } private void Form3_Shown(object sender, EventArgs e) { InsertionSort(); } } } "},{"id":197,"href":"/2-1-19/","title":"2.1.19","section":"帮助","content":"2.1.19 #  解答 #  不得不说这道题意外的难。\n放上论文链接：Shellsort and Sorting Networks (Outstanding Dissertations in the Computer Sciences)\n这篇论文的第二章给出了一种构造最坏序列的方法，当然理想最坏（n^(3/2)）是达不到的了。\n最后结果是 793 次。\n@杨晗 通过随机输入获得了一个理论最坏的输入序列，见：https://github.com/YangXiaoHei/Algorithms/blob/master/Ch_2_1_Elementary_Sorts/Practise_2_1_19.java\n这个序列是：\n48, 46, 54, 97, 83, 69, 76, 25, 10, 5, 87, 12, 21, 99, 61, 33, 30, 47, 57, 4, 36, 42, 98, 66, 100, 17, 94, 81, 11, 77, 24, 89, 73, 53, 38, 7, 29, 8, 27, 23, 56, 70, 60, 85, 39, 65, 9, 75, 15, 67, 64, 22, 51, 82, 43, 3, 37, 91, 45, 13, 34, 63, 74, 71, 95, 55, 80, 92, 2, 19, 62, 40, 84, 41, 50, 88, 86, 59, 28, 44, 72, 68, 14, 35, 93, 26, 18, 78, 31, 58, 96, 6, 1, 90, 49, 16, 52, 79, 32, 20 会比较 999 次。\n代码 #  构造最坏情况的类\nnamespace _2._1._19 { class ShellSortWorstCase { /// \u0026lt;summary\u0026gt;  /// 获得最坏情况的数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;数组大小。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;希尔排序最坏情况的数组。\u0026lt;/returns\u0026gt;  public static int[] GetWorst(int n) { int l = 0; int?[] a = new int?[n + 1]; for (int i = 0; i \u0026lt; a.Length; i++) { a[i] = null; } int P = 40; int PAddition = P; for (int i = 0; l \u0026lt; 100; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (a[j] == null \u0026amp;\u0026amp; IsVisible(j, P)) { l++; a[j] = l; } } P += PAddition; } int[] b = new int[n]; for (int i = 0; i \u0026lt; n; i++) { b[i] = (int)a[i + 1]; } return b; } /// \u0026lt;summary\u0026gt;  /// 确认 j - i 是不是在排序样板（Sorting Template）上。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static bool IsVisible(int i, int j) { int k = 0; while (k \u0026lt;= 100) { if (j - i \u0026gt;= k * 40 \u0026amp;\u0026amp; j - i \u0026lt;= k * 41) return true; k++; } return false; } } } 会显示比较次数的 ShellSort 类\nusing System; using System.Diagnostics; using Sort; namespace _2._1._19 { public class ShellSort : BaseSort { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public ShellSort() { } /// \u0026lt;summary\u0026gt;  /// 利用希尔排序将数组按升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { int n = a.Length; int compareTime = 0; int h = 1; while (h \u0026lt; n / 3) { h = 3 * h + 1; } while (h \u0026gt;= 1) { for (int i = h; i \u0026lt; n; i++) { for (int j = i; j \u0026gt;= h \u0026amp;\u0026amp; Less(a[j], a[j - h]); j -= h) { Exch(a, j, j - h); compareTime++; } compareTime++; } Debug.Assert(IsHSorted(a, h)); h /= 3; } Console.WriteLine(\u0026#34;CompareTime:\u0026#34; + compareTime); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 检查一次希尔排序后的子数组是否有序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;排序后的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;h\u0026#34;\u0026gt;子数组间隔。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;是否有序。\u0026lt;/returns\u0026gt;  private bool IsHSorted\u0026lt;T\u0026gt;(T[] a, int h) where T : IComparable\u0026lt;T\u0026gt; { for (int i = h; i \u0026lt; a.Length; i++) { if (Less(a[i], a[i - h])) { return false; } } return true; } } } main 方法\nusing System; namespace _2._1._19 { /* * 2.1.19 * * 希尔排序的最坏情况。 * 用 1 到 100 构造一个含有 100 个元素的数组并用希尔排序和 * 递增序列 1 4 13 40 对其排序， * 使比较次数尽可能多。 * */ class Program { // 开放题，没有标准答案  // 共参考的最差情况为 n^(3/2)  // 本例共 793 次  static void Main(string[] args) { int[] b; ShellSort sort = new ShellSort(); b = ShellSortWorstCase.GetWorst(100); for (int i = 0; i \u0026lt; b.Length; i++) { Console.Write(b[i] + \u0026#34; \u0026#34;); } Console.WriteLine(); sort.Sort(b); } } } 另请参阅 #  Sort 库\n"},{"id":198,"href":"/2-1-20/","title":"2.1.20","section":"帮助","content":"2.1.20 #  解答 #  由于每次 h 排序都是插入排序，希尔排序最好情况就是插入排序的最好情况，也就是已排序的数组。\n"},{"id":199,"href":"/2-1-21/","title":"2.1.21","section":"帮助","content":"2.1.21 #  解答 #  事实上官方给出来的 Date 类以及 Transaction 类都已经实现了这些接口。\nDate 类：Date.java\nTransaction 类：Transaction.java\n代码 #  using System; using Sort; namespace _2._1._21 { /* * 2.1.21 * * 可比较的交易。 * 用我们的 Date 类（请见 2.1.1.4 节） * 作为模板扩展你的 Transaction 类（请见练习 1.2.13）， * 实现 Comparable 接口，使交易能够按照金额排序。 * */ class Program { static void Main(string[] args) { Transaction[] a = new Transaction[4]; a[0] = new Transaction(\u0026#34;Turing 6/17/1990 644.08\u0026#34;); a[1] = new Transaction(\u0026#34;Tarjan 3/26/2002 4121.85\u0026#34;); a[2] = new Transaction(\u0026#34;Knuth 6/14/1999 288.34\u0026#34;); a[3] = new Transaction(\u0026#34;Dijkstra 8/22/2007 2678.40\u0026#34;); Console.WriteLine(\u0026#34;Unsorted\u0026#34;); for (int i = 0; i \u0026lt; a.Length; i++) { Console.WriteLine(a[i]); } Console.WriteLine(); Console.WriteLine(\u0026#34;Sort by amount\u0026#34;); InsertionSort insertionSort = new InsertionSort(); insertionSort.Sort(a, new Transaction.HowMuchOrder()); for (int i = 0; i \u0026lt; a.Length; i++) Console.WriteLine(a[i]); Console.WriteLine(); } } } 另请参阅 #  Sort 库\n"},{"id":200,"href":"/2-1-22/","title":"2.1.22","section":"帮助","content":"2.1.22 #  解答 #  和上题类似，只要传入事先写好的比较器就可以了。\n代码 #  using System; using Sort; namespace _2._1._22 { /* * 2.1.22 * * 交易排序测试用例。 * 编写一个 SortTransaction 类， * 在静态方法 main() 中从标准输入读取一系列交易， * 将它们排序并在标准输出中打印结果。 * */ class Program { static void Main(string[] args) { Transaction[] a = new Transaction[4]; // 样例输入  // Turing 6/17/1990 644.08  // Tarjan 3/26/2002 4121.85  // Knuth 6/14/1999 288.34  // Dijkstra 8/22/2007 2678.40  for (int i = 0; i \u0026lt; a.Length; i++) { string input = Console.ReadLine(); a[i] = new Transaction(input); } InsertionSort insertionSort = new InsertionSort(); Console.WriteLine(\u0026#34;Unsorted\u0026#34;); for (int i = 0; i \u0026lt; a.Length; i++) { Console.WriteLine(a[i]); } Console.WriteLine(); Console.WriteLine(\u0026#34;Sort by date\u0026#34;); insertionSort.Sort(a, new Transaction.WhenOrder()); for (int i = 0; i \u0026lt; a.Length; i++) Console.WriteLine(a[i]); Console.WriteLine(); Console.WriteLine(\u0026#34;Sort by customer\u0026#34;); insertionSort.Sort(a, new Transaction.WhoOrder()); for (int i = 0; i \u0026lt; a.Length; i++) Console.WriteLine(a[i]); Console.WriteLine(); Console.WriteLine(\u0026#34;Sort by amount\u0026#34;); insertionSort.Sort(a, new Transaction.HowMuchOrder()); for (int i = 0; i \u0026lt; a.Length; i++) Console.WriteLine(a[i]); Console.WriteLine(); } } } 另请参阅 #  Sort 库\n"},{"id":201,"href":"/2-1-23/","title":"2.1.23","section":"帮助","content":"2.1.23 #  解答 #  方法多种多样。\n首先是冒泡，见习题 2.1.13\n插入排序也可以，如下：\n从前往后不断翻牌，\n对于翻到的每张牌，一直和之前的牌交换，\n直至前面的牌比它小或者它已经是第一张了。\n也可以用基数排序\n从前向后依次翻开牌，\n按照花色分成四堆，\n然后按花色从大到小重新排列。\n比较符合直觉的是选择排序\n寻找最小的牌并放到第一位，\n寻找范围向右缩减一位，重复上一步，直到最后一张。\n还有其他方法，这里不再赘述。\n"},{"id":202,"href":"/2-1-24/","title":"2.1.24","section":"帮助","content":"2.1.24 #  解答 #  如果使用官方的实现（InsertionX.java），最后结果可能会比一般插入排序慢，因为它是用冒泡的方法找最小值的。\n一般做法是在待排序数组的最前端插入一个很小的值（比如 int.MinValue），然后对 a[1]~a[n] 排序。\n代码 #  参考官方实现的插入排序：\nusing System.Collections.Generic; using System.Diagnostics; using Sort; namespace _2._1._24 { /// \u0026lt;summary\u0026gt;  /// 插入排序类。  /// \u0026lt;/summary\u0026gt;  public class InsertionSort : BaseSort { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public InsertionSort() { } /// \u0026lt;summary\u0026gt;  /// 利用插入排序将数组按升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { int n = a.Length; int exchanges = 0; for (int i = n - 1; i \u0026gt; 0; i--) { if (Less(a[i], a[i - 1])) { Exch(a, i, i - 1); exchanges++; } } if (exchanges == 0) return; for (int i = 1; i \u0026lt; n; i++) { for (int j = i; Less(a[j], a[j - 1]); --j) { Exch(a, j, j - 1); } Debug.Assert(IsSorted(a, 0, i)); } Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 利用插入排序将数组排序。（使用指定比较器）  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;c\u0026#34;\u0026gt;比较器。\u0026lt;/param\u0026gt;  public void Sort\u0026lt;T\u0026gt;(T[] a, IComparer\u0026lt;T\u0026gt; c) { int n = a.Length; int exchanges = 0; for (int i = n - 1; i \u0026gt; 0; i--) { if (Less(a[i], a[i - 1], c)) { Exch(a, i, i - 1); exchanges++; } } if (exchanges == 0) return; for (int i = 1; i \u0026lt; n; i++) { for (int j = i; Less(a[j], a[j - 1], c); --j) { Exch(a, j, j - 1); } Debug.Assert(IsSorted(a, 0, i, c)); } Debug.Assert(IsSorted(a, c)); } } } 另请参阅 #  Sort 库\n"},{"id":203,"href":"/2-1-25/","title":"2.1.25","section":"帮助","content":"2.1.25 #  解答 #  使用依次赋值的方式腾出空间，到达指定位置之后再把元素插入。\n看代码会方便理解一点。\n官方实现：InsertionX.java。\n代码 #  using System.Collections.Generic; using System.Diagnostics; using Sort; namespace _2._1._25 { /// \u0026lt;summary\u0026gt;  /// 插入排序类。  /// \u0026lt;/summary\u0026gt;  public class InsertionSort : BaseSort { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public InsertionSort() { } /// \u0026lt;summary\u0026gt;  /// 利用插入排序将数组按升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { int n = a.Length; int exchanges = 0; for (int i = n - 1; i \u0026gt; 0 ; i--) { if (Less(a[i], a[i - 1])) { Exch(a, i, i - 1); exchanges++; } } if (exchanges == 0) return; for (int i = 2; i \u0026lt; n; i++) { int j = i; T v = a[i]; while (Less(v, a[j - 1])) { a[j] = a[j - 1]; j--; } a[j] = v; Debug.Assert(IsSorted(a, 0, i)); } Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 利用插入排序将数组排序。（使用指定比较器）  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;c\u0026#34;\u0026gt;比较器。\u0026lt;/param\u0026gt;  public void Sort\u0026lt;T\u0026gt;(T[] a, IComparer\u0026lt;T\u0026gt; c) { int n = a.Length; int exchanges = 0; for (int i = n - 1; i \u0026gt; 0; i--) { if (Less(a[i], a[i - 1], c)) { Exch(a, i, i - 1); exchanges++; } } if (exchanges == 0) return; for (int i = 2; i \u0026lt; n; i++) { int j = i; T v = a[i]; while (Less(v, a[j - 1], c)) { a[j] = a[j - 1]; j--; } a[j] = v; Debug.Assert(IsSorted(a, 0, i, c)); } Debug.Assert(IsSorted(a, c)); } } } 另请参阅 #  Sort 库\n"},{"id":204,"href":"/2-1-26/","title":"2.1.26","section":"帮助","content":"2.1.26 #  解答 #  直接针对特殊值的话显然会快很多。\n代码 #  直接把泛型改成 int 即可。\nnamespace _2._1._26 { /// \u0026lt;summary\u0026gt;  /// 插入排序类。  /// \u0026lt;/summary\u0026gt;  public class InsertionSort { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public InsertionSort() { } /// \u0026lt;summary\u0026gt;  /// 利用插入排序将数组按升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public void Sort(int[] a) { int n = a.Length; for (int i = 0; i \u0026lt; n; i++) { for (int j = i; j \u0026gt; 0 \u0026amp;\u0026amp; a[j] \u0026lt; a[j - 1]; --j) { int t = a[j]; a[j] = a[j - 1]; a[j - 1] = t; } } } } } 另请参阅 #  Sort 库\n"},{"id":205,"href":"/2-1-27/","title":"2.1.27","section":"帮助","content":"2.1.27 #  解答 #  数据比较大的时候会比较明显。\n代码 #  using System; using Sort; namespace _2._1._27 { /* * 2.1.27 * * 希尔排序的用时是次平方级的。 * 在你的计算机上用 SortCompare 比较希尔排序和插入排序以及选择排序。 * 测试数组的大小按照 2 的幂次递增，从 128 开始。 * */ class Program { static void Main(string[] args) { int n = 128; Random random = new Random(); double shellPrev = 1; double insertionPrev = 1; double selectionPrev = 1; while (n \u0026lt; 65538) { int[] testShell = new int[n]; int[] testInsertion = new int[n]; int[] testSelection = new int[n]; for (int i = 0; i \u0026lt; n; i++) { testShell[i] = random.Next(); testInsertion[i] = testShell[i]; testSelection[i] = testShell[i]; } Console.WriteLine(\u0026#34;数组大小：\u0026#34; + n); Console.Write(\u0026#34;Shell Sort:\u0026#34;); double shellNow = SortCompare.Time(new ShellSort(), testShell); Console.WriteLine(shellNow + \u0026#34;\\t\\tNow/Prev=\u0026#34; + shellNow / shellPrev); Console.Write(\u0026#34;Insertion Sort:\u0026#34;); double insertionNow = SortCompare.Time(new InsertionSort(), testInsertion); Console.WriteLine(insertionNow + \u0026#34;\\tNow/Prev=\u0026#34; + insertionNow / insertionPrev); Console.Write(\u0026#34;Selection Sort:\u0026#34;); double selectionNow = SortCompare.Time(new SelectionSort(), testSelection); Console.WriteLine(selectionNow + \u0026#34;\\tNow/Prev=\u0026#34; + selectionNow / selectionPrev); Console.WriteLine(); shellPrev = shellNow; insertionPrev = insertionNow; selectionPrev = selectionNow; n *= 2; } } } } 另请参阅 #  Sort 库\n"},{"id":206,"href":"/2-1-28/","title":"2.1.28","section":"帮助","content":"2.1.28 #  解答 #  插入排序会比选择排序快上许多，当然增长级别不变。\n代码 #  using System; using Sort; namespace _2._1._28 { /* * 2.1.28 * * 相等的主键。 * 对于主键仅可能取两种值的数组， * 评估和验证插入排序和选择排序的性能， * 假设两种主键值出现的概率相同。 * */ class Program { static void Main(string[] args) { int n = 1024; Random random = new Random(); double insertionPrev = 1; double selectionPrev = 1; while (n \u0026lt; 65538) { int[] testInsertion = new int[n]; int[] testSelection = new int[n]; for (int i = 0; i \u0026lt; n; i++) { testInsertion[i] = random.Next(2); testSelection[i] = testInsertion[i]; } Console.WriteLine(\u0026#34;数组大小：\u0026#34; + n); Console.Write(\u0026#34;Insertion Sort:\u0026#34;); double insertionNow = SortCompare.Time(new InsertionSort(), testInsertion); Console.WriteLine(insertionNow + \u0026#34;\\tNow/Prev=\u0026#34; + insertionNow / insertionPrev); Console.Write(\u0026#34;Selection Sort:\u0026#34;); double selectionNow = SortCompare.Time(new SelectionSort(), testSelection); Console.WriteLine(selectionNow + \u0026#34;\\tNow/Prev=\u0026#34; + selectionNow / selectionPrev); Console.WriteLine(); insertionPrev = insertionNow; selectionPrev = selectionNow; n *= 2; } } } } 另请参阅 #  Sort 库\n"},{"id":207,"href":"/2-1-29/","title":"2.1.29","section":"帮助","content":"2.1.29 #  解答 #  当然是题目给出的递增序列更快啦，因为这个序列就是作者提出来的嘛。\n（论文链接： http://linkinghub.elsevier.com/retrieve/pii/0196677486900015）\n代码 #  修改了一下 shellsort，让它按照给定的 h 序列排序。\nusing System; using System.Diagnostics; using Sort; namespace _2._1._29 { public class ShellSort : BaseSort { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public ShellSort() { } /// \u0026lt;summary\u0026gt;  /// 利用希尔排序将数组按升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;待排序的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;h\u0026#34;\u0026gt;需要使用的递增序列。\u0026lt;/param\u0026gt;  public void Sort\u0026lt;T\u0026gt;(T[] a, int[] h) where T : IComparable\u0026lt;T\u0026gt; { int n = a.Length; int t = 0; while (h[t] \u0026lt; a.Length) { t++; if (t \u0026gt;= h.Length) break; } t--; for ( ; t \u0026gt;= 0; t--) { for (int i = h[t]; i \u0026lt; n; i++) { for (int j = i; j \u0026gt;= h[t] \u0026amp;\u0026amp; Less(a[j], a[j - h[t]]); j -= h[t]) { Exch(a, j, j - h[t]); } } Debug.Assert(IsHSorted(a, h[t])); } Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 利用希尔排序将数组按升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { int n = a.Length; int[] h = new int[2]; // 预先准备好的 h 值数组  int hTemp = 1; int sequenceSize = 0; for (sequenceSize = 0; hTemp \u0026lt; n; sequenceSize++) { if (sequenceSize \u0026gt;= h.Length) // 如果数组不够大则双倍扩容  { int[] expand = new int[h.Length * 2]; for (int j = 0; j \u0026lt; h.Length; j++) { expand[j] = h[j]; } h = expand; } h[sequenceSize] = hTemp; hTemp = hTemp * 3 + 1; } for (int t = sequenceSize - 1; t \u0026gt;= 0; t--) { for (int i = h[t]; i \u0026lt; n; i++) { for (int j = i; j \u0026gt;= h[t] \u0026amp;\u0026amp; Less(a[j], a[j - h[t]]); j -= h[t]) { Exch(a, j, j - h[t]); } } Debug.Assert(IsHSorted(a, h[t])); } Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 检查一次希尔排序后的子数组是否有序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;排序后的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;h\u0026#34;\u0026gt;子数组间隔。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;是否有序。\u0026lt;/returns\u0026gt;  private bool IsHSorted\u0026lt;T\u0026gt;(T[] a, int h) where T : IComparable\u0026lt;T\u0026gt; { for (int i = h; i \u0026lt; a.Length; i++) { if (Less(a[i], a[i - h])) { return false; } } return true; } } } 另请参阅 #  Sort 库\n"},{"id":208,"href":"/2-1-30/","title":"2.1.30","section":"帮助","content":"2.1.30 #  解答 #  2，3，4\nt 越大的话，按照这个递增序列，10^6 次能够满足的 h 也就越少。\n代码 #  using System; using Sort; using System.Diagnostics; namespace _2._1._30 { /* * 2.1.30 * * 几何级数递增序列。 * 通过实验找到一个 t，使得对于大小为 N=10^6 的任意随机数组， * 使用递增序列 1, [t], [t^2], [t^3], [t^4], ... 的希尔排序的运行时间最短。 * 给出你能找到的三个最佳 t 值以及相应的递增序列。 * 以下练习描述的是各种用于评估排序算法的测试用例。 * 它们的作用是用随机数据帮助你增进对性能特性的理解。 * 随着命令行指定的实验测试的增大， * 可以和 SortCompare 一样在它们中使用 time() 函数来得到更精确的结果。 * 在以后的几节中我们会使用这些练习来评估更为复杂的算法。 * */ class Program { // t = 2, 3, 4  // t 大于 10 之后，由于每次排序 h 缩减的太快，  // 时间会越来越近似于直接插入排序。  static void Main(string[] args) { int[] array = SortCompare.GetRandomArrayInt(1000000); int[] array2 = new int[array.Length]; array.CopyTo(array2, 0); Stopwatch timer = new Stopwatch(); long[] bestTimes = new long[3]; long[] bestTs = new long[3]; for (int i = 0; i \u0026lt; bestTimes.Length; i++) { bestTimes[i] = long.MaxValue; bestTs[i] = int.MaxValue; } long nowTime = 0; ShellSort shellSort = new ShellSort(); for (int t = 2; t \u0026lt;= 1000000; t++) { Console.WriteLine(t); timer.Restart(); shellSort.Sort(array, t); nowTime = timer.ElapsedMilliseconds; timer.Stop(); Console.WriteLine(\u0026#34;Elapsed Time:\u0026#34; + nowTime); for (int i = 0; i \u0026lt; bestTimes.Length; i++) { Console.Write(\u0026#34;t:\u0026#34; + bestTs[i]); Console.WriteLine(\u0026#34;\\tTime:\u0026#34; + bestTimes[i]); } if (bestTimes[2] \u0026gt; nowTime) { bestTimes[2] = nowTime; bestTs[2] = t; Array.Sort(bestTimes, bestTs); } array2.CopyTo(array, 0); } for (int i = 0; i \u0026lt; bestTimes.Length; i++) { Console.Write(\u0026#34;t:\u0026#34; + bestTs[i]); Console.Write(\u0026#34;\\tTime:\u0026#34; + bestTimes[i]); } } } } 另请参阅 #  Sort 库\n"},{"id":209,"href":"/2-1-31/","title":"2.1.31","section":"帮助","content":"2.1.31 #  解答 #  这里截取数据量比较大的时候的数据。\n插入排序和选择排序显然都是平方级别的。\n希尔排序猜测是线性的，实际上要比线性大一点（次平方级）。\n代码 #  using System; using Sort; namespace _2._1._31 { /* * 2.1.31 * * 双倍测试。 * 编写一个能够对排序算法进行双倍测试的用例。 * 数组规模 N 的起始值为 1000， * 排序后打印 N、估计排序用时、实际排序用时以及在 N 倍增之后两次用时的比例。 * 用这段程序验证在随机输入模型下插入排序和选择排序的运行时间都是平方级别的。 * 对希尔排序的性能做出猜想并验证你的猜想。 * */ class Program { static void Main(string[] args) { int N = 1000; InsertionSort insertion = new InsertionSort(); SelectionSort selection = new SelectionSort(); ShellSort shell = new ShellSort(); double prevInsertion = 0; double prevSelection = 0; double prevShell = 0; for (int i = 0; i \u0026lt; 10; i++) { Console.WriteLine(\u0026#34;N:\u0026#34; + N); int[] array = SortCompare.GetRandomArrayInt(N); int[] arrayBak = new int[N]; array.CopyTo(arrayBak, 0); Console.WriteLine(\u0026#34;\\tInsertion Sort\u0026#34;); double now = SortCompare.Time(insertion, array); Console.WriteLine(\u0026#34;\\t\\tActual Time(ms):\u0026#34; + now); if (i != 0) { Console.WriteLine(\u0026#34;\\t\\tEstimate Time(ms):\u0026#34; + prevInsertion * 4); Console.WriteLine(\u0026#34;\\t\\tRatio:\u0026#34; + now / prevInsertion); } prevInsertion = now; arrayBak.CopyTo(array, 0); Console.WriteLine(\u0026#34;\\tSelection Sort\u0026#34;); now = SortCompare.Time(selection, array); Console.WriteLine(\u0026#34;\\t\\tActual Time(ms):\u0026#34; + now); if (i != 0) { Console.WriteLine(\u0026#34;\\t\\tEstimate Time(ms):\u0026#34; + prevSelection * 4); Console.WriteLine(\u0026#34;\\t\\tRatio:\u0026#34; + now / prevSelection); } prevSelection = now; arrayBak.CopyTo(array, 0); Console.WriteLine(\u0026#34;\\tShell Sort\u0026#34;); now = SortCompare.Time(shell, array); Console.WriteLine(\u0026#34;\\t\\tActual Time(ms):\u0026#34; + now); if (i != 0) { Console.WriteLine(\u0026#34;\\t\\tEstimate Time(ms):\u0026#34; + prevShell * 2); Console.WriteLine(\u0026#34;\\t\\tRatio:\u0026#34; + now / prevShell); } prevShell = now; N *= 2; } } } } 另请参阅 #  Sort 库\n"},{"id":210,"href":"/2-1-32/","title":"2.1.32","section":"帮助","content":"2.1.32 #  解答 #  基本上都是这么个样子：\n代码 #  using System; using System.Drawing; using System.Linq; using System.Windows.Forms; using Sort; namespace _2._1._32 { public partial class Form2 : Form { BaseSort sort; int n; double[] result; /// \u0026lt;summary\u0026gt;  /// 构造一个绘图结果窗口。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sort\u0026#34;\u0026gt;用于做测试的排序算法。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;用于测试的初始数据量。\u0026lt;/param\u0026gt;  public Form2(BaseSort sort, int n) { InitializeComponent(); this.sort = sort; this.n = n; this.result = Test(n); this.timer1.Interval = 1000; this.timer1.Start(); } /// \u0026lt;summary\u0026gt;  /// 执行八次耗时测试，每次数据量翻倍。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;初始数据量。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;测试结果数据。\u0026lt;/returns\u0026gt;  public double[] Test(int n) { double[] result = new double[8]; for (int i = 0; i \u0026lt; result.Length; i++) { result[i] = SortCompare.TimeRandomInput(this.sort, n, 3); n *= 2; } return result; } /// \u0026lt;summary\u0026gt;  /// 绘制曲线图。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;result\u0026#34;\u0026gt;结果数组。\u0026lt;/param\u0026gt;  public void DrawPanel(double[] result) { Graphics graphics = this.CreateGraphics(); graphics.TranslateTransform(0, this.ClientRectangle.Height); graphics.ScaleTransform(1, -1); Rectangle clientRect = this.ClientRectangle; Rectangle drawRect = new Rectangle(clientRect.X + 10, clientRect.Y + 10, clientRect.Width - 10, clientRect.Height - 10); PointF[] dataPoints = new PointF[result.Length]; float unitX = (float)drawRect.Width / result.Length; float unitY = (float)(drawRect.Height / result.Max()); SizeF pointSize = new SizeF(8, 8); for (int i = 0; i \u0026lt; result.Length; i++) { dataPoints[i] = new PointF(drawRect.Left + unitX * i, (float)(unitY * result[i])); graphics.FillEllipse(Brushes.Black, new RectangleF(dataPoints[i], pointSize)); } } private void timer1_Tick(object sender, EventArgs e) { DrawPanel(this.result); this.timer1.Stop(); } } } 另请参阅 #  Sort 库\n"},{"id":211,"href":"/2-1-33/","title":"2.1.33","section":"帮助","content":"2.1.33 #  解答 #  这里每次结果的 Y 轴位置都是随机生成的，这样图像会好看点。\nX 轴代表消耗的时间。\n选择排序：\n插入排序：\n希尔排序：\n代码 #  using System; using System.Collections.Generic; using System.Drawing; using System.Linq; using System.Windows.Forms; using Sort; namespace _2._1._33 { public partial class Form2 : Form { List\u0026lt;double\u0026gt; resultList; List\u0026lt;float\u0026gt; resultYList; Rectangle clientRect; Rectangle drawRect; BaseSort sort; int n; /// \u0026lt;summary\u0026gt;  /// 构造一个绘制结果窗口。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sort\u0026#34;\u0026gt;用于测试的排序算法。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;测试算法是生成的数据量。\u0026lt;/param\u0026gt;  public Form2(BaseSort sort, int n) { InitializeComponent(); this.resultList = new List\u0026lt;double\u0026gt;(); this.resultYList = new List\u0026lt;float\u0026gt;(); this.clientRect = this.ClientRectangle; this.drawRect = new Rectangle(this.clientRect.X + 10, this.clientRect.Y + 10, this.clientRect.Width - 10, this.clientRect.Height - 10); this.sort = sort; this.n = n; this.timer1.Interval = 500; this.timer1.Start(); } /// \u0026lt;summary\u0026gt;  /// 执行一次测试并绘制图像。  /// \u0026lt;/summary\u0026gt;  public void Test() { Random random = new Random(); double[] array = SortCompare.GetRandomArrayDouble(this.n); double time = SortCompare.Time(this.sort, array); this.resultList.Add(time); this.resultYList.Add((float)(random.NextDouble() * this.drawRect.Height)); DrawPanel(this.resultList.ToArray(), this.resultYList.ToArray()); } /// \u0026lt;summary\u0026gt;  /// 根据已有的数据绘制图像。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;result\u0026#34;\u0026gt;耗时数据（X 轴）\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;resultY\u0026#34;\u0026gt;Y 轴数据\u0026lt;/param\u0026gt;  public void DrawPanel(double[] result, float[] resultY) { Graphics graphics = this.CreateGraphics(); graphics.Clear(this.BackColor); graphics.TranslateTransform(0, this.ClientRectangle.Height); graphics.ScaleTransform(1, -1); PointF[] dataPoints = new PointF[result.Length]; float unitX = (float)(this.drawRect.Width / (result.Max() - result.Min())); double min = result.Min(); SizeF pointSize = new SizeF(8, 8); for (int i = 0; i \u0026lt; result.Length; i++) { dataPoints[i] = new PointF((float)(unitX * (result[i] - min)), resultY[i]); graphics.FillEllipse(Brushes.Black, new RectangleF(dataPoints[i], pointSize)); } } private void timer1_Tick(object sender, EventArgs e) { Test(); } } } 另请参阅 #  Sort 库\n"},{"id":212,"href":"/2-1-34/","title":"2.1.34","section":"帮助","content":"2.1.34 #  解答 #  代码 #  using System; using Sort; namespace _2._1._34 { /* * 2.1.34 * * 罕见情况。 * 编写一个测试用例， * 调用 sort() 方法对实际应用中可能出现困难或极端情况的数组进行排序。 * 比如，数组可能已经是有序的， * 或是逆序的， * 数组中的所有主键相同， * 数组的主键只有两种值， * 大小是 0 或 1 的数组。 * */ class Program { static void Main(string[] args) { InsertionSort insertionSort = new InsertionSort(); SelectionSort selectionSort = new SelectionSort(); ShellSort shellSort = new ShellSort(); // 逆序  Console.WriteLine(\u0026#34;逆序\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort Time: \u0026#34; + ReverseSortTest(insertionSort)); Console.WriteLine(\u0026#34;Selection Sort Time: \u0026#34; + ReverseSortTest(selectionSort)); Console.WriteLine(\u0026#34;Shell Sort Time: \u0026#34; + ReverseSortTest(shellSort)); // 顺序  Console.WriteLine(\u0026#34;顺序\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort Time: \u0026#34; + SortedSortTest(insertionSort)); Console.WriteLine(\u0026#34;Selection Sort Time: \u0026#34; + SortedSortTest(selectionSort)); Console.WriteLine(\u0026#34;Shell Sort Time: \u0026#34; + SortedSortTest(shellSort)); // 主键相同  Console.WriteLine(\u0026#34;主键相同\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort Time: \u0026#34; + EqualSortTest(insertionSort)); Console.WriteLine(\u0026#34;Selection Sort Time: \u0026#34; + EqualSortTest(selectionSort)); Console.WriteLine(\u0026#34;Shell Sort Time: \u0026#34; + EqualSortTest(shellSort)); // 二元数组  Console.WriteLine(\u0026#34;二元数组\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort Time: \u0026#34; + BinarySortTest(insertionSort)); Console.WriteLine(\u0026#34;Selection Sort Time: \u0026#34; + BinarySortTest(selectionSort)); Console.WriteLine(\u0026#34;Shell Sort Time: \u0026#34; + BinarySortTest(shellSort)); // 空数组  Console.WriteLine(\u0026#34;空数组\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort Time: \u0026#34; + ZeroArraySizeSort(insertionSort)); Console.WriteLine(\u0026#34;Selection Sort Time: \u0026#34; + ZeroArraySizeSort(selectionSort)); Console.WriteLine(\u0026#34;Shell Sort Time: \u0026#34; + ZeroArraySizeSort(shellSort)); // 只有一个元素的数组  Console.WriteLine(\u0026#34;只有一个元素的数组\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort Time: \u0026#34; + OneArraySizeSort(insertionSort)); Console.WriteLine(\u0026#34;Selection Sort Time: \u0026#34; + OneArraySizeSort(selectionSort)); Console.WriteLine(\u0026#34;Shell Sort Time: \u0026#34; + OneArraySizeSort(shellSort)); } /// \u0026lt;summary\u0026gt;  /// 构造逆序数组并用其对指定输入算法进行测试。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sort\u0026#34;\u0026gt;需要做测试的算法。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;算法耗时。\u0026lt;/returns\u0026gt;  static double ReverseSortTest(BaseSort sort) { int[] array = new int[10000]; for (int i = 0; i \u0026lt; array.Length; i++) { array[i] = array.Length - i; } return SortCompare.Time(sort, array); } /// \u0026lt;summary\u0026gt;  /// 构造已排序的数组并用其对指定排序算法测试。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sort\u0026#34;\u0026gt;需要做测试的排序算法。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;算法的耗时。\u0026lt;/returns\u0026gt;  static double SortedSortTest(BaseSort sort) { return SortCompare.TimeSortedInput(sort, 10000, 1); } /// \u0026lt;summary\u0026gt;  /// 构造只有一个值的数组并用其对指定排序算法做测试。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sort\u0026#34;\u0026gt;需要做测试的排序算法。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;算法的耗时。\u0026lt;/returns\u0026gt;  static double EqualSortTest(BaseSort sort) { int[] array = new int[10000]; Random random = new Random(); int num = random.Next(); for (int i = 0; i \u0026lt; array.Length; i++) { array[i] = num; } return SortCompare.Time(sort, array); } /// \u0026lt;summary\u0026gt;  /// 构造只有两种取值的数组并用其对指定排序算法做测试。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sort\u0026#34;\u0026gt;需要做测试的排序算法。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;排序算法的耗时。\u0026lt;/returns\u0026gt;  static double BinarySortTest(BaseSort sort) { int[] array = new int[10000]; Random random = new Random(); for (int i = 0; i \u0026lt; array.Length; i++) { array[i] = random.Next(2); } return SortCompare.Time(sort, array); } /// \u0026lt;summary\u0026gt;  /// 构造空数组并用其对指定排序算法做测试。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sort\u0026#34;\u0026gt;需要做测试的排序算法。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;排序算法的耗时。\u0026lt;/returns\u0026gt;  static double ZeroArraySizeSort(BaseSort sort) { int[] array = new int[0]; return SortCompare.Time(sort, array); } /// \u0026lt;summary\u0026gt;  /// 构造只有一个元素的数组并用其对指定排序算法做测试。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sort\u0026#34;\u0026gt;需要做测试的排序算法。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;排序算法的耗时。\u0026lt;/returns\u0026gt;  static double OneArraySizeSort(BaseSort sort) { int[] array = new int[1]; Random random = new Random(); array[0] = random.Next(); return SortCompare.Time(sort, array); } } } 另请参阅 #  Sort 库\n"},{"id":213,"href":"/2-1-35/","title":"2.1.35","section":"帮助","content":"2.1.35 #  解答 #  难点是如何生成符合这些分布的随机数。\nJava 的话官方给的 stdRandom 里面都有相应的实现。\n结果：\n代码 #  几种随机数的实现：\nusing System; namespace Sort { /// \u0026lt;summary\u0026gt;  /// 静态类，包含用于生成排序算法测试数据的方法。  /// \u0026lt;/summary\u0026gt;  public static class SortUtil { public static Random UniformGenerator = new Random(); /// \u0026lt;summary\u0026gt;  /// 产生符合正态分布的随机数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;average\u0026#34;\u0026gt;正态分布的期望值 μ。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;standardDeviation\u0026#34;\u0026gt;正态分布的标准差 σ。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;符合正态分布的随机数。\u0026lt;/returns\u0026gt;  public static double Normal(double average, double standardDeviation) { double u1 = UniformGenerator.NextDouble(); double u2 = UniformGenerator.NextDouble(); double z0 = Math.Sqrt(-2.0 * Math.Log(u1)) * Math.Cos(Math.PI * 2 * u2); return z0 * standardDeviation + average; } /// \u0026lt;summary\u0026gt;  /// 生成符合泊松分布的随机数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;average\u0026#34;\u0026gt;泊松分布的期望值 λ。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;一个符合泊松分布的随机数。\u0026lt;/returns\u0026gt;  public static double Poission(double average) { double x = 0; double p = Math.Pow(Math.E, -average); double s = p; double u = UniformGenerator.NextDouble(); do { x++; p *= average / x; s += p; } while (u \u0026gt; s); return x; } /// \u0026lt;summary\u0026gt;  /// 生成符合几何分布的随机数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;几何分布的概率 p，这应该是一个小于 1 的非负数。\u0026lt;/param\u0026gt;  /// \u0026lt;exception cref=\u0026#34;ArgumentOutOfRangeException\u0026#34;\u0026gt;概率不能大于 1.\u0026lt;/exception\u0026gt;  /// \u0026lt;returns\u0026gt;符合几何分布的随机数。\u0026lt;/returns\u0026gt;  public static double Geometry(double p) { if (p \u0026gt; 1) { throw new ArgumentOutOfRangeException(\u0026#34;p\u0026#34;, \u0026#34;概率不能大于 1\u0026#34;); } double result; result = Math.Ceiling(Math.Log(1 - UniformGenerator.NextDouble()) / Math.Log(1 - p)); return result; } /// \u0026lt;summary\u0026gt;  /// 根据指定的几率数组产生符合离散分布的随机数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;probabilities\u0026#34;\u0026gt;各取值的可能性。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;符合随机分布的随机整数。\u0026lt;/returns\u0026gt;  public static double Discrete(double[] probabilities) { if (probabilities == null) { throw new ArgumentNullException(\u0026#34;Argument array is null\u0026#34;); } double EPSION = 1E-14; double sum = 0; for (int i = 0; i \u0026lt; probabilities.Length; i++) { if (probabilities[i] \u0026lt;= 0) { throw new ArgumentException(\u0026#34;array entry \u0026#34; + i + \u0026#34; must be nonnegative:\u0026#34; + probabilities[i]); } sum += probabilities[i]; } if (sum \u0026gt; 1.0 + EPSION || sum \u0026lt; 1.0 - EPSION) { throw new ArgumentException(\u0026#34;sum of array entries does not equal 1.0:\u0026#34; + sum); } while (true) { double r = UniformGenerator.NextDouble(); sum = 0.0; for (int i = 0; i \u0026lt; probabilities.Length; i++) { sum += probabilities[i]; if (sum \u0026gt; r) { return i; } } } } } } Main 方法：\nusing System; using Sort; namespace _2._1._35 { /* * 2.1.35 * * 不均匀的概率分布。编写一个测试用例，使用非均匀分布的概率来生成随机排列的数据，包括： * 高斯分布 * 泊松分布 * 几何分布 * 离散分布（一种特殊情况见练习 2.1.28）。 * 评估并验证这些输入数据对本节讨论的算法的影响。 * */ class Program { static void Main(string[] args) { InsertionSort insertionSort = new InsertionSort(); SelectionSort selectionSort = new SelectionSort(); ShellSort shellSort = new ShellSort(); int n = 10000; // 高斯分布（正态分布）  double[] arrayInsertion = SortCompare.GetNormalDistributionArray(n); double[] arraySelection = new double[n]; double[] arrayShell = new double[n]; arrayInsertion.CopyTo(arraySelection, 0); arrayInsertion.CopyTo(arrayShell, 0); Console.WriteLine(\u0026#34;Normal Distribution:\u0026#34;); Console.WriteLine(\u0026#34;Insertion: \u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Selection: \u0026#34; + SortCompare.Time(selectionSort, arraySelection)); Console.WriteLine(\u0026#34;Shell: \u0026#34; + SortCompare.Time(shellSort, arrayShell)); // 泊松分布  arrayInsertion = SortCompare.GetPossionDistributionArray(n); arrayInsertion.CopyTo(arraySelection, 0); arrayInsertion.CopyTo(arrayShell, 0); Console.WriteLine(\u0026#34;Poission Distribution:\u0026#34;); Console.WriteLine(\u0026#34;Insertion: \u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Selection: \u0026#34; + SortCompare.Time(selectionSort, arraySelection)); Console.WriteLine(\u0026#34;Shell: \u0026#34; + SortCompare.Time(shellSort, arrayShell)); // 几何分布  arrayInsertion = SortCompare.GetGeometricDistributionArray(n, 0.3); arrayInsertion.CopyTo(arraySelection, 0); arrayInsertion.CopyTo(arrayShell, 0); Console.WriteLine(\u0026#34;Geometric Distribution:\u0026#34;); Console.WriteLine(\u0026#34;Insertion: \u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Selection: \u0026#34; + SortCompare.Time(selectionSort, arraySelection)); Console.WriteLine(\u0026#34;Shell: \u0026#34; + SortCompare.Time(shellSort, arrayShell)); // 离散分布  arrayInsertion = SortCompare.GetDiscretDistributionArray(n, new double[] { 0.1, 0.2, 0.3, 0.1, 0.1, 0.1, 0.1 }); arrayInsertion.CopyTo(arraySelection, 0); arrayInsertion.CopyTo(arrayShell, 0); Console.WriteLine(\u0026#34;Discret Distribution:\u0026#34;); Console.WriteLine(\u0026#34;Insertion: \u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Selection: \u0026#34; + SortCompare.Time(selectionSort, arraySelection)); Console.WriteLine(\u0026#34;Shell: \u0026#34; + SortCompare.Time(shellSort, arrayShell)); } } } 另请参阅 #  Sort 库\n"},{"id":214,"href":"/2-1-36/","title":"2.1.36","section":"帮助","content":"2.1.36 #  解答 #  最后结果：\n代码 #  using System; using Sort; namespace _2._1._36 { /* * 2.1.36 * * 不均匀的数据。 * 编写一个测试用例， * 生成不均匀的测试数据，包括： * 一半数据是 0，一半数据是 1 * 一半数据是 0，1/4 是 1，1/4 是 2，以此类推 * 一半数据是 0，一半是随机 int 值。 * 评估并验证这些输入数据对本节讨论的算法的性能的影响。 * */ class Program { // 选择排序的耗时与输入值的内容无关，不受影响。  // 对于插入排序，以上几种情况都是重复值较多的情况，插入排序的速度会加快。  // 希尔排序本质上也是插入排序，因此也会更快一些。  static void Main(string[] args) { int n = 10000; InsertionSort insertionSort = new InsertionSort(); SelectionSort selectionSort = new SelectionSort(); ShellSort shellSort = new ShellSort(); int[] arrayInsertion = new int[n]; int[] arraySelection = new int[n]; int[] arrayShell = new int[n]; // 对照，完全随机  arrayInsertion = HalfZeroHalfOne(n); arrayInsertion.CopyTo(arraySelection, 0); arrayInsertion.CopyTo(arrayShell, 0); Console.WriteLine(\u0026#34;totally random\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.TimeRandomInput(insertionSort, n, 1)); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + SortCompare.TimeRandomInput(selectionSort, n, 1)); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + SortCompare.TimeRandomInput(shellSort, n, 1)); Console.WriteLine(); // 一半是 0 一半是 1  arrayInsertion = HalfZeroHalfOne(n); arrayInsertion.CopyTo(arraySelection, 0); arrayInsertion.CopyTo(arrayShell, 0); Console.WriteLine(\u0026#34;half 0 and half 1\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + SortCompare.Time(selectionSort, arraySelection)); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + SortCompare.Time(shellSort, arrayShell)); Console.WriteLine(); // 一半是 0， 1/4 是 1， 1/8 是 2……  arrayInsertion = HalfAndHalf(n); arrayInsertion.CopyTo(arraySelection, 0); arrayShell.CopyTo(arrayShell, 0); Console.WriteLine(\u0026#34;half and half and half ...\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + SortCompare.Time(selectionSort, arraySelection)); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + SortCompare.Time(shellSort, arrayShell)); Console.WriteLine(); // 一半是 0，一半是随机 int 值  arrayInsertion = HalfZeroHalfRandom(n); arrayInsertion.CopyTo(arraySelection, 0); arrayShell.CopyTo(arrayShell, 0); Console.WriteLine(\u0026#34;half 0 half random\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + SortCompare.Time(selectionSort, arraySelection)); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + SortCompare.Time(shellSort, arrayShell)); } /// \u0026lt;summary\u0026gt;  /// 获取一半是 0 一半是 1 的随机 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;数组大小。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;一半是 0 一半是 1 的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt;数组。\u0026lt;/returns\u0026gt;  static int[] HalfZeroHalfOne(int n) { int[] result = new int[n]; Random random = new Random(); for (int i = 0; i \u0026lt; n; i++) { if (random.NextDouble() \u0026gt;= 0.5) { result[i] = 0; } else { result[i] = 1; } } return result; } /// \u0026lt;summary\u0026gt;  /// 生成 1/2 为 0， 1/4 为 1， 1/8 为 2 …… 的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;数组长度。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;1/2 为 0， 1/4 为 1， 1/8 为 2 …… 的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。\u0026lt;/returns\u0026gt;  static int[] HalfAndHalf(int n) { int[] array = new int[n]; HalfIt(0, 0, n / 2, array); Shuffle(array); return array; } /// \u0026lt;summary\u0026gt;  /// 递归生成 1/2 为 0， 1/4 为 1， 1/8 为 2 …… 的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;start\u0026#34;\u0026gt;填充起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;number\u0026#34;\u0026gt;起始编号。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;length\u0026#34;\u0026gt;填充长度\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;array\u0026#34;\u0026gt;用于填充的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;一个 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。\u0026lt;/returns\u0026gt;  static int[] HalfIt(int start, int number, int length, int[] array) { if (length == 0) return array; for (int i = 0; i \u0026lt; length; i++) { array[start + i] = number; } return HalfIt(start + length, number + 1, length / 2, array); } /// \u0026lt;summary\u0026gt;  /// 生成一半是 0 一半是随机整数的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;数组大小。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;生成一半是 0 一半是随机整数的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。\u0026lt;/returns\u0026gt;  static int[] HalfZeroHalfRandom(int n) { int[] array = new int[n]; Random random = new Random(); for (int i = 0; i \u0026lt; n / 2; i++) { array[i] = 0; } for (int i = n / 2; i \u0026lt; n; i++) { array[i] = random.Next(); } Shuffle(array); return array; } /// \u0026lt;summary\u0026gt;  /// 打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  static void Shuffle(int[] a) { int N = a.Length; Random random = new Random(); for (int i = 0; i \u0026lt; N; i++) { int r = i + random.Next(N - i);// 等于StdRandom.uniform(N-i)  int temp = a[i]; a[i] = a[r]; a[r] = temp; } } } } 另请参阅 #  Sort 库\n"},{"id":215,"href":"/2-1-37/","title":"2.1.37","section":"帮助","content":"2.1.37 #  解答 #  主要说一下第二个的实现，把一个数组按 10 位进行打乱即可。\n代码 #  using System; using System.Collections.Generic; using Sort; namespace _2._1._37 { /* * 2.1.37 * * 部分有序。 * 编写一个测试用例，生成部分有序数组，包括： * 95% 有序，其余部分为随机值。 * 所有元素和它们的正确位置的距离都不超过 10。 * 5% 的元素随机分布在整个数组中，剩下的数据都是有序的。 * 评估并验证这些输入数据对本节讨论的算法的性能的影响。 * */ class Program { // 选择排序的性能只与数组大小有关，以上三种情况耗时都是近似的。  // 插入排序的性能与逆序对数量有关，部分有序的情况下耗时会小于完全随机。  // 希尔排序与插入排序类似。  static void Main(string[] args) { InsertionSort insertionSort = new InsertionSort(); SelectionSort selectionSort = new SelectionSort(); ShellSort shellSort = new ShellSort(); int n = 10000; int[] selectionArray = new int[n]; int[] insertionArray = new int[n]; int[] shellArray = new int[n]; // 完全随机的对照  Console.WriteLine(\u0026#34;totally random\u0026#34;); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + SortCompare.TimeRandomInput(selectionSort, n, 1)); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.TimeRandomInput(insertionSort, n, 1)); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + SortCompare.TimeRandomInput(shellSort, n, 1)); // 95% 有序，其余部分为随机值。  selectionArray = Sorted95Random5(n); selectionArray.CopyTo(insertionArray, 0); selectionArray.CopyTo(shellArray, 0); Console.WriteLine(\u0026#34;95% sorted + 5% random\u0026#34;); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + SortCompare.Time(selectionSort, selectionArray)); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.Time(insertionSort, insertionArray)); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + SortCompare.Time(shellSort, shellArray)); // 所有元素和它们的正确位置的距离都不超过 10。  selectionArray = RandomIn10(n); selectionArray.CopyTo(insertionArray, 0); selectionArray.CopyTo(shellArray, 0); Console.WriteLine(\u0026#34;a sorted array that left shift 6 times\u0026#34;); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + SortCompare.Time(selectionSort, selectionArray)); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.Time(insertionSort, insertionArray)); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + SortCompare.Time(shellSort, shellArray)); // 5% 的元素随机分布在整个数组中，剩下的数据都是有序的。  selectionArray = RandomIn10(n); selectionArray.CopyTo(insertionArray, 0); selectionArray.CopyTo(shellArray, 0); Console.WriteLine(\u0026#34;95% elements is sorted while 5% elements are placed randomly\u0026#34;); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + SortCompare.Time(selectionSort, selectionArray)); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.Time(insertionSort, insertionArray)); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + SortCompare.Time(shellSort, shellArray)); } /// \u0026lt;summary\u0026gt;  /// 生成 95% 有序，最后 5% 随机的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;数组的大小。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;95% 有序，最后 5% 随机的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。\u0026lt;/returns\u0026gt;  static int[] Sorted95Random5(int n) { int[] array = new int[n]; int randomStart = (int)(n * 0.05); Random random = new Random(); for (int i = 0; i \u0026lt; n - randomStart; i++) { array[i] = i; } for (int i = n - randomStart; i \u0026lt; n; i++) { array[i] = random.Next(); } return array; } /// \u0026lt;summary\u0026gt;  /// 返回一个 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组，其中的每个元素和它的正确位置的距离都不超过 10。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;数组大小。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;一个 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组，其中的每个元素和它的正确位置的距离都不超过 10。\u0026lt;/returns\u0026gt;  static int[] RandomIn10(int n) { var array = new int[n]; for (var i = 0; i \u0026lt; n; i++) { array[i] = i; } for (var i = 0; i \u0026lt; n; i += 10) { var max = Math.Min(n, i + 10); ShuffleRange(array, i, max); } return array; } /// \u0026lt;summary\u0026gt;  /// 生成 5% 元素随机分布，剩余有序的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;需要生成的数组大小。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;5% 元素随机分布，剩余有序的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。\u0026lt;/returns\u0026gt;  static int[] Shuffle5Percent(int n) { Random random = new Random(); int percent5 = (int)(n * 0.05); int[] randomIndex = new int[percent5]; for (int i = 0; i \u0026lt; percent5; i++) { randomIndex[i] = random.Next(percent5); } int[] randomValue = new int[percent5]; for (int i = 0; i \u0026lt; percent5; i++) { randomValue[i] = randomIndex[i]; } Shuffle(randomValue); int[] array = new int[n]; for (int i = 0; i \u0026lt; n; i++) { array[i] = i; } for (int i = 0; i \u0026lt; percent5; i++) { array[randomIndex[i]] = randomValue[i]; } return array; } /// \u0026lt;summary\u0026gt;  /// 打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  static void Shuffle(int[] a) { int N = a.Length; Random random = new Random(); for (int i = 0; i \u0026lt; N; i++) { int r = i + random.Next(N - i);// 等于StdRandom.uniform(N-i)  int temp = a[i]; a[i] = a[r]; a[r] = temp; } } } } 另请参阅 #  Sort 库\n"},{"id":216,"href":"/2-1-38/","title":"2.1.38","section":"帮助","content":"2.1.38 #  解答 #  这里实现了一个 Pair 类，用来排序。\n每一个元素都有相应的 key 值和 value 值，排序时只使用 key 值进行排序。\n代码 #  using System; using Sort; namespace _2._1._38 { /* * 2.1.38 * * 不同类型的元素。 * 编写一个测试用例，生成由多种数据类型元素组成的数组，元素的主键值随机，包括： * 每个元素的主键均为 String 类型（至少长 10 个字符），并含有一个 double 值。 * 每个元素的主键均为 double 类型，并含有 10 个 String 值（每个都至少长 10 个字符）。 * 每个元素的主键均为 int 类型，并含有一个 int[20] 值。 * 评估并验证这些输入数据对本节讨论的算法的性能的影响。 * */ class Program { static void Main(string[] args) { int n = 10000; double[] results = TestA(n); Console.WriteLine(\u0026#34;string + double\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + results[0]); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + results[1]); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + results[2]); results = TestB(n); Console.WriteLine(\u0026#34;double + 10 string\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + results[0]); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + results[1]); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + results[2]); results = TestC(n); Console.WriteLine(\u0026#34;int + int[]\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + results[0]); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + results[1]); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + results[2]); } /// \u0026lt;summary\u0026gt;  /// 第一个测试，测试结果按照 Insertion, Selection, Shell 排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;测试的数组长度。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;测试结果。\u0026lt;/returns\u0026gt;  static double[] TestA(int n) { InsertionSort insertionSort = new InsertionSort(); SelectionSort selectionSort = new SelectionSort(); ShellSort shellSort = new ShellSort(); Random random = new Random(); // 每个元素的主键均为 String 类型（至少长 10 个字符），并含有一个 double 值。  Pair\u0026lt;string, double\u0026gt;[] array = new Pair\u0026lt;string, double\u0026gt;[n]; Pair\u0026lt;string, double\u0026gt;[] arrayBak = new Pair\u0026lt;string, double\u0026gt;[n]; for (int i = 0; i \u0026lt; n; i++) { array[i] = new Pair\u0026lt;string, double\u0026gt;(RandomString(20, random), random.NextDouble()); } array.CopyTo(arrayBak, 0); double[] results = new double[3]; results[0] = SortCompare.Time(insertionSort, array); arrayBak.CopyTo(array, 0); results[1] = SortCompare.Time(selectionSort, array); arrayBak.CopyTo(array, 0); results[2] = SortCompare.Time(shellSort, array); return results; } /// \u0026lt;summary\u0026gt;  /// 第二个测试，测试结果按照 Insertion, Selection, Shell 排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;测试的数组长度。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;测试结果。\u0026lt;/returns\u0026gt;  static double[] TestB(int n) { InsertionSort insertionSort = new InsertionSort(); SelectionSort selectionSort = new SelectionSort(); ShellSort shellSort = new ShellSort(); Random random = new Random(); // 每个元素的主键均为 double 类型，并含有 10 个 String 值（每个都至少长 10 个字符）。  Pair\u0026lt;double, string[]\u0026gt;[] array = new Pair\u0026lt;double, string[]\u0026gt;[n]; Pair\u0026lt;double, string[]\u0026gt;[] arrayBak = new Pair\u0026lt;double, string[]\u0026gt;[n]; for (int i = 0; i \u0026lt; n; i++) { string[] temp = new string[10]; for (int j = 0; j \u0026lt; 10; j++) { temp[j] = RandomString(12, random); } array[i] = new Pair\u0026lt;double, string[]\u0026gt;(random.NextDouble(), temp); } array.CopyTo(arrayBak, 0); double[] results = new double[3]; results[0] = SortCompare.Time(insertionSort, array); arrayBak.CopyTo(array, 0); results[1] = SortCompare.Time(selectionSort, array); arrayBak.CopyTo(array, 0); results[2] = SortCompare.Time(shellSort, array); return results; } /// \u0026lt;summary\u0026gt;  /// 第三个测试，测试结果按照 Insertion, Selection, Shell 排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;测试的数组长度。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;测试结果。\u0026lt;/returns\u0026gt;  static double[] TestC(int n) { InsertionSort insertionSort = new InsertionSort(); SelectionSort selectionSort = new SelectionSort(); ShellSort shellSort = new ShellSort(); Random random = new Random(); // 每个元素的主键均为 int 类型，并含有一个 int[20] 值。  Pair\u0026lt;int, int[]\u0026gt;[] array = new Pair\u0026lt;int, int[]\u0026gt;[n]; Pair\u0026lt;int, int[]\u0026gt;[] arrayBak = new Pair\u0026lt;int, int[]\u0026gt;[n]; for (int i = 0; i \u0026lt; n; i++) { int[] temp = new int[20]; for (int j = 0; j \u0026lt; 20; j++) { temp[j] = random.Next(); } array[i] = new Pair\u0026lt;int, int[]\u0026gt;(random.Next(), temp); } array.CopyTo(arrayBak, 0); double[] results = new double[3]; results[0] = SortCompare.Time(insertionSort, array); arrayBak.CopyTo(array, 0); results[1] = SortCompare.Time(selectionSort, array); arrayBak.CopyTo(array, 0); results[2] = SortCompare.Time(shellSort, array); return results; } /// \u0026lt;summary\u0026gt;  /// 获取一个随机 \u0026lt;see cref=\u0026#34;string\u0026#34;/\u0026gt;。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;\u0026lt;see cref=\u0026#34;string\u0026#34;/\u0026gt; 的长度。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;random\u0026#34;\u0026gt;随机数生成器。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;获取一个随机 \u0026lt;see cref=\u0026#34;string\u0026#34;/\u0026gt;。\u0026lt;/returns\u0026gt;  static string RandomString(int n, Random random) { char[] value = new char[n]; for (int i = 0; i \u0026lt; n; i++) { value[i] = (char)random.Next(char.MinValue + 10, char.MaxValue - 10); } return new string(value); } } } 另请参阅 #  Sort 库\n"},{"id":217,"href":"/2-2-1/","title":"2.2.1","section":"帮助","content":"2.2.1 #  解答 #  "},{"id":218,"href":"/2-2-2/","title":"2.2.2","section":"帮助","content":"2.2.2 #  解答 #  "},{"id":219,"href":"/2-2-3/","title":"2.2.3","section":"帮助","content":"2.2.3 #  解答 #  "},{"id":220,"href":"/2-2-4/","title":"2.2.4","section":"帮助","content":"2.2.4 #  解答 #  是的，必须要两个子数组都有序时归并才能得到正确结果。\n如果说数组不有序的话，那么最后只能得到两个数组的混合。\n合并后的数组中，属于原有数组的元素的相对顺序不会被改变。\n例如子数组 1 3 1 和 2 8 5 原地归并。\n结果是 1 2 3 1 8 5，其中 1 3 1 和 2 8 5 的相对顺序不变。\n"},{"id":221,"href":"/2-2-5/","title":"2.2.5","section":"帮助","content":"2.2.5 #  解答 #  每次归并子数组的大小和顺序如下：\n自顶向下\n2, 3, 2, 5, 2, 3, 2, 5, 10, 2, 3, 2, 5, 2, 3, 2, 5, 10, 20, 2, 3, 2, 5, 2, 3, 2, 5, 10, 2, 3, 2, 5, 2, 2, 4, 9, 19, 39\n自底向上\n2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 8, 8, 8, 8, 7, 16, 16, 32, 39\n"},{"id":222,"href":"/2-2-6/","title":"2.2.6","section":"帮助","content":"2.2.6 #  解答 #  灰色是上限，蓝点是自顶向下，红点是自底向上。\n由于两种排序访问数组的次数是一样的，因此蓝点和红点重合。\n代码 #  给出绘图部分的代码：\nusing System; using System.Windows.Forms; using System.Drawing; using Merge; namespace _2._2._6 { /* * 2.2.6 * * 编写一个程序来计算自顶向下和自底向上的归并排序访问数组的准确次数。 * 使用这个程序将 N=1 至 512 的结果绘成曲线图， * 并将其和上限 6NlgN 相比较。 * */ static class Program { /// \u0026lt;summary\u0026gt;  /// 应用程序的主入口点。  /// \u0026lt;/summary\u0026gt; [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Compute(); Application.Run(new Form1()); } static void Compute() { MergeSort mergeSort = new MergeSort(); MergeSortBU mergeSortBU = new MergeSortBU(); int[] mergeResult = new int[10]; int[] mergeResultBU = new int[10]; int[] upperBound = new int[10]; // 进行计算  int dataSize = 1; for (int i = 0; i \u0026lt; 10; i++) { int[] dataMerge = SortCompare.GetRandomArrayInt(dataSize); int[] dataMergeBU = new int[dataSize]; dataMerge.CopyTo(dataMergeBU, 0); mergeSort.ClearArrayVisitCount(); mergeSortBU.ClearArrayVisitCount(); mergeSort.Sort(dataMerge); mergeSortBU.Sort(dataMergeBU); mergeResult[i] = mergeSort.GetArrayVisitCount(); mergeResultBU[i] = mergeSortBU.GetArrayVisitCount(); upperBound[i] = (int)(6 * dataSize * Math.Log(dataSize, 2)); dataSize *= 2; } // 绘图  Form2 plot = new Form2(); plot.Show(); Graphics graphics = plot.CreateGraphics(); // 获得绘图区矩形。  RectangleF rect = plot.ClientRectangle; float unitX = rect.Width / 10; float unitY = rect.Width / 10; // 添加 10% 边距作为文字区域。  RectangleF center = new RectangleF (rect.X + unitX, rect.Y + unitY, rect.Width - 2 * unitX, rect.Height - 2 * unitY); // 绘制坐标系。  graphics.DrawLine(Pens.Black, center.Left, center.Top, center.Left, center.Bottom); graphics.DrawLine(Pens.Black, center.Left, center.Bottom, center.Right, center.Bottom); graphics.DrawString(\u0026#34;28000\u0026#34;, plot.Font, Brushes.Black, rect.Location); graphics.DrawString(\u0026#34;1024\u0026#34;, plot.Font, Brushes.Black, center.Right, center.Bottom); graphics.DrawString(\u0026#34;0\u0026#34;, plot.Font, Brushes.Black, rect.Left, center.Bottom); // 初始化点。  PointF[] grayPoints = new PointF[10]; // 上限  PointF[] redPoints = new PointF[10]; // 自顶向下  PointF[] bluePoints = new PointF[10]; // 自底向上  unitX = center.Width / 11.0f; unitY = center.Height / 28000.0f; for (int i = 0; i \u0026lt; 10; i++) { grayPoints[i] = new PointF(center.Left + unitX * (i + 1), center.Bottom - (upperBound[i] * unitY) - 10); redPoints[i] = new PointF(center.Left + unitX * (i + 1), center.Bottom - (mergeResult[i] * unitY) - 10); bluePoints[i] = new PointF(center.Left + unitX * (i + 1), center.Bottom - (mergeResultBU[i] * unitY) - 10); } // 绘制点。  for (int i = 0; i \u0026lt; 10; i++) { graphics.FillEllipse(Brushes.Gray, new RectangleF(grayPoints[i], new SizeF(10, 10))); graphics.FillEllipse(Brushes.Red, new RectangleF(redPoints[i], new SizeF(10, 10))); graphics.FillEllipse(Brushes.Blue, new RectangleF(bluePoints[i], new Size(10, 10))); } graphics.Dispose(); } } } 另请参阅 #  Merge 库\n"},{"id":223,"href":"/2-2-7/","title":"2.2.7","section":"帮助","content":"2.2.7 #  解答 #  根据书本给出的命题 G 和命题 H（中文版 P173/176，英文版 P275/279），\n比较次数的下限 $C(N) = 1/2 \\times NlgN$\n$N$ 和 $lgN$ 都是单调递增且大于零的($N\u0026gt;1$)，\n因此 $C(N)$ 也是单调递增的。\n"},{"id":224,"href":"/2-2-8/","title":"2.2.8","section":"帮助","content":"2.2.8 #  解答 #  修改后的算法对已经有序的情况做了优化\n数组对半切分并排序后，\n如果 a[mid] \u0026lt; a[mid + 1](左半部分的最后一个元素小于右半部分的第一个元素)\n那么我们可以直接合并数组，不需要再做多余的操作\n现在的输入是一个已经排序的数组\n算法唯一的比较发生在判断 a[mid] \u0026lt; a[mid + 1] 这个条件时\n假定数组有 $N$ 个元素\n比较次数满足 $T(N) = 2 T(N / 2) + 1, T(1) = 0$\n转化为非递归形式即为：$T(N) = cN / 2 + N - 1$\n其中 $c$ 为任意正整数。\n"},{"id":225,"href":"/2-2-9/","title":"2.2.9","section":"帮助","content":"2.2.9 #  解答 #  官方给出的归并排序实现中在 Sort 方法里初始化了 aux 数组。\n源码见：https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\nC#实现和官方的实现非常类似，\n首先定义只接受一个参数的公开 Sort 方法，在这个方法里面初始化 aux 数组。\n/// \u0026lt;summary\u0026gt; /// 利用归并排序将数组按升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { T[] aux = new T[a.Length]; Sort(a, aux, 0, a.Length - 1); } 然后建立一个私有的递归 Sort 方法做实际的排序操作。\n/// \u0026lt;summary\u0026gt; /// 自顶向下地对数组指定范围内进行归并排序，需要辅助数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围终点。\u0026lt;/param\u0026gt; private void Sort\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) return; int mid = lo + (hi - lo) / 2; Sort(a, aux, lo, mid); Sort(a, aux, mid + 1, hi); Merge(a, aux, lo, mid, hi); } 代码 #  using System; namespace Merge { /// \u0026lt;summary\u0026gt;  /// 归并排序类。  /// \u0026lt;/summary\u0026gt;  public class MergeSort : BaseSort { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public MergeSort() { } /// \u0026lt;summary\u0026gt;  /// 利用归并排序将数组按升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { T[] aux = new T[a.Length]; Sort(a, aux, 0, a.Length - 1); } /// \u0026lt;summary\u0026gt;  /// 自顶向下地对数组指定范围内进行归并排序，需要辅助数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围终点。\u0026lt;/param\u0026gt;  private void Sort\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) return; int mid = lo + (hi - lo) / 2; Sort(a, aux, lo, mid); Sort(a, aux, mid + 1, hi); Merge(a, aux, lo, mid, hi); } /// \u0026lt;summary\u0026gt;  /// 将指定范围内的元素归并。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;范围中点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt;  private void Merge\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int mid, int hi) where T : IComparable\u0026lt;T\u0026gt; { for (int k = lo; k \u0026lt;= hi; k++) { aux[k] = a[k]; } int i = lo, j = mid + 1; for (int k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) { a[k] = aux[j]; j++; } else if (j \u0026gt; hi) { a[k] = aux[i]; i++; } else if (Less(aux[j], aux[i])) { a[k] = aux[j]; j++; } else { a[k] = aux[i]; i++; } } } } } 另请参阅 #  Merge 库\n"},{"id":226,"href":"/2-2-10/","title":"2.2.10","section":"帮助","content":"2.2.10 #  解答 #  官方同样给出了 java 实现，如下：\nprivate static void merge(Comparable[] a, int lo, int mid, int hi) { for (int i = lo; i \u0026lt;= mid; i++) aux[i] = a[i]; for (int j = mid+1; j \u0026lt;= hi; j++) aux[j] = a[hi-j+mid+1]; int i = lo, j = hi; for (int k = lo; k \u0026lt;= hi; k++) if (less(aux[j], aux[i])) a[k] = aux[j--]; else a[k] = aux[i++]; } C# 实现见代码部分。\n代码 #  using System; using Merge; namespace _2._2._10 { /// \u0026lt;summary\u0026gt;  /// 归并排序类。  /// \u0026lt;/summary\u0026gt;  public class MergeSort : BaseSort { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public MergeSort() { } /// \u0026lt;summary\u0026gt;  /// 利用归并排序将数组按升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { T[] aux = new T[a.Length]; Sort(a, aux, 0, a.Length - 1); } /// \u0026lt;summary\u0026gt;  /// 自顶向下地对数组指定范围内进行归并排序，需要辅助数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围终点。\u0026lt;/param\u0026gt;  private void Sort\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) return; int mid = lo + (hi - lo) / 2; Sort(a, aux, lo, mid); Sort(a, aux, mid + 1, hi); Merge(a, aux, lo, mid, hi); } /// \u0026lt;summary\u0026gt;  /// 将指定范围内的元素归并。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;范围中点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt;  private void Merge\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int mid, int hi) where T : IComparable\u0026lt;T\u0026gt; { // 前半部分升序复制  for (int k = lo; k \u0026lt;= mid; k++) { aux[k] = a[k]; } // 后半部分降序复制  for (int k = mid + 1; k \u0026lt;= hi; k++) { aux[k] = a[hi - k + mid + 1]; } // i 指向最左端，j 指向最右端  int i = lo, j = hi; for (int k = lo; k \u0026lt;= hi; k++) { if (Less(aux[j], aux[i])) { a[k] = aux[j]; j--; } else { a[k] = aux[i]; i++; } } } } } 另请参阅 #  Merge 库\n"},{"id":227,"href":"/2-2-11/","title":"2.2.11","section":"帮助","content":"2.2.11 #  解答 #  官方实现见：https://algs4.cs.princeton.edu/22mergesort/MergeX.java.html\n在 MergeSortX 类里添加一个 CUTOFF 字段，排序时如果数组长度小于它则直接调用插入排序进行排序。\n在调用归并方法前判断第一个有序数组的最后一个元素是否大于第二个有序数组的第一个元素，\n如果大于的话就不需要调用归并了，直接首尾相接即可。\n每次归并都需要两个数组，一个用于存放归并结果，这个数组中的内容是无关紧要的；\n另一个则保存了归并前的数组，用于实际的归并过程。\n归并结束后，前一个数组变成归并后的有序结果（也就是下一次归并时的「归并前数组」），后一个数组中的内容则不再有用。\n我们可以看到这两个数组的角色在下一次归并时正好可以互换。\n要注意的是，归并次数总是一个奇数（左侧归并+右侧归并+总归并），因此在第一次调用 Sort 方法时应该把 aux 和 a 互换传入。\n代码 #  using System; namespace Merge { /// \u0026lt;summary\u0026gt;  /// 优化后的归并排序类。  /// \u0026lt;/summary\u0026gt;  public class MergeSortX : BaseSort { /// \u0026lt;summary\u0026gt;  /// 对小于 CUTOFF 的数组使用插入排序。  /// \u0026lt;/summary\u0026gt;  private static int CUTOFF = 7; /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public MergeSortX() { } /// \u0026lt;summary\u0026gt;  /// 设置启用插入排序的阈值，小于该阈值的数组将采用插入排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;cutoff\u0026#34;\u0026gt;新的阈值。\u0026lt;/param\u0026gt;  public void SetCutOff(int cutoff) =\u0026gt; CUTOFF = cutoff; /// \u0026lt;summary\u0026gt;  /// 将指定范围内的元素归并。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;src\u0026#34;\u0026gt;原始数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;dst\u0026#34;\u0026gt;目标数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;范围中点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt;  private void Merge\u0026lt;T\u0026gt;(T[] src, T[] dst, int lo, int mid, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = mid + 1; for (int k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) dst[k] = src[j++]; else if (j \u0026gt; hi) dst[k] = src[i++]; else if (Less(src[j], src[i])) dst[k] = src[j++]; else dst[k] = src[i++]; } } /// \u0026lt;summary\u0026gt;  /// 自顶向下地对数组指定范围内进行归并排序，需要辅助数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;src\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;dst\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围终点。\u0026lt;/param\u0026gt;  private void Sort\u0026lt;T\u0026gt;(T[] src, T[] dst, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { // 小于 CUTOFF 的数组调用插入排序  if (hi \u0026lt;= lo + CUTOFF) { InsertionSort insertion = new InsertionSort(); insertion.Sort(dst, lo, hi); return; } int mid = lo + (hi - lo) / 2; // 交换辅助数组和原数组  Sort(dst, src, lo, mid); Sort(dst, src, mid + 1, hi); // 已排序的数组直接合并  if (!Less(src[mid + 1], src[mid])) { Array.Copy(src, lo, dst, lo, hi - lo + 1); return; } Merge(src, dst, lo, mid, hi); } /// \u0026lt;summary\u0026gt;  /// 利用优化后的归并排序对数组 a 排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组中的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { T[] aux = new T[a.Length]; a.CopyTo(aux, 0); // aux 和 a 需要交换  Sort(aux, a, 0, a.Length - 1); } } } 另请参阅 #  Merge 库\n"},{"id":228,"href":"/2-2-12/","title":"2.2.12","section":"帮助","content":"2.2.12 #  解答 #  中文版的翻译比较难理解。\n实际上就是另一种归并排序的实现方式。\n先把数组分成若干个大小为 M 的块 。\n对于每个块，用选择排序进行排序 。\n随后遍历数组，将各个块归并起来。\n归并时仅复制右侧数组就够了，然后倒着归并（从右到左），可以将额外空间降到 M。\n具体归并流程如下：\n 复制右侧数组到 aux，现在右侧数组a[hi]~a[mid+1]中的元素可以被安全覆盖。 设定指针i,j,k，将数组 a[mid]~a[0] 和 aux[hi-mid-1]~aux[mid + 1] 归并到 a[hi - 1]~a[0]。  在这个流程中左侧数组的指针i是不会大于归并的写入指针k的。\n最坏情况下，aux用尽时 i == k，左侧数组可以直接并上去。\n代码 #  using System; using Merge; namespace _2._2._12 { /// \u0026lt;summary\u0026gt;  /// 归并排序类。  /// \u0026lt;/summary\u0026gt;  public class MergeSort : BaseSort { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public MergeSort() { } /// \u0026lt;summary\u0026gt;  /// 利用归并排序将数组按升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { Sort(a, 1); } /// \u0026lt;summary\u0026gt;  /// 利用分块法进行归并排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;待排序的数组内容。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;M\u0026#34;\u0026gt;分块大小。\u0026lt;/param\u0026gt;  public void Sort\u0026lt;T\u0026gt;(T[] a, int M) where T : IComparable\u0026lt;T\u0026gt; { var blockNum = (a.Length + M - 1) / M; var selection = new SelectionSort(); // 对块进行选择排序。  for (var i = 0; i \u0026lt; blockNum; i++) { var lo = i * M; var hi = Math.Min((i + 1) * M - 1, a.Length - 1); selection.Sort(a, lo, hi); } // 将各个块合并。  var aux = new T[M]; for (var i = 0; i \u0026lt; blockNum - 1; i++) { Merge(a, aux, 0, (i + 1) * M - 1, Math.Min((i + 2) * M - 1, a.Length - 1)); } } /// \u0026lt;summary\u0026gt;  /// 将指定范围内的元素归并。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;范围中点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt;  private void Merge\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int mid, int hi) where T : IComparable\u0026lt;T\u0026gt; { for (var k = mid + 1; k \u0026lt;= hi; k++) { aux[k - mid - 1] = a[k]; } int i = mid, j = hi - mid - 1; for (var k = hi; k \u0026gt;= lo; k--) { if (i \u0026lt; lo) { a[k] = aux[j]; j--; } else if (j \u0026lt; 0) { a[k] = a[i]; i--; } else if (Less(aux[j], a[i])) { a[k] = a[i]; i--; } else { a[k] = aux[j]; j--; } } } } } 另请参阅 #  Merge 库\n"},{"id":229,"href":"/2-2-13/","title":"2.2.13","section":"帮助","content":"2.2.13 #  解答 #  假设对三个数进行排序，\n这三个数是：35，10，17\n三个数排序的决策树如下，\n结点代表比较对应位置上的数。\n对于 35,10,17 来说，路径遵循右、左、左，最后得到的结果就是 2 3 1（10,17,35）。\n我们可以发现决策树上的每一个叶子节点都代表一种排列顺序，对于 N 个数，叶子节点就有 $N!$ 个\n根据二叉树的性质，高度为 $h$ 的二叉树最多有 $2^h$ 个叶子节点\n那么，对于 $N$ 个数，决策树的高度 $h$ 的最小值可以通过下面这个式子得出来\n$2^h \u0026gt;= n!$\n$h \\ge log(n!)$\n因此可以得到决策树高度 $h$ 的最小值是 $log(n!)$\n接下来我们来计算平均路径长度\n我们令函数 $H(k)$ 代表有 $k$ 个叶子节点的平衡决策树的所有路径长度之和\n上例中 $H(6) = 2 + 2 + 3 + 3 + 3 + 3 = 16$\n由于平衡决策树的性质，$H(k) = 2H(k / 2) + k$\n（加上 $k$ 的原因：左右子树的高度比整个树的高度小 $1$，因此每条路径的长度都必须加 $1$，总共多加了 $k$ 次）\n因此 $H(k) = klogk$\n现在令 $k = n!$\n$H(n!) = n!log(n!)$\n由于每次排序时我们只经过某一条路径（上例中我们只经过了右、左、左这条路径）\n而且每种路径的出现概率相等\n因此平均比较次数应该为 $H(n!) / n! = log(n!) = nlog(n)$\n证明完毕\n另请参阅 #  排序算法的下界-Data Selection. Lower bound for sorting-PDF\n"},{"id":230,"href":"/2-2-14/","title":"2.2.14","section":"帮助","content":"2.2.14 #  解答 #  比较两个有序队列的第一个元素，取较小的一个出队并放入额外建立的队列中。\n重复上述步骤直到两个队列都为空。\n代码 #  /// \u0026lt;summary\u0026gt; /// 归并两个有序队列。输入队列将被清空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;有序队列的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要归并的队列。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;需要归并的队列。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;归并后的新队列。\u0026lt;/returns\u0026gt; static Queue\u0026lt;T\u0026gt; Merge\u0026lt;T\u0026gt;(Queue\u0026lt;T\u0026gt; a, Queue\u0026lt;T\u0026gt; b) where T : IComparable\u0026lt;T\u0026gt; { Queue\u0026lt;T\u0026gt; sortedQueue = new Queue\u0026lt;T\u0026gt;(); while (!a.IsEmpty() \u0026amp;\u0026amp; !b.IsEmpty()) { if (a.Peek().CompareTo(b.Peek()) \u0026lt; 0) sortedQueue.Enqueue(a.Dequeue()); else sortedQueue.Enqueue(b.Dequeue()); } while (!a.IsEmpty()) sortedQueue.Enqueue(a.Dequeue()); while (!b.IsEmpty()) sortedQueue.Enqueue(b.Dequeue()); return sortedQueue; } "},{"id":231,"href":"/2-2-15/","title":"2.2.15","section":"帮助","content":"2.2.15 #  解答 #  程序思路题目已经给出，按照题意实现即可。\nMerge 方法可以直接使用前一题的实现。\n代码 #  using System; namespace _2._2._15 { /// \u0026lt;summary\u0026gt;  /// 利用队列归并实现的自底向上的归并排序。  /// \u0026lt;/summary\u0026gt;  class MergeSortQueue { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public MergeSortQueue() { } /// \u0026lt;summary\u0026gt;  /// 利用队列归并进行自底向上的归并排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public void Sort\u0026lt;T\u0026gt;(T[] a) where T : IComparable\u0026lt;T\u0026gt; { Queue\u0026lt;Queue\u0026lt;T\u0026gt;\u0026gt; queueList = new Queue\u0026lt;Queue\u0026lt;T\u0026gt;\u0026gt;(); for (int i = 0; i \u0026lt; a.Length; i++) { Queue\u0026lt;T\u0026gt; temp = new Queue\u0026lt;T\u0026gt;(); temp.Enqueue(a[i]); queueList.Enqueue(temp); } while (queueList.Size() != 1) { int times = queueList.Size() / 2; for (int i = 0; i \u0026lt; times; i++) { Queue\u0026lt;T\u0026gt; A = queueList.Dequeue(); Queue\u0026lt;T\u0026gt; B = queueList.Dequeue(); queueList.Enqueue(Merge(A, B)); } } Queue\u0026lt;T\u0026gt; result = queueList.Dequeue(); for (int i = 0; i \u0026lt; a.Length; i++) { a[i] = result.Dequeue(); } } /// \u0026lt;summary\u0026gt;  /// 归并两个有序队列。输入队列将被清空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;有序队列的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要归并的队列。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;需要归并的队列。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;归并后的新队列。\u0026lt;/returns\u0026gt;  public static Queue\u0026lt;T\u0026gt; Merge\u0026lt;T\u0026gt;(Queue\u0026lt;T\u0026gt; a, Queue\u0026lt;T\u0026gt; b) where T : IComparable\u0026lt;T\u0026gt; { Queue\u0026lt;T\u0026gt; sortedQueue = new Queue\u0026lt;T\u0026gt;(); while (!a.IsEmpty() \u0026amp;\u0026amp; !b.IsEmpty()) { if (a.Peek().CompareTo(b.Peek()) \u0026lt; 0) sortedQueue.Enqueue(a.Dequeue()); else sortedQueue.Enqueue(b.Dequeue()); } while (!a.IsEmpty()) sortedQueue.Enqueue(a.Dequeue()); while (!b.IsEmpty()) sortedQueue.Enqueue(b.Dequeue()); return sortedQueue; } } } "},{"id":232,"href":"/2-2-16/","title":"2.2.16","section":"帮助","content":"2.2.16 #  解答 #  自然归并排序的一个示例如下图所示：\n基本过程和自底向上的归并排序类似，只是每次归并的块大小不一定相同。\n时间分析\n随着有序块的变大，排序速度会加快，但增长的数量级也会变高（平均分块大小变大了）。\n代码 #  using System; using System.Diagnostics; namespace Merge { /// \u0026lt;summary\u0026gt;  /// 自然的归并排序。  /// \u0026lt;/summary\u0026gt;  public class MergeSortNatural : BaseSort { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public MergeSortNatural() { } /// \u0026lt;summary\u0026gt;  /// 利用自然的归并排序进行自底向上的排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;用于排序的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { T[] aux = new T[a.Length]; while (true) { // 找到第一个块  int lo = 0; int mid = FindBlock(lo, a) - 1; if (mid == a.Length - 1) break; while (mid \u0026lt; a.Length - 1) { int hi = FindBlock(mid + 1, a) + mid; Merge(lo, mid, hi, a, aux); lo = hi + 1; mid = FindBlock(lo, a) + lo - 1; } } Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 将两个块归并。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;第一个块的开始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;第一个块的结束下标（第二个块的开始下标 - 1）。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;第二个块的结束下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要归并的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt;  private void Merge\u0026lt;T\u0026gt;(int lo, int mid, int hi, T[] a, T[] aux) where T : IComparable\u0026lt;T\u0026gt; { for (int k = lo; k \u0026lt;= hi; k++) { aux[k] = a[k]; } int i = lo, j = mid + 1; for (int k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) { a[k] = aux[j]; j++; } else if (j \u0026gt; hi) { a[k] = aux[i]; i++; } else if (Less(aux[j], aux[i])) { a[k] = aux[j]; j++; } else { a[k] = aux[i]; i++; } } } /// \u0026lt;summary\u0026gt;  /// 获取下一个有序块。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;查找起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;用于查找的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;块的大小。\u0026lt;/returns\u0026gt;  private int FindBlock\u0026lt;T\u0026gt;(int lo, T[] a) where T : IComparable\u0026lt;T\u0026gt; { int size = 1; for (int i = lo; i \u0026lt; a.Length - 1; i++) { if (Less(a[i], a[i + 1]) || a[i].Equals(a[i + 1])) size++; else break; } return size; } } } 另请参阅 #  Merge 库\n"},{"id":233,"href":"/2-2-17/","title":"2.2.17","section":"帮助","content":"2.2.17 #  解答 #  排序方式和 2.2.16 十分类似，不再赘述，这里介绍一下归并方法。\n如 gif 图所示，先把要归并的两个链表拆出来，随后确定表头位置，然后进行归并即可。 归并结束后返回 first。\n结果分析如下图所示：\n随着有序部分的增加，对于相同大小的数组自然归并排序的耗时会缩短。\n对于有序部分相同的情况，随着数组大小的倍增，耗时呈现了O(nlogn)的趋势。\n代码 #  using System; using System.Diagnostics; using Merge; namespace _2._2._17 { /// \u0026lt;summary\u0026gt;  /// 自然的归并排序。  /// \u0026lt;/summary\u0026gt;  public class MergeSortNatural : BaseSort { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public MergeSortNatural() { } /// \u0026lt;summary\u0026gt;  /// 利用自然的归并排序进行自底向上的排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;用于排序的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { T[] aux = new T[a.Length]; while (true) { // 找到第一个块  int lo = 0; int mid = FindBlock(lo, a) - 1; if (mid == a.Length - 1) break; while (mid \u0026lt; a.Length - 1) { int hi = FindBlock(mid + 1, a) + mid; Merge(lo, mid, hi, a, aux); lo = hi + 1; mid = FindBlock(lo, a) + lo; } } Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 利用自然的归并排序将链表排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;链表元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;等待排序的链表。\u0026lt;/param\u0026gt;  public void Sort\u0026lt;T\u0026gt;(LinkedList\u0026lt;T\u0026gt; a) where T : IComparable\u0026lt;T\u0026gt; { while (true) { // 找到第一个块  Node\u0026lt;T\u0026gt; lo = a.GetFirst(); Node\u0026lt;T\u0026gt; mid = FindBlock(lo); if (mid.next == null) break; while (mid.next != null) { Node\u0026lt;T\u0026gt; hi = FindBlock(mid.next); if (lo == a.GetFirst()) a.SetFirst(Merge(lo, mid, hi)); else lo.next = Merge(lo.next, mid, hi); // 跳到表尾  if (Less(hi.item, mid.item)) lo = mid; else lo = hi; if (lo.next != null) mid = FindBlock(lo.next); } } } /// \u0026lt;summary\u0026gt;  /// 将两个块归并。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;第一个块的开始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;第一个块的结束下标（第二个块的开始下标 - 1）。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;第二个块的结束下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要归并的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt;  private void Merge\u0026lt;T\u0026gt;(int lo, int mid, int hi, T[] a, T[] aux) where T : IComparable\u0026lt;T\u0026gt; { for (int k = lo; k \u0026lt;= hi; k++) { aux[k] = a[k]; } int i = lo, j = mid + 1; for (int k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) { a[k] = aux[j]; j++; } else if (j \u0026gt; hi) { a[k] = aux[i]; i++; } else if (Less(aux[j], aux[i])) { a[k] = aux[j]; j++; } else { a[k] = aux[i]; i++; } } } /// \u0026lt;summary\u0026gt;  /// 将两个有序链表块归并，返回新的表头。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;链表元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;第一个有序块起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;第一个有序块终点（第二个有序块起点的前驱）。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;第二个有序块的终点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;新的表头。\u0026lt;/returns\u0026gt;  private Node\u0026lt;T\u0026gt; Merge\u0026lt;T\u0026gt;(Node\u0026lt;T\u0026gt; lo, Node\u0026lt;T\u0026gt; mid, Node\u0026lt;T\u0026gt; hi) where T : IComparable\u0026lt;T\u0026gt; { Node\u0026lt;T\u0026gt; after = hi.next; // 要合并的两个块之后的元素  Node\u0026lt;T\u0026gt; first = null; Node\u0026lt;T\u0026gt; i = lo; // 链表1  Node\u0026lt;T\u0026gt; j = mid.next; // 链表2  // 切割链表  mid.next = null; hi.next = null; Node\u0026lt;T\u0026gt; current = null; // 决定新的表头  if (Less(i.item, j.item)) { current = i; i = i.next; } else { current = j; j = j.next; } first = current; // 归并表  while (i != null \u0026amp;\u0026amp; j != null) { if (Less(i.item, j.item)) { current.next = i; i = i.next; current = current.next; } else { current.next = j; j = j.next; current = current.next; } } if (i == null) current.next = j; else current.next = i; // 连接表尾（链表 1 的尾部或者链表 2 的尾部）  if (mid.next == null) mid.next = after; else hi.next = after; return first; } /// \u0026lt;summary\u0026gt;  /// 获取下一个有序块。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;查找起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;用于查找的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;块的大小。\u0026lt;/returns\u0026gt;  private int FindBlock\u0026lt;T\u0026gt;(int lo, T[] a) where T : IComparable\u0026lt;T\u0026gt; { int size = 1; for (int i = lo; i \u0026lt; a.Length - 1; i++) { if (Less(a[i], a[i + 1]) || a[i].Equals(a[i + 1])) size++; else break; } return size; } /// \u0026lt;summary\u0026gt;  /// 获取链表的下一个有序块。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;链表的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;查找的起始结点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;有序块的最后一个元素结点。\u0026lt;/returns\u0026gt;  private Node\u0026lt;T\u0026gt; FindBlock\u0026lt;T\u0026gt;(Node\u0026lt;T\u0026gt; lo) where T : IComparable\u0026lt;T\u0026gt; { Node\u0026lt;T\u0026gt; hi = lo; while (hi.next != null) { if (Less(hi.item, hi.next.item) || hi.item.Equals(hi.next.item)) hi = hi.next; else break; } return hi; } } } 另请参阅 #  Merge 库\n"},{"id":234,"href":"/2-2-18/","title":"2.2.18","section":"帮助","content":"2.2.18 #  解答 #  可以在用归并排序的方法做。\n将归并时取两边较小的元素改为随机取一侧的值，即可实现打乱的效果。\n算法的分析和普通归并排序一致，满足题目要求。\n代码 #  分治法打乱链表的实现。\nusing System; namespace _2._2._18 { /// \u0026lt;summary\u0026gt;  /// 分治法打乱链表。 /// \u0026lt;/summary\u0026gt;  public class MergeShuffle { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public MergeShuffle() { } /// \u0026lt;summary\u0026gt;  /// 利用分治法打乱链表。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;链表元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;等待打乱的链表。\u0026lt;/param\u0026gt;  public void Shuffle\u0026lt;T\u0026gt;(LinkedList\u0026lt;T\u0026gt; a) { int blockLen = 1; Random random = new Random(); while (blockLen \u0026lt;= a.Size()) { // 找到第一个块  Node\u0026lt;T\u0026gt; lo = a.GetFirst(); Node\u0026lt;T\u0026gt; mid = FindBlock(lo, blockLen); if (mid.next == null) break; while (mid.next != null) { Node\u0026lt;T\u0026gt; hi = FindBlock(mid.next, blockLen); Node\u0026lt;T\u0026gt;[] result; if (lo == a.GetFirst()) { result = Merge(lo, mid, hi, random); a.SetFirst(result[0]); } else { result = Merge(lo.next, mid, hi, random); lo.next = result[0]; } // 跳到表尾  lo = result[1]; if (lo.next != null) mid = FindBlock(lo.next, blockLen); else mid = lo; } blockLen *= 2; } } /// \u0026lt;summary\u0026gt;  /// 将两个有序链表块随机归并，返回新的表头。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;链表元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;第一个块起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;第一个块终点（第二个块起点的前驱）。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;第二个块的终点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;新的表头。\u0026lt;/returns\u0026gt;  private Node\u0026lt;T\u0026gt;[] Merge\u0026lt;T\u0026gt;(Node\u0026lt;T\u0026gt; lo, Node\u0026lt;T\u0026gt; mid, Node\u0026lt;T\u0026gt; hi, Random random) { Node\u0026lt;T\u0026gt; after = hi.next; // 要合并的两个块之后的元素  Node\u0026lt;T\u0026gt; first = null; Node\u0026lt;T\u0026gt;[] result = new Node\u0026lt;T\u0026gt;[2]; Node\u0026lt;T\u0026gt; i = lo; // 链表1  Node\u0026lt;T\u0026gt; j = mid.next; // 链表2  // 切割链表  mid.next = null; hi.next = null; Node\u0026lt;T\u0026gt; current = null; // 决定新的表头  if (random.NextDouble() \u0026gt;= 0.5) { current = i; i = i.next; } else { current = j; j = j.next; } first = current; // 归并表  while (i != null \u0026amp;\u0026amp; j != null) { if (random.NextDouble() \u0026gt;= 0.5) { current.next = i; i = i.next; current = current.next; } else { current.next = j; j = j.next; current = current.next; } } if (i == null) current.next = j; else current.next = i; // 连接表尾（链表 1 的尾部或者链表 2 的尾部）  if (mid.next == null) { mid.next = after; result[1] = mid; } else { hi.next = after; result[1] = hi; } result[0] = first; return result; } /// \u0026lt;summary\u0026gt;  /// 获取从指定位置开始定长的链表。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;链表的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;链表的起始结点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;length\u0026#34;\u0026gt;需要获取的链表长度。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;结果链表的最后一个元素结点。\u0026lt;/returns\u0026gt;  private Node\u0026lt;T\u0026gt; FindBlock\u0026lt;T\u0026gt;(Node\u0026lt;T\u0026gt; lo, int length) { Node\u0026lt;T\u0026gt; hi = lo; for (int i = 0; i \u0026lt; length - 1 \u0026amp;\u0026amp; hi.next != null; i++) { hi = hi.next; } return hi; } } } 另请参阅 #  Merge 库\n"},{"id":235,"href":"/2-2-19/","title":"2.2.19","section":"帮助","content":"2.2.19 #  解答 #  官方实现：https://algs4.cs.princeton.edu/22mergesort/Inversions.java.html\n事实上只要在归并排序的时候统计 Less(aux[j], aux[i]) 满足的次数即可，这个次数就是我们要的值。\n代码 #  using System; using Merge; namespace _2._2._19 { /// \u0026lt;summary\u0026gt;  /// 归并排序类。  /// \u0026lt;/summary\u0026gt;  public class MergeSort : BaseSort { public int Counter = 0; /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public MergeSort() { } /// \u0026lt;summary\u0026gt;  /// 利用归并排序将数组按升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { T[] aux = new T[a.Length]; Sort(a, aux, 0, a.Length - 1); } /// \u0026lt;summary\u0026gt;  /// 自顶向下地对数组指定范围内进行归并排序，需要辅助数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围终点。\u0026lt;/param\u0026gt;  private void Sort\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) return; int mid = lo + (hi - lo) / 2; Sort(a, aux, lo, mid); Sort(a, aux, mid + 1, hi); Merge(a, aux, lo, mid, hi); } /// \u0026lt;summary\u0026gt;  /// 将指定范围内的元素归并。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;范围中点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt;  private void Merge\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int mid, int hi) where T : IComparable\u0026lt;T\u0026gt; { for (int k = lo; k \u0026lt;= hi; k++) { aux[k] = a[k]; } int i = lo, j = mid + 1; for (int k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) { a[k] = aux[j]; j++; } else if (j \u0026gt; hi) { a[k] = aux[i]; i++; } else if (Less(aux[j], aux[i])) { a[k] = aux[j]; this.Counter += mid - i + 1; // 统计逆序对数  j++; } else { a[k] = aux[i]; i++; } } } } } 另请参阅 #  Merge 库\n"},{"id":236,"href":"/2-2-20/","title":"2.2.20","section":"帮助","content":"2.2.20 #  解答 #  官方实现：https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\n把 Sort 方法中传入的 a 数组换成一个 index 数组，将 Merge 方法中的判断改为 Less(a[aux[j]], a[aux[i]]) 即可。\n代码 #  using System; using Merge; namespace _2._2._20 { /// \u0026lt;summary\u0026gt;  /// 归并排序类。  /// \u0026lt;/summary\u0026gt;  public class MergeSort : BaseSort { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public MergeSort() { } /// \u0026lt;summary\u0026gt;  /// 利用归并排序将数组按升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待排序的数组。\u0026lt;/param\u0026gt;  public int[] IndexSort\u0026lt;T\u0026gt;(T[] a) where T : IComparable\u0026lt;T\u0026gt; { int[] aux = new int[a.Length]; int[] index = new int[a.Length]; for (int i = 0; i \u0026lt; a.Length; i++) { index[i] = i; } Sort(a, index, aux, 0, a.Length - 1); return index; } /// \u0026lt;summary\u0026gt;  /// 自顶向下地对数组指定范围内进行归并排序，需要辅助数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围终点。\u0026lt;/param\u0026gt;  private void Sort\u0026lt;T\u0026gt;(T[] a, int[] index, int[] aux, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) return; int mid = lo + (hi - lo) / 2; Sort(a, index, aux, lo, mid); Sort(a, index, aux, mid + 1, hi); Merge(a, index, aux, lo, mid, hi); } /// \u0026lt;summary\u0026gt;  /// 将指定范围内的元素归并。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;范围中点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt;  private void Merge\u0026lt;T\u0026gt;(T[] a, int[] index, int[] aux, int lo, int mid, int hi) where T : IComparable\u0026lt;T\u0026gt; { for (int k = lo; k \u0026lt;= hi; k++) { aux[k] = index[k]; } int i = lo, j = mid + 1; for (int k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) { index[k] = aux[j]; j++; } else if (j \u0026gt; hi) { index[k] = aux[i]; i++; } else if (Less(a[aux[j]], a[aux[i]])) { index[k] = aux[j]; j++; } else { index[k] = aux[i]; i++; } } } public override void Sort\u0026lt;T\u0026gt;(T[] a) { throw new NotImplementedException(); } } } 另请参阅 #  Merge 库\n"},{"id":237,"href":"/2-2-21/","title":"2.2.21","section":"帮助","content":"2.2.21 #  解答 #  对三份列表进行归并排序（$O(nlogn)$），随后遍历一遍其中的一份表， 用二分查找检查在其余两个表中是否存在相同的姓名（$O(nlogn)$）。\n代码 #  using System; using Merge; namespace _2._2._21 { /* * 2.2.21 * * 一式三份。 * 给定三个列表， * 每个列表中包含 N 个名字， * 编写一个线性对数级别的算法来判定三份列表中是否含有公共的名字， * 如果有，返回第一个被找到的这种名字。 * */ class Program { static void Main(string[] args) { string[] name1 = new string[] { \u0026#34;Noah\u0026#34;, \u0026#34;Liam\u0026#34;, \u0026#34;Jacob\u0026#34;, \u0026#34;Mason\u0026#34; }; string[] name2 = new string[] { \u0026#34;Sophia\u0026#34;, \u0026#34;Emma\u0026#34;, \u0026#34;Mason\u0026#34;, \u0026#34;Ava\u0026#34; }; string[] name3 = new string[] { \u0026#34;Mason\u0026#34;, \u0026#34;Marcus\u0026#34;, \u0026#34;Alexander\u0026#34;, \u0026#34;Ava\u0026#34; }; MergeSort mergeSort = new MergeSort(); mergeSort.Sort(name1); mergeSort.Sort(name2); mergeSort.Sort(name3); for (int i = 0; i \u0026lt; name1.Length; i++) { if (BinarySearch(name1[i], name2, 0, name1.Length) != -1 \u0026amp;\u0026amp; BinarySearch(name1[i], name3, 0, name1.Length) != -1) { Console.WriteLine(name1[i]); break; } } } /// \u0026lt;summary\u0026gt;  /// 二分查找，返回目标元素的下标，没有结果则返回 -1。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;查找的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要查找的目标值。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;array\u0026#34;\u0026gt;用于查找的目标范围。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;查找的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;查找的终止下标。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;找到则返回元素下标，否则返回 -1。\u0026lt;/returns\u0026gt;  static int BinarySearch\u0026lt;T\u0026gt;(T key, T[] array, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { while (lo \u0026lt;= hi) { int mid = lo + (hi - lo) / 2; if (array[mid].Equals(key)) return mid; else if (array[mid].CompareTo(key) \u0026lt; 0) lo = mid + 1; else hi = mid - 1; } return -1; } } } 另请参阅 #  Merge 库\n"},{"id":238,"href":"/2-2-22/","title":"2.2.22","section":"帮助","content":"2.2.22 #  解答 #  增长数量级为$O(nlogn)$。\n代码 #  using System; using System.Diagnostics; namespace Merge { /// \u0026lt;summary\u0026gt;  /// 三向归并排序。  /// \u0026lt;/summary\u0026gt;  public class MergeSortThreeWay : BaseSort { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public MergeSortThreeWay() { } /// \u0026lt;summary\u0026gt;  /// 利用三项归并排序将数组按升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组中的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { T[] aux = new T[a.Length]; Sort(a, aux, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 自顶向下地对数组指定范围内进行三向归并排序，需要辅助数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围终点。\u0026lt;/param\u0026gt;  private void Sort\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 小于或等于一个元素  return; int lmid = lo + (hi - lo) / 3; int rmid = hi - (hi - lo) / 3; Sort(a, aux, lo, lmid); Sort(a, aux, lmid + 1, rmid); Sort(a, aux, rmid + 1, hi); Merge(a, aux, lo, lmid, rmid, hi); } /// \u0026lt;summary\u0026gt;  /// 返回两个元素中较小的那个。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;比较的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;用于比较的元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;用于比较的元素。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;较小的元素。\u0026lt;/returns\u0026gt;  private T Min\u0026lt;T\u0026gt;(T a, T b) where T : IComparable\u0026lt;T\u0026gt; { if (Less(a, b)) return a; return b; } /// \u0026lt;summary\u0026gt;  /// 将指定范围内的元素归并。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lmid\u0026#34;\u0026gt;范围三分之一点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;rmid\u0026#34;\u0026gt;范围三分之二点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt;  private void Merge\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int lmid, int rmid, int hi) where T : IComparable\u0026lt;T\u0026gt; { for (int l = lo; l \u0026lt;= hi; l++) { aux[l] = a[l]; } int i = lo, j = lmid + 1, k = rmid + 1; for (int l = lo; l \u0026lt;= hi; l++) { int flag = 0; if (i \u0026gt; lmid) flag += 1; if (j \u0026gt; rmid) flag += 10; if (k \u0026gt; hi) flag += 100; switch (flag) { case 0: // 三个数组都还没有取完  T min = Min(aux[i], Min(aux[j], aux[k])); if (min.Equals(aux[i])) a[l] = aux[i++]; else if (min.Equals(aux[j])) a[l] = aux[j++]; else a[l] = aux[k++]; break; case 1: // 只有第一个数组取完了  if (Less(aux[j], aux[k])) a[l] = aux[j++]; else a[l] = aux[k++]; break; case 10: // 只有第二个数组取完了  if (Less(aux[i], aux[k])) a[l] = aux[i++]; else a[l] = aux[k++]; break; case 100: // 只有第三个数组取完了  if (Less(aux[i], aux[j])) a[l] = aux[i++]; else a[l] = aux[j++]; break; case 11: // 第一、二个数组取完了  a[l] = aux[k++]; break; case 101: // 第一、三个数组取完了  a[l] = aux[j++]; break; case 110: // 第二、三个数组取完了  a[l] = aux[i++]; break; } } } } } 另请参阅 #  Merge 库\n"},{"id":239,"href":"/2-2-23/","title":"2.2.23","section":"帮助","content":"2.2.23 #  解答 #  阈值合适时，大约会有10%的性能提升。\n阈值在 10 以下都是比较合适的。\n代码 #  using System; using Merge; namespace _2._2._23 { /* * 2.2.23 * * 改进。 * 用实验评估正文中所提到的归并排序的三项改进（请见练习 2.2.11）的效果， * 并比较正文中实现的归并排序和练习 2.2.10 所实现的归并排序之间的性能。 * 根据经验给出应该在何时为子数组切换到插入排序。 * */ class Program { static void Main(string[] args) { MergeSort mergeSort = new MergeSort(); MergeSortX mergeSortX = new MergeSortX(); MergeSortUnstable mergeSortUnstable = new MergeSortUnstable(); int n = 1000000; int cutoff = 2; int trialTime = 4; Console.WriteLine(\u0026#34;归并排序改进前与改进后的比较：\u0026#34;); Console.WriteLine(\u0026#34;数组\\t耗时1\\t耗时2\\t阈值\\t比率\u0026#34;); for (int i = 0; i \u0026lt; 20; i++) { double mergeSortTime = 0; double mergeSortXTime = 0; mergeSortX.SetCutOff(cutoff); for (int j = 0; j \u0026lt; trialTime; j++) { int[] a = SortCompare.GetRandomArrayInt(n); int[] b = new int[a.Length]; a.CopyTo(b, 0); mergeSortTime += SortCompare.Time(mergeSort, a); mergeSortXTime += SortCompare.Time(mergeSortX, b); } mergeSortTime /= trialTime; mergeSortXTime /= trialTime; Console.WriteLine(n + \u0026#34;\\t\u0026#34; + mergeSortTime + \u0026#34;\\t\u0026#34; + mergeSortXTime + \u0026#34;\\t\u0026#34; + cutoff + \u0026#34;\\t\u0026#34; + mergeSortTime / mergeSortXTime); cutoff++; } n = 100000; Console.WriteLine(\u0026#34;稳定归并排序与不稳定版本的比较：\u0026#34;); Console.WriteLine(\u0026#34;数组\\t耗时1\\t耗时2\\t比率\u0026#34;); for (int i = 0; i \u0026lt; 6; i++) { double mergeSortTime = 0; double mergeSortUnstableTime = 0; for (int j = 0; j \u0026lt; trialTime; j++) { int[] a = SortCompare.GetRandomArrayInt(n); int[] b = new int[a.Length]; a.CopyTo(b, 0); mergeSortTime += SortCompare.Time(mergeSort, a); mergeSortUnstableTime += SortCompare.Time(mergeSortUnstable, b); } mergeSortTime /= trialTime; mergeSortUnstableTime /= trialTime; Console.WriteLine(n + \u0026#34;\\t\u0026#34; + mergeSortTime + \u0026#34;\\t\u0026#34; + mergeSortUnstableTime + \u0026#34;\\t\u0026#34; + mergeSortTime / mergeSortUnstableTime); n *= 2; } } } } 另请参阅 #  Merge 库\n"},{"id":240,"href":"/2-2-24/","title":"2.2.24","section":"帮助","content":"2.2.24 #  解答 #  约为 $lgN$ 次\n代码 #  using System; using Merge; namespace _2._2._24 { /* * 2.2.24 * * 改进的有序测试。 * 在实验中用大型随机数组评估练习 2.2.8 所做的修改的效果。 * 根据经验用 N（被排序的原始数组的大小）的函数描述条件语句 * （a[mid] \u0026lt;= a[mid + 1]）成立（无论数组是否有序）的次数。 * */ class Program { static void Main(string[] args) { MergeSortX mergeSortX = new MergeSortX(); int n = 10000; int trialTimes = 10; Console.WriteLine(\u0026#34;数组\\t平均命中次数\u0026#34;); for (int i = 0; i \u0026lt; 4; i++) { int avgHit = 0; for (int j = 0; j \u0026lt; trialTimes; j++) { mergeSortX.ResetHitTime(); int[] a = SortCompare.GetRandomArrayInt(n); mergeSortX.Sort(a); avgHit += mergeSortX.GetHitTime(); } Console.WriteLine(n + \u0026#34;\\t\u0026#34; + avgHit / trialTimes); n *= 10; } } } } 另请参阅 #  Merge 库\n"},{"id":241,"href":"/2-2-25/","title":"2.2.25","section":"帮助","content":"2.2.25 #  解答 #  事实上 k 的取值无关紧要，实验也证明了这一点。\n算法大致可以分为以下几个步骤 首先将数组划为 k 份，\n用一个数组 mids 记录这 k 个子数组的分割位置\n随后递归的调用 Sort 方法，将这 k 个子数组排序 随后将这 k 个子数组归并，\n每次归并时遍历取 k 个子数组中值最小的一个，\n然后对应子数组的指示器 + 1 上面这一步是 $O(k)$ 的，\n可以用堆或者败者树优化为对数级别\n代码 #  using System; using System.Diagnostics; namespace Merge { /// \u0026lt;summary\u0026gt;  /// k 路归并排序。  /// \u0026lt;/summary\u0026gt;  public class MergeSortKWay : BaseSort { /// \u0026lt;summary\u0026gt;  /// 同时归并的数组数目。  /// \u0026lt;/summary\u0026gt;  public int K { get; set; } /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public MergeSortKWay() { this.K = 2; } /// \u0026lt;summary\u0026gt;  /// 用 k 向归并排序对数组 a 进行排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;exception cref=\u0026#34;ArgumentOutOfRangeException\u0026#34;\u0026gt;数组长度小于 K 值时抛出异常。\u0026lt;/exception\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { if (this.K \u0026gt; a.Length) throw new ArgumentOutOfRangeException(\u0026#34;数组长度不能小于 K 值！\u0026#34;); T[] aux = new T[a.Length]; Sort(a, aux, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 自顶向下地对数组指定范围内进行 k 向归并排序，需要辅助数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围终点。\u0026lt;/param\u0026gt;  private void Sort\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 小于或等于一个元素  return; int[] mids = new int[this.K - 1]; int steps = (hi - lo) / this.K; mids[0] = lo + steps; for (int i = 1; i \u0026lt; this.K - 1; i++) { mids[i] = mids[i - 1] + steps; if (mids[i] \u0026gt; hi) // 防止溢出  mids[i] = hi; } Sort(a, aux, lo, mids[0]); for (int i = 1; i \u0026lt; this.K - 1; i++) { Sort(a, aux, mids[i - 1] + 1, mids[i]); } Sort(a, aux, mids[this.K - 2] + 1, hi); Merge(a, aux, lo, mids, hi); } /// \u0026lt;summary\u0026gt;  /// 将指定范围内的元素归并。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;mids\u0026#34;\u0026gt;范围中间点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt;  private void Merge\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int[] mids, int hi) where T : IComparable\u0026lt;T\u0026gt; { for (int l = lo; l \u0026lt;= hi; l++) { aux[l] = a[l]; } int[] pointers = new int[this.K]; // 标记每个数组的当前归并位置  pointers[0] = lo; // 开始时归并位置处于每个子数组的起始  for (int i = 1; i \u0026lt; this.K; i++) { pointers[i] = mids[i - 1] + 1; } // 开始归并  for (int i = lo; i \u0026lt;= hi; i++) { // 找到最小值  T min; int minPointerIndex = 0; bool isInit = true; if (pointers[this.K - 1] \u0026gt; hi) { min = default(T); // 初始化以避免编译错误  } else { min = aux[pointers[this.K - 1]]; minPointerIndex = this.K - 1; isInit = false; } for (int j = 0; j \u0026lt; this.K - 1; j++) { if (pointers[j] \u0026gt; mids[j]) // 当前数组已经用完  continue; if (isInit) // 第一次赋值  { isInit = false; min = aux[pointers[j]]; minPointerIndex = j; continue; } if (Less(aux[pointers[j]], min)) { min = aux[pointers[j]]; minPointerIndex = j; } } // 将最小值赋给归并数组，对应子数组的归并位置+1  a[i] = min; pointers[minPointerIndex]++; } } } } 另请参阅 #  Merge 库\n"},{"id":242,"href":"/2-2-26/","title":"2.2.26","section":"帮助","content":"2.2.26 #  解答 #  差距还是比较明显的，由于 Merge 会调用多次，而用于启动递归的 Sort 方法只会调用一次。\n代码 #  using System; using Merge; namespace _2._2._26 { /* * 2.2.26 * * 创建数组。 * 使用 SortCompare 粗略比较在你的计算机上 * 在 merge() 中和在 sort() 中创建 aux[] 的性能差异。 * */ class Program { static void Main(string[] args) { AuxInSortMergeSort auxInSort = new AuxInSortMergeSort(); AuxInMergeMergeSort auxInMerge = new AuxInMergeMergeSort(); int[] data1 = SortCompare.GetRandomArrayInt(100000); int[] data2 = new int[data1.Length]; data1.CopyTo(data2, 0); Console.WriteLine(\u0026#34;在Sort中创建aux[]\\t\u0026#34; + SortCompare.Time(auxInSort, data1) + \u0026#34;ms\u0026#34;); Console.WriteLine(\u0026#34;在Merge中创建aux[]\\t\u0026#34; + SortCompare.Time(auxInMerge, data2) + \u0026#34;ms\u0026#34;); } } } 另请参阅 #  Merge 库\n"},{"id":243,"href":"/2-2-27/","title":"2.2.27","section":"帮助","content":"2.2.27 #  解答 #  大致上会是一个对数函数，用 Excel 做了简单的拟合。\n原始数据：\n表中的 n 代表某一个子数组用尽时两个子数组之和，rest 是另一个未用尽的子数组平均剩余长度，times 代表出现次数，表中删去了出现次数小于 100 次的数据。\n   n rest times     2 0.331378 48576   3 0.333894 213568   6 0.603899 48576   7 0.596223 82496   14 0.773263 48576   15 0.796285 16960   29 0.879808 15808   30 0.883432 16960   60 0.950848 15808   61 0.935764 576   121 0.985163 7616   122 0.96875 576   243 0.93608 3520   244 1.147569 576   487 0.942255 1472   488 1.020833 576   975 1.078125 448   976 1.024306 576   1952 1.129464 448    代码 #  using System; using Merge; namespace _2._2._27 { /* * 2.2.27 * * 子数组长度。 * 用归并将大型随机数组排序， * 根据经验用 N （某次归并时两个子数组的长度之和） * 的函数估计当一个子数组用尽时另一个子数组的平均长度。 * */ class Program { static void Main(string[] args) { int arraySize = 1000000; NotifiedMergeSort sort = new NotifiedMergeSort(arraySize); for (int i = 0; i \u0026lt; 100; i++) { int[] data = SortCompare.GetRandomArrayInt(arraySize); sort.Sort(data); } Console.WriteLine(\u0026#34;n\\trest\\ttimes\u0026#34;); for (int i = 0; i \u0026lt; sort.NArraySize.Length; i++) { if (sort.NArraySize[i] != 0) Console.WriteLine(i + \u0026#34;\\t\u0026#34; + sort.NArraySize[i] / sort.NArraySizeTime[i] + \u0026#34;\\t\u0026#34; + sort.NArraySizeTime[i]); } // 大致上是一个对数函数  } } } 另请参阅 #  Merge 库\n"},{"id":244,"href":"/2-2-28/","title":"2.2.28","section":"帮助","content":"2.2.28 #  解答 #  自底向上会快一些，省去了递归过程中函数重复调用的时间。\n代码 #  using System; using Merge; namespace _2._2._28 { /* * 2.2.28 * * 自顶向下和自底向上。 * 对于 N=10^3、10^4、10^5 和 10^6， * 使用 SortCompare 比较自顶向下和自底向上的归并排序的性能。 * */ class Program { static void Main(string[] args) { int n = 1000; MergeSort topBottomMergeSort = new MergeSort(); MergeSortBU bottomUpMergeSort = new MergeSortBU(); int trialTimes = 100; for (int i = 0; i \u0026lt; 4; i++) { Console.Write(\u0026#34;数组大小：\u0026#34; + n + \u0026#34;\\t\u0026#34;); int time1 = 0, time2 = 0; for (int j = 0; j \u0026lt; trialTimes; j++) { double[] data1 = SortCompare.GetRandomArrayDouble(n); double[] data2 = new double[n]; data1.CopyTo(data2, 0); time1 += (int)SortCompare.Time(topBottomMergeSort, data1); time2 += (int)SortCompare.Time(bottomUpMergeSort, data2); } Console.WriteLine(\u0026#34;自顶向下：\u0026#34; + time1 / trialTimes + \u0026#34;ms\\t自底向上：\u0026#34; + time2 / trialTimes + \u0026#34;ms\u0026#34;); n *= 10; } } } } 另请参阅 #  Merge 库\n"},{"id":245,"href":"/2-2-29/","title":"2.2.29","section":"帮助","content":"2.2.29 #  解答 #  完全有序时只需要一次归并（直接输出），\n逆序时需要 n - 1 次归并（退化为插入排序），\n平均需要 n/2 次归并。\n所以分别需要 500，500000，500000000 次归并。\n"},{"id":246,"href":"/2-3-1/","title":"2.3.1","section":"帮助","content":"2.3.1 #  解答 #  "},{"id":247,"href":"/2-3-2/","title":"2.3.2","section":"帮助","content":"2.3.2 #  解答 #  "},{"id":248,"href":"/2-3-3/","title":"2.3.3","section":"帮助","content":"2.3.3 #  解答 #  N / 2\n在快速排序中，一个元素要被交换，有以下两种情况\n1.该元素是枢轴，在切分的最后一步被交换\n2.该元素位于枢轴错误的一侧，需要被交换到另一侧去\n注意，以上两种情况在一次切分中只会出现一次\n首先来看第一种情况，如果一个元素变成了枢轴\n那么在之后的切分中该元素会被排除，不存在后续的交换。\n因此我们的目标应该是：\n最大的元素总是出现在错误的一侧，同时切分的次数尽可能多。\n接下来我们来思考如何构造这样的数组\n由于我们针对的是最大的元素，因此「错误的一侧」就是枢轴的左侧。\n为了使切分的次数尽可能多，我们需要保持最大值移动的距离尽量短。\n但如果每次只移动一位的话，下一次切分时最大值就会变成枢轴\n例如 4 10 3 5 6，枢轴为 4，交换后数组变为：\n4 3 10 5 6\n随后 4 和 3 交换\n3 4 10 5 6\n下一次切分时 10 会变成枢轴，不再参与后续的切分。\n因此我们需要让最大值每次移动两个元素。\n考虑下面的数组：\n2 10 4 1 6 3 8 5 7 9\n第一次切分的时候，枢轴为 2，10 和 1 进行交换\n数组变为：\n2 1 4 10 6 3 8 5 7 9\n随后枢轴交换，数组变为：\n1 2 4 10 6 3 8 5 7 9\n第二次切分，枢轴为 4，10 和 3 进行交换。\n1 2 4 3 6 10 8 5 7 9\n随后枢轴交换 数组变为：\n1 2 3 4 6 10 8 5 7 9\n第三次切分，枢轴为 6，10 和 5 交换\n1 2 3 4 6 5 8 10 7 9\n随后枢轴交换，数组变为：\n1 2 3 4 5 6 8 10 7 9\n第四次切分，枢轴为 8，10 和 7 交换\n1 2 3 4 5 6 8 7 10 9\n枢轴交换，数组变为\n1 2 3 4 5 6 7 8 10 9\n最后一次切分，枢轴为 10，直接交换\n1 2 3 4 5 6 7 8 9 10\n我们可以总结出要构造这样的数组的模板\na2 max a3 a1\n其中 a1 \u0026lt; a2 \u0026lt; a3 \u0026lt; max\nmax 每轮切分移动两格，总共切分 N/ 2 次。\n另请参阅 #  Number of largest element exchanges for quicksort-Stack Overflow\n"},{"id":249,"href":"/2-3-4/","title":"2.3.4","section":"帮助","content":"2.3.4 #  解答 #  每次只让枢轴变为已排序，这就是最坏情况。\n这种时候枢轴是当前子数组的最大值 / 最小值。\n由于在我们的实现中总是取子数组的第一个元素作为枢轴。\n因此一个已排序的数组可以达到最坏情况，比较次数达到 O(n^ 2)。\n如果换作取最后一个元素，最坏情况会变成逆序数组。\n我们的实现中如果碰到与枢轴相等的元素也会停止循环，\n因此如果数组中有重复的元素会减少比较次数。\n例如：\n1 2 3 4 5 6 7 8 9 10 2 3 4 5 6 7 8 9 10 11 3 4 5 6 7 8 9 10 11 12 4 5 6 7 8 9 10 11 12 13 5 6 7 8 9 10 11 12 13 14 6 7 8 9 10 11 12 13 14 15 另请参阅 #  Analysis of Quicksort-khanacademy\nWorst case for QuickSort - When can it occur?-Stack Overflow\n"},{"id":250,"href":"/2-3-5/","title":"2.3.5","section":"帮助","content":"2.3.5 #  解答 #  官方实现：https://algs4.cs.princeton.edu/23quicksort/Sort2distinct.java.html\n算法 gif 动图\n代码 #  namespace Quick { /// \u0026lt;summary\u0026gt;  /// 用于将只有两种元素的数组排序。  /// \u0026lt;/summary\u0026gt;  public class Sort2Distinct : BaseSort { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public Sort2Distinct() { } /// \u0026lt;summary\u0026gt;  /// 对数组 a 进行排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组 a 的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { int lt = 0, gt = a.Length - 1; int i = 0; while (i \u0026lt;= gt) { int cmp = a[i].CompareTo(a[lt]); if (cmp \u0026lt; 0) Exch(a, lt++, i++); else if (cmp \u0026gt; 0) Exch(a, i, gt--); else i++; } } } } 另请参阅 #  Quick 库\n"},{"id":251,"href":"/2-3-6/","title":"2.3.6","section":"帮助","content":"2.3.6 #  解答 #  运行结果如下：\n代码 #  新建一个 QuickSortAnalyze 类，在 QuickSort 的基础上添加一个 CompareCount 属性，用于记录比较次数。重写 Less 方法，每调用一次就让 CompareCount 增加 1 。\nusing System; using System.Diagnostics; namespace Quick { /// \u0026lt;summary\u0026gt;  /// 自动记录比较次数以及子数组数量的快速排序类。  /// \u0026lt;/summary\u0026gt;  public class QuickSortAnalyze : BaseSort { /// \u0026lt;summary\u0026gt;  /// 比较次数。  /// \u0026lt;/summary\u0026gt;  public int CompareCount { get; set; } /// \u0026lt;summary\u0026gt;  /// 是否启用打乱。  /// \u0026lt;/summary\u0026gt;  public bool NeedShuffle { get; set; } /// \u0026lt;summary\u0026gt;  /// 是否显示轨迹。  /// \u0026lt;/summary\u0026gt;  public bool NeedPath { get; set; } /// \u0026lt;summary\u0026gt;  /// 大小为 0 的子数组数量。  /// \u0026lt;/summary\u0026gt;  public int Array0Num { get; set; } /// \u0026lt;summary\u0026gt;  /// 大小为 1 的子数组数量。  /// \u0026lt;/summary\u0026gt;  public int Array1Num { get; set; } /// \u0026lt;summary\u0026gt;  /// 大小为 2 的子数组数量。  /// \u0026lt;/summary\u0026gt;  public int Array2Num { get; set; } /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public QuickSortAnalyze() { this.CompareCount = 0; this.NeedShuffle = true; this.NeedPath = false; this.Array0Num = 0; this.Array1Num = 0; this.Array2Num = 0; } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 进行升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { this.Array0Num = 0; this.Array1Num = 0; this.Array2Num = 0; this.CompareCount = 0; if (this.NeedShuffle) Shuffle(a); if (this.NeedPath) { for (int i = 0; i \u0026lt; a.Length; i++) { Console.Write(\u0026#34; \u0026#34;); } Console.WriteLine(\u0026#34;\\tlo\\tj\\thi\u0026#34;); } Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 的 lo ~ hi 范围排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt;  private void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi - lo == 1) this.Array2Num++; else if (hi == lo) this.Array1Num++; else if (hi \u0026lt; lo) this.Array0Num++; if (hi \u0026lt;= lo) // 别越界  return; int j = Partition(a, lo, hi); if (this.NeedPath) { for (int i = 0; i \u0026lt; a.Length; i++) { Console.Write(a[i] + \u0026#34; \u0026#34;); } Console.WriteLine(\u0026#34;\\t\u0026#34; + lo + \u0026#34;\\t\u0026#34; + j + \u0026#34;\\t\u0026#34; + hi); } Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt;  /// 对数组进行切分，返回枢轴位置。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt;  private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; T v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt;  /// 打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  private void Shuffle\u0026lt;T\u0026gt;(T[] a) { Random random = new Random(); for (int i = 0; i \u0026lt; a.Length; i++) { int r = i + random.Next(a.Length - i); T temp = a[i]; a[i] = a[r]; a[r] = temp; } } /// \u0026lt;summary\u0026gt;  /// 比较第一个元素是否小于第二个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;要比较的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;第一个元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;第二个元素。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  new protected bool Less\u0026lt;T\u0026gt;(T a, T b) where T : IComparable\u0026lt;T\u0026gt; { this.CompareCount++; return a.CompareTo(b) \u0026lt; 0; } } } 主方法\nusing System; using Quick; namespace _2._3._6 { /* * 2.3.6 * * 编写一段代码来计算 C_N 的准确值， * 在 N=100、1000 和 10 000 的情况下比较准确值和估计值 2NlnN 的差距。 * */ class Program { static void Main(string[] args) { Console.WriteLine(\u0026#34;N\\t准确值\\t估计值\\t比值\u0026#34;); QuickSortAnalyze sort = new QuickSortAnalyze(); int N = 100; int trialTime = 500; for (int i = 0; i \u0026lt; 3; i++) { int sumOfCompare = 0; int[] a = new int[N]; for (int j = 0; j \u0026lt; trialTime; j++) { for (int k = 0; k \u0026lt; N; k++) { a[k] = k; } SortCompare.Shuffle(a); sort.Sort(a); sumOfCompare += sort.CompareCount; } int averageCompare = sumOfCompare / trialTime; double estimatedCompare = 2 * N * Math.Log(N); Console.WriteLine(N + \u0026#34;\\t\u0026#34; + averageCompare + \u0026#34;\\t\u0026#34; + (int)estimatedCompare + \u0026#34;\\t\u0026#34; + averageCompare / estimatedCompare); N *= 10; } } } } 另请参阅 #  Quick 库\n"},{"id":252,"href":"/2-3-7/","title":"2.3.7","section":"帮助","content":"2.3.7 #  解答 #  我讨厌数学= =\n证明：\n我们设 $C_0(n)$ 代表将 $n$ 个不重复元素排序时大小为 0 的数组的数量。\n同理有 $C_1(n)$ 和 $C_2(n)$ 代表大小为 1 的数组的数量以及大小为 2 的数组的数量。\n设 k 代表切分位置，显然切分位置随机且概率相等，在 1~n 之间均匀分布。\n根据条件，$C_0(n), C_1(n),C_2(n)$ 都满足下式：\n$$\nC(n)= \\frac{\\sum_{k=1}^{n}(C(k-1)+C(n-k))}{n}\n$$\n根据快速排序算法， $\\sum_{k=1}^{n}C(k-1)=\\sum_{k=1}^{n}C(n-k)$ ，因此\n$$\nC(n)=\\frac{2\\sum_{k=1}^{n}C(k-1)}{n}\\\nnC(n)=2\\sum_{k-1}^{n}C(k-1)\n$$\n同理代入 $n-1$ 有\n$$\n(n-1)C(n-1)=2\\sum_{k-1}^{n-1}C(k-1)\n$$\n相减\n$$\nnC(n)-(n-1)C(n-1)=2C(n-1)\\\nC(n)=\\frac{n+1}{n}C(n-1)\n$$\n利用累乘法求到通项公式\n$$\n\\frac{C(n)}{C(n-1)}=\\frac{n+1}{n} \\\n\\frac{C(n)}{C(n-1)}\\times\\frac{C(n-1)}{C(n-2)}\\times\\dots\\times\\frac{C(m+1)}{C(m)}=\n\\frac{n+1}{n}\\times\\frac{n}{n-1}\\times\\dots\\times\\frac{m+2}{m+1}\\\n\\frac{C(n)}{C(m)}=\\frac{n+1}{m+1}\\\nC(n)=C(m)\\frac{n+1}{m+1}，n\u0026gt;m\n$$\n对于 $C_0(n)$ ，我们有初始条件 $C_0(0)=1, C_0(1)=0,C_0(2)=C_0(0)+C_0(1)=1$\n$$\nC_0(n)=\\frac{n+1}{3}, n\u0026gt;2\n$$\n对于 $C_1(n)$ ，我们有初始条件 $C_1(0)=0,C_1(1)=1,C_1(2)=C_1(0)+C_1(1)=1$\n$$\nC_1(n)=\\frac{n+1}{3},n\u0026gt;2\n$$\n对于 $C_2(n)$ ，我们有初始条件 $C_2(0)=C_2(1)=0,C_2(2)=1,C_2(3)=\\frac{2\\times(C_2(0)+C_2(1)+C_2(2))}{3}=\\frac{2}{3}$\n$$\nC_2(n)=\\frac{n+1}{6},n\u0026gt;3\n$$\n结论\n$$\nC_0(n)=C_1(n)=\\frac{n+1}{3},n\u0026gt;2 \\\nC_2(n)=\\frac{n+1}{6},n\u0026gt;3\n$$\n实验结果：\n代码 #  QuickSortAnalyze 类，添加了三个属性用于计算数组数量。\nusing System; using System.Diagnostics; namespace Quick { /// \u0026lt;summary\u0026gt;  /// 自动记录比较次数以及子数组数量的快速排序类。  /// \u0026lt;/summary\u0026gt;  public class QuickSortAnalyze : BaseSort { /// \u0026lt;summary\u0026gt;  /// 比较次数。  /// \u0026lt;/summary\u0026gt;  public int CompareCount { get; set; } /// \u0026lt;summary\u0026gt;  /// 是否启用打乱。  /// \u0026lt;/summary\u0026gt;  public bool NeedShuffle { get; set; } /// \u0026lt;summary\u0026gt;  /// 是否显示轨迹。  /// \u0026lt;/summary\u0026gt;  public bool NeedPath { get; set; } /// \u0026lt;summary\u0026gt;  /// 大小为 0 的子数组数量。  /// \u0026lt;/summary\u0026gt;  public int Array0Num { get; set; } /// \u0026lt;summary\u0026gt;  /// 大小为 1 的子数组数量。  /// \u0026lt;/summary\u0026gt;  public int Array1Num { get; set; } /// \u0026lt;summary\u0026gt;  /// 大小为 2 的子数组数量。  /// \u0026lt;/summary\u0026gt;  public int Array2Num { get; set; } /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public QuickSortAnalyze() { this.CompareCount = 0; this.NeedShuffle = true; this.NeedPath = false; this.Array0Num = 0; this.Array1Num = 0; this.Array2Num = 0; } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 进行升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { this.Array0Num = 0; this.Array1Num = 0; this.Array2Num = 0; this.CompareCount = 0; if (this.NeedShuffle) Shuffle(a); if (this.NeedPath) { for (int i = 0; i \u0026lt; a.Length; i++) { Console.Write(\u0026#34; \u0026#34;); } Console.WriteLine(\u0026#34;\\tlo\\tj\\thi\u0026#34;); } Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 的 lo ~ hi 范围排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt;  private void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi - lo == 1) this.Array2Num++; else if (hi == lo) this.Array1Num++; else if (hi \u0026lt; lo) this.Array0Num++; if (hi \u0026lt;= lo) // 别越界  return; int j = Partition(a, lo, hi); if (this.NeedPath) { for (int i = 0; i \u0026lt; a.Length; i++) { Console.Write(a[i] + \u0026#34; \u0026#34;); } Console.WriteLine(\u0026#34;\\t\u0026#34; + lo + \u0026#34;\\t\u0026#34; + j + \u0026#34;\\t\u0026#34; + hi); } Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt;  /// 对数组进行切分，返回枢轴位置。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt;  private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; T v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt;  /// 打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  private void Shuffle\u0026lt;T\u0026gt;(T[] a) { Random random = new Random(); for (int i = 0; i \u0026lt; a.Length; i++) { int r = i + random.Next(a.Length - i); T temp = a[i]; a[i] = a[r]; a[r] = temp; } } /// \u0026lt;summary\u0026gt;  /// 比较第一个元素是否小于第二个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;要比较的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;第一个元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;第二个元素。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  new protected bool Less\u0026lt;T\u0026gt;(T a, T b) where T : IComparable\u0026lt;T\u0026gt; { this.CompareCount++; return a.CompareTo(b) \u0026lt; 0; } } } 主方法\nusing System; using Quick; namespace _2._3._7 { /* * 2.3.7 * * 在使用快速排序将 N 个不重复的元素排序时， * 计算大小为 0、1 和 2 的子数组的数量。 * 如果你喜欢数学，请推导； * 如果你不喜欢，请做一些实验并提出猜想。 * */ class Program { static void Main(string[] args) { // 证明  // 我们设 C0(n) 代表将 n 个不重复元素排序时大小为 0 的数组的数量。  // 同理有 C1(n) 和 C2(n) 代表大小为 1 的数组的数量和大小为 2 的数组的数量。  // 设 k 代表切分位置，显然切分位置随机且概率相等，在 1~n 之间均匀分布。  // 根据条件，三者都满足下式。  // C(n) = 1/n sum(C(k - 1) + C(n - k)), k=1,2,...,n  // 显然 sum(C(k - 1)) = sum(C(n - k)), k=1,2,...,n  // 于是可以化简为  // C(n) = 2/n sum(C(k - 1)), k=1,2,...,n  // nC(n) = 2 * sum(C(k-1)), k=1,2,...,n  // 同理有  // (n-1)C(n-1) = 2 * sum(C(k-1)), k = 1,2,...,n-1  // 相减得到递推式  // nC(n) - (n-1)C(n-1) = 2*C(n-1)  // C(n) = (n+1)/n * C(n-1)  // 利用累乘法可以求得通项公式  // C(n)=C(k)*(n+1)/(k+1), n\u0026gt;k  // 对于 C0 有 C0(0)=1, C0(1)=0  // C0(2)=C(0)+C(1)=1  // C0(n)=(n+1)/3, n\u0026gt;2  // 对于 C1 有 C1(0)=0, C1(1)=1  // C1(2)=C1(0)+C1(1)=1  // C1(n)=(n+1)/3, n\u0026gt;2  // 对于 C2 有 C2(0)=C2(1)=0, C2(2)=1  // C2(3)=1/3*2*(C2(0)+C2(1)+C2(2))=2/3  // C2(n)=C2(3)*(n+1)/4=(n+1)/6, n\u0026gt;3  // 结论  // C0(n)=C1(n)=(n+1)/3, C2(n)=(n+1)/6  int n = 1000; QuickSortAnalyze sort = new QuickSortAnalyze(); Console.WriteLine(\u0026#34;n\\t0\\t1\\t2\u0026#34;); for (int i = 0; i \u0026lt; 5; i++) { int[] a = new int[n]; for (int j = 0; j \u0026lt; n; j++) { a[j] = j; } SortCompare.Shuffle(a); sort.Sort(a); Console.WriteLine(n + \u0026#34;\\t\u0026#34; + sort.Array0Num + \u0026#34;\\t\u0026#34; + sort.Array1Num + \u0026#34;\\t\u0026#34; + sort.Array2Num); n *= 2; } } } } 另请参阅 #  Quick 库\nWhat is the expected number of subarrays of size 0, 1 and 2 when quicksort is used to sort an array of N items with distinct keys?-Stack Overflow\n"},{"id":253,"href":"/2-3-8/","title":"2.3.8","section":"帮助","content":"2.3.8 #  解答 #  每次切分都会把数组平分，共切分 logN 次（二分法），每次切分比较 N 次（i 和 j 会一位一位地从两边向中间靠拢）。\n共比较 NlogN 次。\n"},{"id":254,"href":"/2-3-9/","title":"2.3.9","section":"帮助","content":"2.3.9 #  解答 #  切分时，枢轴左侧都是小于（或等于）枢轴的，\n右侧都是大于（或等于）枢轴的\n只有两种主键值时，\n第一次切分之后，某一侧的元素将全部相同\n（如果枢轴选了较大的，那么右侧将全部相同，反之则左侧全部相同）\n只有三种主键值时，和一般快速排序并无不同。\n但如果第一次切分时选择了中间值作为枢轴，且中间值只有一个\n那么只需要一次切分数组便会有序。\n"},{"id":255,"href":"/2-3-10/","title":"2.3.10","section":"帮助","content":"2.3.10 #  解答 #  切比雪夫不等式（Chebyshev’s inequality）\n$$\nP(|X-\\mu|\\geq k\\sigma)\\leq \\frac{1}{k^2}\n$$\n其中，$\\mu$ 代表期望，$\\sigma$ 代表标准差。\n对于快速排序的比较次数来说，$\\mu = 2N\\ln N$ ，$\\sigma=0.65N$。\n（这两个结论见 2.3 节的命题 K 和命题 L）\n题目中要求比较次数大于 $0.1N^2$ ，可以求得 $k$ 的值。\n$$\n0.65kN=0.1N^2 \\\nk=\\frac{2N}{13}\n$$\n将 $N=1,000,000$ 代入\n$$\nP(|X-27,631,021|\\geq 100,000,000,000)\\leq 0.00000000004225\n$$\n另请参阅 #  切比雪夫不等式到底是个什么概念? - 马同学的回答 - 知乎\n"},{"id":256,"href":"/2-3-11/","title":"2.3.11","section":"帮助","content":"2.3.11 #  解答 #  只有若干种元素值意味着大量的连续重复。\n（由于存在打乱这一步骤，不存在连续重复的可能性是很低的）\n接下来我们考虑这样的连续重复在修改后的快排下的性能。\n1 1 1 1 1 1 1\n对于这样的数组，枢轴选为 1，j 将会在 j = lo 处终止。\n因此最后的结果将是每次只有数组的第一个元素被排序\n已知每次切分都是 O(k - 1) 的（i 和 j 都将走完整个子数组）\n因此这样的快速排序所需时间 = $2 (N - 1 + N - 2 + \\cdots + 1) = (N - 1)N$\n因此对于值相同的子数组，这样的快排运行时间是平方级别的\n那么当数组中这样的连续重复内容越多，运行时间就越接近平方级别。\n"},{"id":257,"href":"/2-3-12/","title":"2.3.12","section":"帮助","content":"2.3.12 #  解答 #  "},{"id":258,"href":"/2-3-13/","title":"2.3.13","section":"帮助","content":"2.3.13 #  解答 #  快速排序先将数组分为 （小于枢轴）枢轴（大于枢轴）三部分，然后再分别递归的排序左右两部分数组。\n在这里，我们可以将快速排序的递归树看作是一棵二叉搜索树（BST, Binary Search Tree）。\n枢轴作为根结点，左子树即为左数组构造的 BST，右子树即为右数组构造的 BST。\n这样题目中所求的递归深度即为所构造的 BST 的高度。\n最坏情况，每次都只有枢轴和大于枢轴两部分，BST 退化为链表，高度为 $n-1$。\n最好情况，每次枢轴都正好平分数组，构造一棵完全二叉树，高度为 $\\log n$。\n平均情况，问题转化为：一个由 $n$ 个元素随机构造的 BST 的平均高度是多少？\n《算法导论》给出的结论是 $\\log n$ ，具体证明如下：\n设由 $n$ 个结点随机构成的 BST 的高度为 $h_n$，那么有：\n$$\nh_n=1+\\max(h_{l}+h_{r})\n$$\n其中，$h_l$ 和 $h_r$ 分别代表左数组和右数组构造的 BST 的高度。\n设枢轴位置为 $i$，上式可简化为：\n$$\nh_n=1+\\max(h_{i-1}, h_{n-i})\n$$\n由于枢轴位置可以在 1~n 之间任意取值且概率相等，因此 BST 的平均高度（即高度的期望）为：\n$$\nE(h_n)=\\frac{1}{n}\\sum_{i=1}^{n}\\lbrack 1+\\max(h_{i-1}, h_{n-i}) \\rbrack\n$$\n我们令 $Y_n=2^{h_n}$，可得：\n$$\nY_n=2\\times\\max(Y_{i-1},Y_{n-i})\n$$\n我们把 $Y_n$ 代入，可得：\n$$\n\\begin{aligned}\nE(Y_n)\n\u0026amp;=\\sum_{i=1}^{n}\\frac{1}{n}E\\lbrack2\\times\\max(Y_{i-1}, Y_{n-i})\\rbrack\\\n\u0026amp;=\\frac{2}{n}\\sum_{i=1}^{n}E\\lbrack\\max(Y_{i-1},Y_{n-i})\\rbrack\\\n\\end{aligned}\n$$\n接下来我们去掉最大值运算，根据最大值的性质，下式显然成立：\n$$\nE\\lbrack\\max(X,Y)\\rbrack\\le E\\lbrack\\max(X,Y)+\\min(X,Y)\\rbrack=E\\lbrack X+Y\\rbrack=E\\lbrack X\\rbrack+E\\lbrack Y\\rbrack\n$$\n代入可得：\n$$\nE(Y_n)\n\\le\\frac{2}{n}\\sum_{i=1}^{n}(E\\lbrack Y_{i-1}\\rbrack + E\\lbrack Y_{n-i} \\rbrack)\n=\\frac{2}{n}\\sum_{i=0}^{n-1}2E\\lbrack Y_i\\rbrack\n=\\frac{4}{n}\\sum_{i=0}^{n-1}E\\lbrack Y_i\\rbrack\n$$\n大小为 0 的数组构成的 BST 的高度显然为 0，我们设 $Y_0=0$ 。接下来用一个组合数公式来构造上界：\n$$\n\\begin{align}\n0\u0026amp;=Y_0=E\\lbrack Y_0 \\rbrack\\le \\frac{1}{4}\\begin{pmatrix}3\\3\\end{pmatrix}=\\frac{1}{4}\\\n1\u0026amp;=Y_1=E\\lbrack Y_1 \\rbrack\\le\\frac {1}{4}\\begin{pmatrix}3+1\\3\\end{pmatrix}=1 \\\n\\vdots \\\nY_i \u0026amp;=E\\lbrack Y_i\\rbrack\\le\\frac{1}{4}\\begin{pmatrix}i+3\\3\\end{pmatrix}\n\\end{align}\n$$\n注意这里的组合数公式为：\n$$\n\\begin{pmatrix}n\\r\\end{pmatrix}=\\frac{r!}{r!(n-r)!}\n$$\n代入可得：\n$$\n\\begin{align}\nE(Y_n) \u0026amp;\\le \\frac{4}{n}\\sum_{i=0}^{n-1}E\\lbrack Y_i\\rbrack \\\n\u0026amp;\\le\\frac{4}{n}\\sum_{i=0}^{n-1}\\frac{1}{4}\\begin{pmatrix}i+3\\3\\end{pmatrix} \\\n\u0026amp;=\\frac{1}{n}\\sum_{i=0}^{n-1}\\begin{pmatrix}i+3\\3\\end{pmatrix}\n\\end{align}\n$$\n接下来我们去掉求和符号，首先根据组合数的性质，有以下等式成立\n$$\n\\begin{align}\n\\begin{pmatrix}n\\k\\end{pmatrix}\u0026amp;=\\begin{pmatrix}n-1\\k-1\\end{pmatrix}+\\begin{pmatrix}n-1\\k\\end{pmatrix} \\\n\\begin{pmatrix}n\\n\\end{pmatrix}\u0026amp;=1\n\\end{align}\n$$\n我们把求和式展开得到：\n$$\n\\begin{align}\n\\sum_{i=0}^{n-1}\\begin{pmatrix}i+3\\3\\end{pmatrix}\n\u0026amp;=\\begin{pmatrix}3\\3\\end{pmatrix} + \\begin{pmatrix}4\\3\\end{pmatrix}+\\cdots+\\begin{pmatrix}n+2\\3\\end{pmatrix} \\\n\u0026amp;=\\begin{pmatrix}4\\4\\end{pmatrix} + \\begin{pmatrix}4\\3\\end{pmatrix}+\\cdots+\\begin{pmatrix}n+2\\3\\end{pmatrix} \\\n\u0026amp;=\\begin{pmatrix}n+3\\4\\end{pmatrix}\n\\end{align}\n$$\n代入可得：\n$$\n\\begin{align}\nE(Y_n) \u0026amp;\\le\\frac{1}{n}\\sum_{i=0}^{n-1}\\begin{pmatrix}i+3\\3\\end{pmatrix}\\\n\u0026amp;=\\frac{1}{n}\\begin{pmatrix}n+3\\4 \\end{pmatrix} \\\n\u0026amp;=\\frac{1}{n}\\cdot\\frac{(n+3)!}{4!(n-1)!} \\\n\u0026amp;=\\frac{1}{4}\\cdot\\frac{(n+3)!}{3!n!} \\\n\u0026amp;=\\frac{(n+1)(n+2)(n+3)}{24} \\\n\u0026amp;=\\frac{n^3+6n^2+11n+6}{24}\n\\end{align}\n$$\n由于 $Y_n=2^{h_n}$ ，因此 $E\\lbrack Y_n \\rbrack=E\\lbrack 2^{h_n} \\rbrack$。\n由于 $f(x)=2^x$ 是个凸函数，可以应用延森不等式（凸函数的割线一定在函数上方），即 $2^{E\\lbrack h_n\\rbrack}\\le E\\lbrack Y_n\\rbrack$。\n于是得到结论：\n$$\n2^{E\\lbrack h_n\\rbrack} \\le \\frac{n^3+6n^2+11n+6}{24} \\\nE\\lbrack h_n \\rbrack\\le \\log(\\frac{n^3+6n^2+11n+6}{24})\n$$\n另请参阅 #  快速排序的递归树可以视为 BST 的结论可以在下面这个 PPT 的第 5 页找到。\nQuickSort-纽约大学\n《算法导论》中关于随机 BST 高度的证明（P321 Theorem12.4）\nIntroduction to Algorithms\n也可以参考下面这个链接获得更详细的解释。\nProof that a randomly built binary search tree has logarithmic height-StackExchange\n"},{"id":259,"href":"/2-3-14/","title":"2.3.14","section":"帮助","content":"2.3.14 #  解答 #  中文版题目有误，详见官方勘误页面：https://algs4.cs.princeton.edu/errata/errata-printing3.php\n假设 $ i \u0026lt; j​$ 。\n首先，在快速排序中，如果两个元素要发生交换，意味着其中一个元素被选为枢轴。\n而且数组中的元素各不相同，那么两个特定的元素的比较最多发生一次。\n那么先考虑一个特殊情况，$i = 1, j = n$ ，即求最大值和最小值比较的概率。\n此时，一旦枢轴不是这两个元素之一，\n最大值和最小值会被分到两个不同的子数组，无法发生比较。\n因此在这种特例下第 $i$ 大的元素和第 $j $ 大的元素发生比较的概率为 $\\frac{2}{n} = \\frac{2}{j-i+1}$ 。\n接下来考虑一般情况，如果枢轴选择了第 $i$ 到第 $j$ 大之外的元素，\n那么第 $i$ 大和第 $j$ 大的元素会被分到同一个子数组里，重复上述过程。\n因此我们所求的概率只和从第 $i$ 大到第 $j$ 大之间的元素有关，概率为 $\\frac{2}{j-i+1}$。\n（举个例子，一个箱子里有 2 个红球、1个蓝球和 7 个白球，现在摸球而不放回。\n如果摸到白球可以再摸一次，直到摸到红球或蓝球为止。\n显然在这样的规则下摸到红球或蓝球的概率为 1，即白球对概率没有影响。）\n现在我们已经得到了某两个元素比较的概率 $E(X_{ij})$，接下来我们求每两个元素比较的概率 $E(X)$。\n$$\n\\begin{align}\nE(X)\n\u0026amp;= \\sum_{i=1}^{n}\\sum_{j=i+1}^{n}E(X_{ij})\\\n\u0026amp;=\\sum_{i=1}^{n}2(\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{n-i+1}) \\\n\u0026amp;\u0026lt;2n(\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{n})\n\\end{align}\n$$\n根据调和级数的性质（$\\ln (n) \u0026lt; 1+ \\frac{1}{2}+ \\cdots + \\frac{1}{n} \u0026lt; 1+\\ln(n)$），可以得到结论：\n$$\nE(X) \u0026lt; 2n \\ln(n)\n$$\n另请参阅 #  下面这个链接里的 3.4.2 节给出了解法。\nlect0906 - 卡内基梅隆大学\n如果还是不能理解为什么多次切分不影响概率，可以参考三门问题的解释：\n蒙提霍尔问题 - 维基百科\n蒙提霍尔问题（又称三门问题、山羊汽车问题）的正解是什么？- 知乎\n"},{"id":260,"href":"/2-3-15/","title":"2.3.15","section":"帮助","content":"2.3.15 #  解答 #  事实上只需要修改快速排序的切分方法，分两次进行切分。\n首先选第一个螺母作为枢轴，找到对应的螺丝（$O(n)$）放到第一位，对螺丝数组进行切分。\n然后再用找到的螺丝对螺母数组进行切分。\n螺母类，实现了对螺丝类的 IComparable 接口\n/// \u0026lt;summary\u0026gt; /// 螺母类。 /// \u0026lt;/summary\u0026gt; public class Nut\u0026lt;T\u0026gt; : IComparable\u0026lt;Bolt\u0026lt;T\u0026gt;\u0026gt; where T : IComparable\u0026lt;T\u0026gt; { /// \u0026lt;summary\u0026gt;  /// 螺母的值。  /// \u0026lt;/summary\u0026gt;  public T Value { get; set; } /// \u0026lt;summary\u0026gt;  /// 螺母的构造函数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;螺母的值。\u0026lt;/param\u0026gt;  public Nut(T value) =\u0026gt; this.Value = value; /// \u0026lt;summary\u0026gt;  /// 比较方法，螺母只能和螺丝比较。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;需要比较的螺丝。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int CompareTo(Bolt\u0026lt;T\u0026gt; other) { return this.Value.CompareTo(other.Value); } } 类似的有螺丝类。\n/// \u0026lt;summary\u0026gt; /// 螺丝类。 /// \u0026lt;/summary\u0026gt; public class Bolt\u0026lt;T\u0026gt; : IComparable\u0026lt;Nut\u0026lt;T\u0026gt;\u0026gt; where T : IComparable\u0026lt;T\u0026gt; { /// \u0026lt;summary\u0026gt;  /// 螺丝的值。  /// \u0026lt;/summary\u0026gt;  public T Value { get; set; } /// \u0026lt;summary\u0026gt;  /// 螺丝的默认构造函数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;螺丝的值。\u0026lt;/param\u0026gt;  public Bolt(T value) =\u0026gt; this.Value = value; /// \u0026lt;summary\u0026gt;  /// 比较方法，螺丝只能和螺母比较。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;需要比较的螺母。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int CompareTo(Nut\u0026lt;T\u0026gt; other) { return this.Value.CompareTo(other.Value); } } 代码 #  修改后的排序方法。\nusing System; namespace _2._3._15 { /// \u0026lt;summary\u0026gt;  /// 用快排的方式解决螺母和螺帽的问题。  /// \u0026lt;/summary\u0026gt;  public class BoltsAndNuts { private readonly Random random = new Random(); /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public BoltsAndNuts() { } /// \u0026lt;summary\u0026gt;  /// 对螺丝和螺母排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;bolts\u0026#34;\u0026gt;螺母数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;nuts\u0026#34;\u0026gt;螺丝数组。\u0026lt;/param\u0026gt;  public void Sort\u0026lt;T\u0026gt;(Bolt\u0026lt;T\u0026gt;[] bolts, Nut\u0026lt;T\u0026gt;[] nuts) where T : IComparable\u0026lt;T\u0026gt; { if (bolts.Length != nuts.Length) throw new ArgumentException(\u0026#34;数组长度必须一致\u0026#34;); Shuffle(bolts); Shuffle(nuts); Sort(bolts, nuts, 0, bolts.Length - 1); } /// \u0026lt;summary\u0026gt;  /// 对螺丝和螺母排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;bolts\u0026#34;\u0026gt;螺母数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;nuts\u0026#34;\u0026gt;螺丝数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;终止下标。\u0026lt;/param\u0026gt;  public void Sort\u0026lt;T\u0026gt;(Bolt\u0026lt;T\u0026gt;[] bolts, Nut\u0026lt;T\u0026gt;[] nuts, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) return; int j = Partition(bolts, nuts, lo, hi); Sort(bolts, nuts, lo, j - 1); Sort(bolts, nuts, j + 1, hi); } /// \u0026lt;summary\u0026gt;  /// 对数组进行切分。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;bolts\u0026#34;\u0026gt;螺母数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;nuts\u0026#34;\u0026gt;螺丝数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;终止下标。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;切分位置。\u0026lt;/returns\u0026gt;  private int Partition\u0026lt;T\u0026gt;(Bolt\u0026lt;T\u0026gt;[] bolts, Nut\u0026lt;T\u0026gt;[] nuts, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; Bolt\u0026lt;T\u0026gt; pivotB = bolts[lo]; // 找到对应螺丝  for (int k = lo; k \u0026lt;= hi; k++) { if (nuts[k].CompareTo(pivotB) == 0) { Exch(nuts, k, lo); break; } } // 先用螺母去套螺丝  while (true) { while (nuts[++i].CompareTo(pivotB) \u0026lt; 0) if (i == hi) break; while (pivotB.CompareTo(nuts[--j]) \u0026lt; 0) if (j == lo) break; if (i \u0026gt;= j) break; Exch(nuts, i, j); } Exch(nuts, lo, j); // 再用螺丝去比较螺母  Nut\u0026lt;T\u0026gt; pivotN = nuts[j]; i = lo; j = hi + 1; while (true) { while (bolts[++i].CompareTo(pivotN) \u0026lt; 0) if (i == hi) break; while (pivotN.CompareTo(bolts[--j]) \u0026lt; 0) if (j == lo) break; if (i \u0026gt;= j) break; Exch(bolts, i, j); } Exch(bolts, lo, j); return j; } /// \u0026lt;summary\u0026gt;  /// 打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  private void Shuffle\u0026lt;T\u0026gt;(T[] a) { for (int i = 0; i \u0026lt; a.Length; i++) { int r = i + this.random.Next(a.Length - i); T temp = a[i]; a[i] = a[r]; a[r] = temp; } } /// \u0026lt;summary\u0026gt;  /// 交换两个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要交换的第一个元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;需要交换的第二个元素。\u0026lt;/param\u0026gt;  private void Exch\u0026lt;T\u0026gt;(T[] a, int lo, int hi) { T t = a[lo]; a[lo] = a[hi]; a[hi] = t; } } } 另请参阅 #  下面这个网站给出了这道题的解法，还给出了另一种确定性算法（非随机的算法）的论文链接。\nMatching Nuts and Bolts - Solution\n"},{"id":261,"href":"/2-3-16/","title":"2.3.16","section":"帮助","content":"2.3.16 #  解答 #  官方实现见：https://algs4.cs.princeton.edu/23quicksort/QuickBest.java.html\n类似于快速排序的结构，只要中点的两边都是最佳情况，那么整个数组就是最佳情况了。\n具体方法是：\n首先构造一个有序数组，\n然后找到中点（作为枢轴），\n对中点左右两侧子数组进行构造，\n将选择的枢轴放到开始处(a[lo])。\n代码 #  用于构造最佳数组的类。\nnamespace Quick { /// \u0026lt;summary\u0026gt;  /// 构建快速排序最佳情况的类。  /// \u0026lt;/summary\u0026gt;  public class QuickBest { /// \u0026lt;summary\u0026gt;  /// 构造函数，这个类不应该被实例化。  /// \u0026lt;/summary\u0026gt;  private QuickBest() { } /// \u0026lt;summary\u0026gt;  /// 构造适用于快速排序的最佳数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;数组长度。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static int[] Best(int n) { int[] a = new int[n]; for (int i = 0; i \u0026lt; n; i++) { a[i] = i; } Best(a, 0, n - 1); return a; } /// \u0026lt;summary\u0026gt;  /// 递归的构造数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要构造的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;构造的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;构造的终止下标。\u0026lt;/param\u0026gt;  private static void Best(int[] a, int lo, int hi) { if (hi \u0026lt;= lo) return; int mid = lo + (hi - lo) / 2; Best(a, lo, mid - 1); Best(a, mid + 1, hi); Exch(a, lo, mid); } /// \u0026lt;summary\u0026gt;  /// 交换数组中的两个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;包含要交换元素的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;需要交换的第一个元素下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;y\u0026#34;\u0026gt;需要交换的第二个元素下标。\u0026lt;/param\u0026gt;  private static void Exch(int[] a, int x, int y) { int t = a[x]; a[x] = a[y]; a[y] = t; } } } 用于测试的方法\nusing System; using Quick; namespace _2._3._16 { /* * 2.3.16 * * 最佳情况。 * 编写一段程序来生成使算法 2.5 中的 sort() 方法表现最佳的数组（无重复元素）： * 数组大小为 N 且不包含重复元素， * 每次切分后两个子数组的大小最多差 1 * （子数组的大小与含有 N 个相同元素的数组的切分情况相同）。 * （对于这道练习，我们不需要在排序开始时打乱数组。） * */ class Program { static void Main(string[] args) { QuickSortAnalyze quick = new QuickSortAnalyze { NeedShuffle = false, // 关闭打乱  NeedPath = true // 显示排序轨迹  }; int[] a = QuickBest.Best(10); for (int i = 0; i \u0026lt; 10; i++) { Console.Write(a[i] + \u0026#34; \u0026#34;); } Console.WriteLine(); quick.Sort(a); for (int i = 0; i \u0026lt; 10; i++) { Console.Write(a[i] + \u0026#34; \u0026#34;); } Console.WriteLine(); } } } 另请参阅 #  Quick 库\n"},{"id":262,"href":"/2-3-17/","title":"2.3.17","section":"帮助","content":"2.3.17 #  解答 #  按照题意修改代码即可，在调用 Suffle() 之后添加一段用于寻找最大值的方法（$O(n)$）。\n/// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 进行升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); // 把最大元素放到最后一位  int maxIndex = 0; for (int i = 0; i \u0026lt; a.Length; i++) { if (Less(a[maxIndex], a[i])) maxIndex = i; } Exch(a, maxIndex, a.Length - 1); Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } 代码 #  修改后的快速排序类。\nusing System; using System.Diagnostics; using Quick; namespace _2._3._17 { /// \u0026lt;summary\u0026gt;  /// 快速排序类。  /// \u0026lt;/summary\u0026gt;  public class QuickSortX : BaseSort { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public QuickSortX() { } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 进行升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); // 把最大元素放到最后一位  int maxIndex = 0; for (int i = 0; i \u0026lt; a.Length; i++) { if (Less(a[maxIndex], a[i])) maxIndex = i; } Exch(a, maxIndex, a.Length - 1); Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 的 lo ~ hi 范围排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt;  private void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界  return; int j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt;  /// 对数组进行切分，返回枢轴位置。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt;  private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; T v = a[lo]; while (true) { while (Less(a[++i], v)) ; // if (i == hi)  // break;  while (Less(v, a[--j])) ; // if (j == lo)  // break;  if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt;  /// 打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  private void Shuffle\u0026lt;T\u0026gt;(T[] a) { Random random = new Random(); for (int i = 0; i \u0026lt; a.Length; i++) { int r = i + random.Next(a.Length - i); T temp = a[i]; a[i] = a[r]; a[r] = temp; } } } } 主方法。\nusing System; using Quick; namespace _2._3._17 { /* * 2.3.17 * * 哨兵。 * 修改算法 2.5，去掉内循环 while 中的边界检查。 * 由于切分元素本身就是一个哨兵（v 不可能小于 a[lo]）， * 左侧边界检查是多余的。 * 要去掉另一个检查，可以在打乱数组后将数组的最大元素方法 a[length - 1] 中。 * 该元素永远不会移动（除非和相等的元素交换）， * 可以在所有包含它的子数组中成为哨兵。 * 注意：在处理内部子数组时， * 右子数组中最左侧的元素可以作为左子数组右边界的哨兵。 * */ class Program { static void Main(string[] args) { QuickSort quick = new QuickSort(); QuickSortX quickSortX = new QuickSortX(); int arrayLength = 1000000; int[] a = SortCompare.GetRandomArrayInt(arrayLength); int[] b = new int[arrayLength]; a.CopyTo(b, 0); double time1 = SortCompare.Time(quick, a); double time2 = SortCompare.Time(quickSortX, b); Console.WriteLine(\u0026#34;QSort\\tQSort with Sentinels\\t\u0026#34;); Console.WriteLine(time1 + \u0026#34;\\t\u0026#34; + time2 + \u0026#34;\\t\u0026#34;); } } } 另请参阅 #  Quick 库\n"},{"id":263,"href":"/2-3-18/","title":"2.3.18","section":"帮助","content":"2.3.18 #  解答 #  每次切分时都取前三个元素的中位数作为枢轴，这可以带来约 5%~10% 的性能提升。\n这里通过三次比较将前三个数排序，然后把三个数中的中位数放到数组开头，最大值放到数组末尾。\n最大值被放到了末尾，枢轴不可能大于末尾的这个数，因此右边界判断可以去掉。\n同时由于枢轴不可能小于自身，因此左边界判断也可以去掉。\n这样就可以把切分中的两个边界判断全部去掉了。\n最后对于大小为 2 的数组做特殊处理，通过一次比较直接排序并返回。\n测试结果：\n代码 #  QuickSortMedian3\nusing System; using System.Diagnostics; using Quick; namespace _2._3._18 { /// \u0026lt;summary\u0026gt;  /// 三取样快速排序  /// \u0026lt;/summary\u0026gt;  public class QuickSortMedian3 : BaseSort { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public QuickSortMedian3() {} /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 进行升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 的 lo ~ hi 范围排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt;  private void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界  return; // 只有两个元素的数组直接排序  if (hi == lo + 1) { if (Less(a[hi], a[lo])) Exch(a, lo, hi); return; } int j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt;  /// 对数组进行切分，返回枢轴位置。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt;  private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; if (Less(a[lo + 1], a[lo])) Exch(a, lo + 1, lo); if (Less(a[lo + 2], a[lo])) Exch(a, lo + 2, lo); if (Less(a[lo + 2], a[lo + 1])) Exch(a, lo + 1, lo + 2); Exch(a, lo, lo + 1); // 中位数放最左侧  Exch(a, hi, lo + 2); // 较大的值放最右侧作为哨兵  T v = a[lo]; while (true) { while (Less(a[++i], v)) ; while (Less(v, a[--j])) ; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt;  /// 打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  private void Shuffle\u0026lt;T\u0026gt;(T[] a) { Random random = new Random(); for (int i = 0; i \u0026lt; a.Length; i++) { int r = i + random.Next(a.Length - i); T temp = a[i]; a[i] = a[r]; a[r] = temp; } } } } 测试用例\nusing System; using Quick; namespace _2._3._18 { /* * 2.3.18 * * 三取样切分。 * 为快速排序实现正文所述的三取样切分（参见 2.3.3.2 节）。 * 运行双倍测试来确认这项改动的效果。 * */ class Program { static void Main(string[] args) { QuickSort quickNormal = new QuickSort(); QuickSortMedian3 quickMedian = new QuickSortMedian3(); int arraySize = 200000; // 初始数组大小。  const int trialTimes = 4; // 每次实验的重复次数。  const int trialLevel = 5; // 双倍递增的次数。  Console.WriteLine(\u0026#34;n\\tmedian\\tnormal\\tratio\u0026#34;); for (int i = 0; i \u0026lt; trialLevel; i++) { double timeMedian = 0; double timeNormal = 0; for (int j = 0; j \u0026lt; trialTimes; j++) { int[] a = SortCompare.GetRandomArrayInt(arraySize); int[] b = new int[a.Length]; a.CopyTo(b, 0); timeNormal += SortCompare.Time(quickNormal, b); timeMedian += SortCompare.Time(quickMedian, a); } timeMedian /= trialTimes; timeNormal /= trialTimes; Console.WriteLine(arraySize + \u0026#34;\\t\u0026#34; + timeMedian + \u0026#34;\\t\u0026#34; + timeNormal + \u0026#34;\\t\u0026#34; + timeMedian / timeNormal); arraySize *= 2; } } } } 另请参阅 #  Quick 库\n"},{"id":264,"href":"/2-3-19/","title":"2.3.19","section":"帮助","content":"2.3.19 #  解答 #  主要介绍一下这个少于七次比较的五取样算法。\n首先假设五个数字为 a b c d e\n对 b c 排序，d e 排序。（两次比较）\n比较 b 和 d，把较小那一组换到 b c 的位置上去。（一次比较）\n此时会有 b \u0026lt; c, b \u0026lt; d \u0026lt; e。\n交换 a, b，重新对 b c 排序。（一次比较）\n再次比较 b 和 d，把较小的那一组换到 b c 的位置上。（一次比较）\n最后比较 c 和 d，较小的那一个即为中位数。（一次比较）\n总共需要 6 次比较，严格小于 7 次。\n取样完毕后，a b 是最小值和次小值（这里没有对应关系，a 也可以是次小值）。\nd 和 e 是最大值和次大值（同样没有对应关系）。\n我们把 d 和 e 放到数组的最后作为哨兵，去掉右边界的判断。\n同时让左右两侧指针都向中间移动两位，减少不必要的比较。\n测试结果，对比普通快排性能提升约 10%，和三取样快排区别不大。\n代码 #  五取样快排\nusing System; using System.Diagnostics; using Quick; namespace _2._3._19 { /// \u0026lt;summary\u0026gt;  /// 五取样快速排序  /// \u0026lt;/summary\u0026gt;  public class QuickSortMedian5 : BaseSort { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public QuickSortMedian5() {} /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 进行升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 的 lo ~ hi 范围排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt;  private void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界  return; // 少于五个元素的数组直接进行插入排序  if (hi - lo + 1 \u0026lt; 5) { int n = hi - lo + 1; for (int i = lo; i - lo \u0026lt; n; i++) { for (int k = i; k \u0026gt; 0 \u0026amp;\u0026amp; Less(a[k], a[k - 1]); --k) { Exch(a, k, k - 1); } } return; } int j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt;  /// 对数组进行切分，返回枢轴位置。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt;  private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; // 假设为 a b c d e 五个数字  // 首先对 b c 排序  if (Less(a[lo + 2], a[lo + 1])) Exch(a, lo + 2, lo + 1); // 然后再排序 d e  if (Less(a[lo + 4], a[lo + 3])) Exch(a, lo + 4, lo + 3); // 这时满足 b \u0026lt; c, d \u0026lt; e  // 比较 b d，把较小的一组放到 b c 的位置上去  if (Less(a[lo + 3], a[lo + 1])) { Exch(a, lo + 1, lo + 3); Exch(a, lo + 2, lo + 4); } // 这时满足 b \u0026lt; c, b \u0026lt; d \u0026lt; e，即 b 是 b c d e 中的最小值  // 交换 a 和 b  Exch(a, lo, lo + 1); // 重新排序 b c  if (Less(a[lo + 2], a[lo + 1])) Exch(a, lo + 2, lo + 1); // 这时再次满足 b \u0026lt; c, d \u0026lt; e  // 比较 b d，把最小的一组放到 b c 的位置上去  if (Less(a[lo + 3], a[lo + 1])) { Exch(a, lo + 1, lo + 3); Exch(a, lo + 2, lo + 4); } // 这时 a 和 b 为五个数中的最小值和次小值（顺序不固定，a 也可以是次小值）  // 最后比较 c 和 d，较小的那一个即为中位数（即第三小的数）  if (Less(a[lo + 3], a[lo + 2])) Exch(a, lo + 3, lo + 2); // 此时 c 即为中位数  Exch(a, lo, lo + 2); // d e 放到数组末尾充当哨兵  Exch(a, lo + 3, hi); Exch(a, lo + 4, hi - 1); // 调整指针位置，前两位和后两位都已经在合适位置了  j -= 2; i += 2; T v = a[lo]; while (true) { while (Less(a[++i], v)) ; while (Less(v, a[--j])) ; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt;  /// 打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  private void Shuffle\u0026lt;T\u0026gt;(T[] a) { Random random = new Random(); for (int i = 0; i \u0026lt; a.Length; i++) { int r = i + random.Next(a.Length - i); T temp = a[i]; a[i] = a[r]; a[r] = temp; } } } } 三取样快排\nusing System; using System.Diagnostics; using Quick; namespace _2._3._19 { /// \u0026lt;summary\u0026gt;  /// 三取样快速排序  /// \u0026lt;/summary\u0026gt;  public class QuickSortMedian3 : BaseSort { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public QuickSortMedian3() {} /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 进行升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 的 lo ~ hi 范围排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt;  private void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界  return; // 少于五个元素的数组直接进行插入排序  if (hi - lo + 1 \u0026lt; 5) { int n = hi - lo + 1; for (int i = lo; i - lo \u0026lt; n; i++) { for (int k = i; k \u0026gt; 0 \u0026amp;\u0026amp; Less(a[k], a[k - 1]); --k) { Exch(a, k, k - 1); } } return; } int j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt;  /// 对数组进行切分，返回枢轴位置。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt;  private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; if (Less(a[lo + 1], a[lo])) Exch(a, lo + 1, lo); if (Less(a[lo + 2], a[lo])) Exch(a, lo + 2, lo); if (Less(a[lo + 2], a[lo + 1])) Exch(a, lo + 1, lo + 2); Exch(a, lo, lo + 1); // 中位数放最左侧  Exch(a, hi, lo + 2); // 较大的值放最右侧作为哨兵  T v = a[lo]; while (true) { while (Less(a[++i], v)) ; while (Less(v, a[--j])) ; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt;  /// 打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  private void Shuffle\u0026lt;T\u0026gt;(T[] a) { Random random = new Random(); for (int i = 0; i \u0026lt; a.Length; i++) { int r = i + random.Next(a.Length - i); T temp = a[i]; a[i] = a[r]; a[r] = temp; } } } } 测试用例\nusing System; using Quick; namespace _2._3._19 { /* * 2.3.19 * * 五取样切分。 * 实现一种基于随机抽取子数组中 5 个元素并取中位数进行切分的快速排序。 * 将取样元素放在数组的一侧以保证只有中位数元素参与了切分。 * 运行双倍测试来确定这项改动的效果， * 并和标准的快速排序以及三取样的快速排序（请见上一道练习）进行比较。 * 附加题：找到一种对于任意输入都只需要少于 7 次比较的五取样算法。 * */ class Program { static void Main(string[] args) { QuickSort quickNormal = new QuickSort(); QuickSortMedian3 quickMedian3 = new QuickSortMedian3(); QuickSortMedian5 quickMedian5 = new QuickSortMedian5(); int arraySize = 200000; // 初始数组大小。  const int trialTimes = 4; // 每次实验的重复次数。  const int trialLevel = 6; // 双倍递增的次数。  Console.WriteLine(\u0026#34;n\\tmedian5\\tmedian3\\tnormal\\tmedian5/normal\\t\\tmedian5/median3\u0026#34;); for (int i = 0; i \u0026lt; trialLevel; i++) { double timeMedian3 = 0; double timeMedian5 = 0; double timeNormal = 0; for (int j = 0; j \u0026lt; trialTimes; j++) { int[] a = SortCompare.GetRandomArrayInt(arraySize); int[] b = new int[a.Length]; int[] c = new int[a.Length]; a.CopyTo(b, 0); a.CopyTo(c, 0); timeNormal += SortCompare.Time(quickNormal, a); timeMedian3 += SortCompare.Time(quickMedian3, b); timeMedian5 += SortCompare.Time(quickMedian5, c); } timeMedian5 /= trialTimes; timeMedian3 /= trialTimes; timeNormal /= trialTimes; Console.WriteLine(arraySize + \u0026#34;\\t\u0026#34; + timeMedian5 + \u0026#34;\\t\u0026#34; + timeMedian3 + \u0026#34;\\t\u0026#34; + timeNormal + \u0026#34;\\t\u0026#34; + timeMedian5 / timeNormal + \u0026#34;\\t\u0026#34; + timeMedian5/timeMedian3); arraySize *= 2; } } } } 另请参阅 #  Quick 库\nCode to calculate “median of five” in C#\n"},{"id":265,"href":"/2-3-20/","title":"2.3.20","section":"帮助","content":"2.3.20 #  解答 #  事实上就是用一个栈保存每次切分后的子数组下标。\n关键代码如下：\n/// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 进行升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); Stack\u0026lt;int\u0026gt; stack = new Stack\u0026lt;int\u0026gt;(); stack.Push(0); stack.Push(a.Length - 1); while (stack.Count != 0) { // 压入顺序是先 lo，再 hi，故弹出顺序是先 hi 再 lo  int hi = stack.Pop(); int lo = stack.Pop(); if (hi \u0026lt;= lo) continue; int j = Partition(a, lo, hi); // 让较大的子数组先入栈（先排序较小的子数组）  if (j - lo \u0026gt; hi - j) { stack.Push(lo); stack.Push(j - 1); stack.Push(j + 1); stack.Push(hi); } else { stack.Push(j + 1); stack.Push(hi); stack.Push(lo); stack.Push(j - 1); } } Debug.Assert(IsSorted(a)); } 由于栈操作比函数调用操作耗费时间更长，因此测试后的结果会比原有快排慢一些。\n代码 #  QuickSortNonRecursive\nusing System; using System.Diagnostics; using Quick; namespace _2._3._20 { /// \u0026lt;summary\u0026gt;  /// 快速排序类。  /// \u0026lt;/summary\u0026gt;  public class QuickSortNonRecursive : BaseSort { /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public QuickSortNonRecursive() { } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 进行升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); Stack\u0026lt;int\u0026gt; stack = new Stack\u0026lt;int\u0026gt;(); stack.Push(0); stack.Push(a.Length - 1); while (stack.Count != 0) { // 压入顺序是先 lo，再 hi，故弹出顺序是先 hi 再 lo  int hi = stack.Pop(); int lo = stack.Pop(); if (hi \u0026lt;= lo) continue; int j = Partition(a, lo, hi); // 让较大的子数组先入栈（先排序较小的子数组）  if (j - lo \u0026gt; hi - j) { stack.Push(lo); stack.Push(j - 1); stack.Push(j + 1); stack.Push(hi); } else { stack.Push(j + 1); stack.Push(hi); stack.Push(lo); stack.Push(j - 1); } } Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 对数组进行切分，返回枢轴位置。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt;  private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; T v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt;  /// 打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  private void Shuffle\u0026lt;T\u0026gt;(T[] a) { Random random = new Random(); for (int i = 0; i \u0026lt; a.Length; i++) { int r = i + random.Next(a.Length - i); T temp = a[i]; a[i] = a[r]; a[r] = temp; } } } } 测试用例\nusing System; using Quick; namespace _2._3._20 { /* * 2.3.20 * * 非递归的快速排序。 * 实现一个非递归的快速排序， * 使用一个循环来将弹出栈的子数组切分并将结果子数组重新压入栈。 * 注意： * 先将较大的子数组压入栈，这样就可以保证栈最多只会有 lgN 个元素。 * */ class Program { static void Main(string[] args) { QuickSort quickNormal = new QuickSort(); QuickSortNonRecursive quickNonRecursive = new QuickSortNonRecursive(); int arraySize = 200000; // 初始数组大小。  const int trialTimes = 4; // 每次实验的重复次数。  const int trialLevel = 5; // 双倍递增的次数。  Console.WriteLine(\u0026#34;n\\tnon-recursive\\tnormal\\tratio\u0026#34;); for (int i = 0; i \u0026lt; trialLevel; i++) { double timeRecursive = 0; double timeNormal = 0; for (int j = 0; j \u0026lt; trialTimes; j++) { int[] a = SortCompare.GetRandomArrayInt(arraySize); int[] b = new int[a.Length]; a.CopyTo(b, 0); timeNormal += SortCompare.Time(quickNormal, b); timeRecursive += SortCompare.Time(quickNonRecursive, a); } timeRecursive /= trialTimes; timeNormal /= trialTimes; Console.WriteLine(arraySize + \u0026#34;\\t\u0026#34; + timeRecursive + \u0026#34;\\t\\t\u0026#34; + timeNormal + \u0026#34;\\t\u0026#34; + timeRecursive / timeNormal); arraySize *= 2; } } } } 另请参阅 #  Quick 库\n"},{"id":266,"href":"/2-3-21/","title":"2.3.21","section":"帮助","content":"2.3.21 #  解答 #  首先引入命题 I 的结论，对于互不相同的主键值，基于比较的排序算法的下界等于所形成的比较树的高度，即：\n$$\nh \\ge \\log_2{N!}\n$$\n那么我们题目即可转化为求证\n$$\nh \\ge \\log_2 (\\frac{N!}{f_1!f_2!\\cdots f_k!}) \\ge \\log_2 N!\n$$\n这里的 $f_i$ 为某个主键值出现的频率，即某个主键值出现的次数，因此 $f_i\\ge 1$ 。\n根据题目给出的条件，如果主键互不重复，此时 $k=N$，且 $f_1=f_2=\\cdots=f_k=1$ 。\n那么 $f_1!f_2!\\cdots f_k!=1$ ，待证式子即为命题 I 的结论。\n那么当主键有重复时，此时 $k \u0026lt; N$，为使 $f_1+f_2+ \\cdots + f_k=N$ ，至少存在一个 $f_m \\ge 2$。\n故此时：\n$$\nf_1!f_2!\\cdots f_k! \u0026gt;1\\Rightarrow \\frac{N!}{f_1!f_2!\\cdots f_k!}\u0026lt;N! \\Rightarrow \\\nh \\ge \\log_2 (\\frac{N!}{f_1!f_2!\\cdots f_k!}) \\ge \\log_2 N! \\ \\blacksquare\n$$\n得证。\n另请参阅 #  lower bounds of sorting-The University of Maryland\n"},{"id":267,"href":"/2-3-22/","title":"2.3.22","section":"帮助","content":"2.3.22 #  解答 #  官方实现见：https://algs4.cs.princeton.edu/23quicksort/QuickBentleyMcIlroy.java.html\n快速三向切分 #  论文引用见「另请参阅」部分。\n算法演示\nNinther 算法 #  官方实现中用到了 Ninther 算法用于选取近似中位数（作为枢轴），\n该算法由 John Tukey 在 1978 年提出，论文引用见「另请参阅」部分。\n这个算法的思想其实很简单，假设我们有三个数 $y_1, y_2, y_3$ ，那么其中位数为：\n$$\ny_A= {\\rm median}\\lbrace y_1,y_2,y_3 \\rbrace\n$$\n现在对于九个数，我们以三个为一组，取三个中位数：\n$$\ny_A= {\\rm median}\\lbrace y_1,y_2,y_3 \\rbrace \\\ny_B= {\\rm median}\\lbrace y_4,y_5,y_6 \\rbrace \\\ny_C= {\\rm median}\\lbrace y_7,y_8,y_9 \\rbrace\n$$\n接下来取这三个中位数的中位数，有：\n$$\ny_E= {\\rm median}\\lbrace y_A,y_B,y_C \\rbrace\n$$\n我们把上述过程封装成函数，即 $y_E= {\\rm ninther}\\lbrace y_1,y_2,\\cdots,y_9 \\rbrace$ 。\n于是我们获得的 $y_E$ 即为近似中位数，如果 $\\lbrace y_1,y_2,\\cdots,y_9 \\rbrace$ 是单调数列，那么 $y_E$ 就是中位数。\n获取三个数中的中位数 #  事实上，我们可以直接画出三个数排列的所有可能，获得决策树。\n然后根据决策树写出取中位数的算法：\nprivate int Median3\u0026lt;T\u0026gt;(T[] a, int i, int j, int k) where T : IComparable\u0026lt;T\u0026gt; { return (Less(a[i], a[j]) ? (Less(a[j], a[k]) ? j : Less(a[i], a[k]) ? k : i) : (Less(a[k], a[j]) ? j : Less(a[k], a[i]) ? k : i)); } 测试结果 #  提高约 20% 左右的性能。\n代码 #  QuickBentleyMcIlroy\nusing System; using System.Diagnostics; namespace Quick { public class QuickBentleyMcIlroy : BaseSort { /// \u0026lt;summary\u0026gt;  /// 小于这个数值的数组调用插入排序。  /// \u0026lt;/summary\u0026gt;  private readonly int INSERTION_SORT_CUTOFF = 8; /// \u0026lt;summary\u0026gt;  /// 小于这个数值的数组调用中位数作为枢轴。  /// \u0026lt;/summary\u0026gt;  private readonly int MEDIAN_OF_3_CUTOFF = 40; /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public QuickBentleyMcIlroy() { } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 进行升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 对指定范围内的数组进行排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序的终止下标。\u0026lt;/param\u0026gt;  private void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int n = hi - lo + 1; if (n \u0026lt;= this.INSERTION_SORT_CUTOFF) { InsertionSort(a, lo, hi); return; } else if (n \u0026lt;= this.MEDIAN_OF_3_CUTOFF) { // 对于较小的数组，直接选择左中右三个元素中的中位数作为枢轴。  int m = Median3(a, lo, lo + n / 2, hi); Exch(a, m, lo); } else { // 对于较大的数组使用 Turkey Ninther 作为枢轴。  int eps = n / 8; int mid = lo + n / 2; int m1 = Median3(a, lo, lo + eps, lo + eps + eps); int m2 = Median3(a, mid - eps, mid, mid + eps); int m3 = Median3(a, hi - eps - eps, hi - eps, hi); int ninther = Median3(a, m1, m2, m3); Exch(a, ninther, lo); } // 三向切分  int i = lo, j = hi + 1; int p = lo, q = hi + 1; T v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i == j \u0026amp;\u0026amp; IsEqual(a[i], v)) Exch(a, ++p, i); if (i \u0026gt;= j) break; Exch(a, i, j); if (IsEqual(a[i], v)) Exch(a, ++p, i); if (IsEqual(a[j], v)) Exch(a, --q, j); } i = j + 1; for (int k = lo; k \u0026lt;= p; k++) Exch(a, k, j--); for (int k = hi; k \u0026gt;= q; k--) Exch(a, k, i++); Sort(a, lo, j); Sort(a, i, hi); } /// \u0026lt;summary\u0026gt;  /// 判断两个元素是否值相等。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要判断的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;进行比较的第一个元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;进行比较的第二个元素。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;两个元素的值是否相等。\u0026lt;/returns\u0026gt;  private bool IsEqual\u0026lt;T\u0026gt;(T a, T b) where T : IComparable\u0026lt;T\u0026gt; { return a.CompareTo(b) == 0; } /// \u0026lt;summary\u0026gt;  /// 用插入排序对指定范围内的数组排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序的终止下标。\u0026lt;/param\u0026gt;  private void InsertionSort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { for (int i = lo; i \u0026lt;= hi; i++) { for (int j = i; j \u0026gt; lo \u0026amp;\u0026amp; Less(a[j], a[j - 1]); j--) { Exch(a, j, j - 1); } } } /// \u0026lt;summary\u0026gt;  /// 获取三个元素中的中位数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;用于排序的元素。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;第一个待选元素的下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;第二个待选元素的下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;第三个待选元素的下标。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private int Median3\u0026lt;T\u0026gt;(T[] a, int i, int j, int k) where T : IComparable\u0026lt;T\u0026gt; { return (Less(a[i], a[j]) ? (Less(a[j], a[k]) ? j : Less(a[i], a[k]) ? k : i) : (Less(a[k], a[j]) ? j : Less(a[k], a[i]) ? k : i)); } } } 测试用例\nusing System; using Quick; namespace _2._3._22 { /* * 2.3.22 * * 快速三向切分。（J.Bently，D.McIlroy） * 用将重复元素放置于子数组两端的方式实现一个信息量最优的排序算法。 * 使用两个索引 p 和 q，使得 a[lo...p-1] 和 a[q+1..hi] 的元素都和 a[lo] 相等。 * 使用另外两个索引 i 和 j， * 使得 a[p...i-1] 小于 a[lo]，a[j+i..q] 大于 a[lo]。 * 在内循环中加入代码，在 a[i] 和 v 相当时将其与 a[p] 交换（并将 p 加 1）， * 在 a[j] 和 v 相等且 a[i] 和 a[j] 尚未和 v 进行比较之前将其与 a[q] 交换。 * 添加在切分循环结束后将和 v 相等的元素交换到正确位置的代码，如图 2.3.6 所示。 * 请注意： * 这里实现的代码和正文中给出的代码时等价的， * 因为这里额外的交换用于和切分元素相等的元素， * 而正文中的代码将额外的交换用于和切分元素不等的元素。 * */ class Program { static void Main(string[] args) { QuickSort quickNormal = new QuickSort(); QuickBentleyMcIlroy quickBentleyMcIlroy = new QuickBentleyMcIlroy(); int arraySize = 800000; // 初始数组大小。  const int trialTimes = 1; // 每次实验的重复次数。  const int trialLevel = 8; // 双倍递增的次数。  Console.WriteLine(\u0026#34;n\\t\\t3way\\tnormal\\tratio\u0026#34;); for (int i = 0; i \u0026lt; trialLevel; i++) { double timeBentleyMcIlroy = 0; double timeNormal = 0; for (int j = 0; j \u0026lt; trialTimes; j++) { int[] a = SortCompare.GetRandomArrayInt(arraySize); int[] b = new int[a.Length]; a.CopyTo(b, 0); timeNormal += SortCompare.Time(quickNormal, b); timeBentleyMcIlroy += SortCompare.Time(quickBentleyMcIlroy, a); } timeBentleyMcIlroy /= trialTimes; timeNormal /= trialTimes; if (arraySize \u0026lt; 10000000) Console.WriteLine(arraySize + \u0026#34;\\t\\t\u0026#34; + timeBentleyMcIlroy + \u0026#34;\\t\u0026#34; + timeNormal + \u0026#34;\\t\u0026#34; + timeBentleyMcIlroy / timeNormal); else Console.WriteLine(arraySize + \u0026#34;\\t\u0026#34; + timeBentleyMcIlroy + \u0026#34;\\t\u0026#34; + timeNormal + \u0026#34;\\t\u0026#34; + timeBentleyMcIlroy / timeNormal); arraySize *= 2; } } } } 另请参阅 #  有关这种快速排序算法的来源以及三个数的中位数的选取算法，请参阅下面这篇 1993 年的论文：\nBentley J L, McIlroy M D. Engineering a sort function[J]. Software: Practice and Experience, 1993, 23(11): 1249-1265.\n下面这份 2002 年的 PPT 详细解释和分析了官方实现代码的思路和性能：\nSedgewick R, Bentley J. Quicksort is optimal[J]. Knuthfest, Stanford University, Stanford, 2002.\n有关选取中位数 Ninther 算法，请参阅下面这篇 1978 年的论文：\nTukey J W. The ninther, a technique for low-effort robust (resistant) location in large samples[M]//Contributions to Survey Sampling and Applied Statistics. 1978: 251-257.\n以及按照惯例给出本题用到的类库链接：\nQuick 库\n"},{"id":268,"href":"/2-3-23/","title":"2.3.23","section":"帮助","content":"2.3.23 #  解答 #  官方实现见：https://algs4.cs.princeton.edu/23quicksort/QuickBentleyMcIlroy.java.html\n见 2.3.22 的解答，其中已经包含了这些改动。\n代码 #  QuickBentleyMcIlroy\nusing System; using System.Diagnostics; namespace Quick { public class QuickBentleyMcIlroy : BaseSort { /// \u0026lt;summary\u0026gt;  /// 小于这个数值的数组调用插入排序。  /// \u0026lt;/summary\u0026gt;  private readonly int INSERTION_SORT_CUTOFF = 8; /// \u0026lt;summary\u0026gt;  /// 小于这个数值的数组调用中位数作为枢轴。  /// \u0026lt;/summary\u0026gt;  private readonly int MEDIAN_OF_3_CUTOFF = 40; /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public QuickBentleyMcIlroy() { } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 进行升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 对指定范围内的数组进行排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序的终止下标。\u0026lt;/param\u0026gt;  private void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int n = hi - lo + 1; if (n \u0026lt;= this.INSERTION_SORT_CUTOFF) { InsertionSort(a, lo, hi); return; } else if (n \u0026lt;= this.MEDIAN_OF_3_CUTOFF) { // 对于较小的数组，直接选择左中右三个元素中的中位数作为枢轴。  int m = Median3(a, lo, lo + n / 2, hi); Exch(a, m, lo); } else { // 对于较大的数组使用 Turkey Ninther 作为枢轴。  int eps = n / 8; int mid = lo + n / 2; int m1 = Median3(a, lo, lo + eps, lo + eps + eps); int m2 = Median3(a, mid - eps, mid, mid + eps); int m3 = Median3(a, hi - eps - eps, hi - eps, hi); int ninther = Median3(a, m1, m2, m3); Exch(a, ninther, lo); } // 三向切分  int i = lo, j = hi + 1; int p = lo, q = hi + 1; T v = a[lo]; while (true) { while (Less(a[++i], v)) ; while (Less(v, a[--j])) if (j == lo) break; if (i == j \u0026amp;\u0026amp; IsEqual(a[i], v)) Exch(a, ++p, i); if (i \u0026gt;= j) break; Exch(a, i, j); if (IsEqual(a[i], v)) Exch(a, ++p, i); if (IsEqual(a[j], v)) Exch(a, --q, j); } i = j + 1; for (int k = lo; k \u0026lt;= p; k++) Exch(a, k, j--); for (int k = hi; k \u0026gt;= q; k--) Exch(a, k, i++); Sort(a, lo, j); Sort(a, i, hi); } /// \u0026lt;summary\u0026gt;  /// 判断两个元素是否值相等。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要判断的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;进行比较的第一个元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;进行比较的第二个元素。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;两个元素的值是否相等。\u0026lt;/returns\u0026gt;  private bool IsEqual\u0026lt;T\u0026gt;(T a, T b) where T : IComparable\u0026lt;T\u0026gt; { return a.CompareTo(b) == 0; } /// \u0026lt;summary\u0026gt;  /// 用插入排序对指定范围内的数组排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序的终止下标。\u0026lt;/param\u0026gt;  private void InsertionSort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { for (int i = lo; i \u0026lt;= hi; i++) { for (int j = i; j \u0026gt; lo \u0026amp;\u0026amp; Less(a[j], a[j - 1]); j--) { Exch(a, j, j - 1); } } } /// \u0026lt;summary\u0026gt;  /// 获取三个元素中的中位数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;用于排序的元素。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;第一个待选元素的下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;第二个待选元素的下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;第三个待选元素的下标。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private int Median3\u0026lt;T\u0026gt;(T[] a, int i, int j, int k) where T : IComparable\u0026lt;T\u0026gt; { return (Less(a[i], a[j]) ? (Less(a[j], a[k]) ? j : Less(a[i], a[k]) ? k : i) : (Less(a[k], a[j]) ? j : Less(a[k], a[i]) ? k : i)); } } } 另请参阅 #  Quick 库\n"},{"id":269,"href":"/2-3-24/","title":"2.3.24","section":"帮助","content":"2.3.24 #  解答 #  取样排序的想法很简单：\n常规快排的枢轴只有一个。\n如果用一个数组来充当枢轴，根据排序位置的不同自动选择对应的枢轴，\n显然能够更好的估计中位数，以求更好的切分效果。\n于是引入了「取样」的概念，假如我们从源数组中随机取了 3 个元素并对其排序，\n那么这 3 个元素的中位数可以作为第一次切分的枢轴，剩余两个元素则可以充当切分后两个子数组的枢轴。\n那么当取样元素到达一个合适的数量时，就能达到提升切分效率的目标。\n大致思路如下：\n首先先从输入数组里随机取一些元素，作为「取样数组」。\n用任意排序算法（比如快排）对取样数组进行排序。\n（由于取样数组通常都比较小，这一步的时间消耗通常不会影响性能）\n取出取样数组里面的中位数，当作枢轴对剩下的数组进行切分。\n之后的切分中，根据排序区间在剩余数组中的相对位置，\n用取样数组中对应位置的数作为枢轴，直到整个排序完成。\n论文里提到了两种实现方式。\n第一种方法\n取样数组和剩余数组是分开保存的。\n每次切分完成后，并不把枢轴放入剩余数组中，\n而是等到剩余数组全部排序完毕之后再用一次归并（merge）操作将取样数组和剩余数组归并。\n第二种方法\n取样数组和剩余数组保存在同一片空间里，这也是这份题解所实现的方法。\n在打乱输入数组之后，取前 2^k-1 个元素作为取样数组，用快排对其排序。\n然后把取样数组的后半部分放到整个数组的末尾。\n这样操作的结果是输入数组分为了四个部分：\n有序的取样数组、取样数组的中位数、无序的剩余数组、有序的取样数组。\n中位数则位于第一部分的末尾，我们将其作为枢轴对剩余数组进行切分，数组变为：\n有序的取样数组、小于中位数的部分、枢轴、大于中位数的部分、有序的取样数组\n接下来我们再对第一个部分取半，放到中位数之前；对最后一部分取半，放到中位数之后：\n0 ~ 1/4 取样数组、小于中位数、1/4 ~ 1/2 取样数组、枢轴、1/2~3/4 取样数组、大于中位数、3/4~1 取样数组\n你会发现枢轴前后又分别变回了初始条件，递归执行上述操作，便能对整个数组排序。\n注意当取样数组用完的时候，直接变回普通的快排。\n现代的取样排序\n这里的「现代」并不意味着更好，只是让取样排序能更好的适应多线程排序。\n首先仍然是取样，取样的数量往往取决于线程的数量，比如说取了 p-1 个，就将数组分为 p 份。\n对取样数组进行排序，获得 p 个区间（桶）。\n遍历输入的数组，把元素扔到相应的桶里面。\n把每个桶和对应的枢轴送到对应的线程进行排序。\n汇总各个桶中的结果，排序完毕。\n测试结果：\n大概能提升 5%~10% 的性能。\n代码 #  using System; using System.Diagnostics; namespace Quick { /// \u0026lt;summary\u0026gt;  /// 取样排序类。  /// \u0026lt;/summary\u0026gt;  public class SampleSort : QuickSort { /// \u0026lt;summary\u0026gt;  /// 取样数组长度 2^k - 1 的阶数。  /// \u0026lt;/summary\u0026gt;  public int K { get; set; } /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public SampleSort() { this.K = 8; } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 进行升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { if (a.Length \u0026lt; Math.Pow(2, this.K + 1)) { // 小于 2^(k+1) 的数组直接进行快排  base.Sort(a); return; } Shuffle(a); int samplehi = (int)Math.Pow(2, this.K) - 2; // 利用快速排序对取样数组进行排序  base.Sort(a, 0, samplehi); // 找到取样数组的中位数  int sampleMedian = samplehi / 2; // 将取样数组后半部分放到数组末尾  int i = samplehi, j = a.Length - 1; while (i != sampleMedian) Exch(a, i--, j--); // 根据取样数组进行排序  Sort(a, 0, sampleMedian, j, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 的 lo ~ hi 范围排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;samplelo\u0026#34;\u0026gt;取样数组的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;samplehi\u0026#34;\u0026gt;取样数组的终止下标。\u0026lt;/param\u0026gt;  private void Sort\u0026lt;T\u0026gt;(T[] a, int samplelo, int lo, int hi, int samplehi) where T : IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界  return; int j = Partition(a, lo, hi); // 将前部的有序取样数组取半，后半部分放在枢轴前面。  if (lo - samplelo \u0026gt; 1) { // p 应该始终指向有序部分的最后一项  // v 应该始终指向有序部分的前面一项  int p = lo - 1, v = j - 1; for (int i = 0; i \u0026lt; (lo - samplelo) / 2; i++) { Exch(a, p--, v--); } Sort(a, samplelo, p, v, j - 1); } else { // 取样数组已经用完，退化为普通 Quicksort  base.Sort(a, samplelo, j - 1); } // 将尾部有序取样数组取半，前半部分放在枢轴后面。  if (samplehi - hi \u0026gt; 1) { // p 应该始终指向有序部分的前面一项  // v 应该始终指向有序部分的最后一项  int p = hi, v = j; for (int i = 0; i \u0026lt; (samplehi - hi) / 2; i++) { Exch(a, ++p, ++v); } Sort(a, j + 1, v, p, samplehi); } else { // 取样数组已用完，退化为普通 Quicksort  base.Sort(a, j + 1, samplehi); } } /// \u0026lt;summary\u0026gt;  /// 对数组进行切分，返回枢轴位置。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt;  private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; T v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt;  /// 打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  private void Shuffle\u0026lt;T\u0026gt;(T[] a) { Random random = new Random(); for (int i = 0; i \u0026lt; a.Length; i++) { int r = i + random.Next(a.Length - i); T temp = a[i]; a[i] = a[r]; a[r] = temp; } } } } 测试用例：\nusing System; using Quick; namespace _2._3._24 { /* * 2.3.24 * * 取样排序。（W.Frazer，A.McKellar） * 实现一个快速排序， * 取样大小为 2^k-1。首先将取样得到的元素排序， * 然后在递归函数中使用样品的中位数切分。 * 分为两部分的其余样品元素无需再次排序并可以分别应用于原数组的两个子数组。 * 这种算法称为取样排序。 * */ class Program { static void Main(string[] args) { QuickSort quickNormal = new QuickSort(); SampleSort sampleSort = new SampleSort(); int arraySize = 1600000; // 初始数组大小。  const int kSteps = 10; // 取样 k 值的递增次数。  const int trialTimes = 1; // 每次实验的重复次数。  const int trialLevel = 2; // 双倍递增的次数。  Console.WriteLine(\u0026#34;k\\tn\\t\\tsample\\tnormal\\tratio\u0026#34;); for (int i = 0; i \u0026lt; kSteps; i++) { int array = arraySize; for (int j = 0; j \u0026lt; trialLevel; j++) { double timeSample = 0; double timeNormal = 0; for (int k = 0; k \u0026lt; trialTimes; k++) { int[] a = SortCompare.GetRandomArrayInt(array); int[] b = new int[a.Length]; a.CopyTo(b, 0); timeNormal += SortCompare.Time(quickNormal, b); timeSample += SortCompare.Time(sampleSort, a); } timeSample /= trialTimes; timeNormal /= trialTimes; if (arraySize \u0026lt; 10000000) Console.WriteLine(sampleSort.K + \u0026#34;\\t\u0026#34; + array + \u0026#34;\\t\\t\u0026#34; + timeSample + \u0026#34;\\t\u0026#34; + timeNormal + \u0026#34;\\t\u0026#34; + timeSample / timeNormal); else Console.WriteLine(sampleSort.K + \u0026#34;\\t\u0026#34; + array + \u0026#34;\\t\u0026#34; + timeSample + \u0026#34;\\t\u0026#34; + timeNormal + \u0026#34;\\t\u0026#34; + timeSample / timeNormal); array *= 2; } sampleSort.K++; } } } } 另请参阅 #  关于取样排序的论文（1970 年）：\nFrazer W D, McKellar A C. Samplesort: A sampling approach to minimal storage tree sorting[J]. Journal of the ACM (JACM), 1970, 17(3): 496-507.\n维基百科中的取样排序：\nSamplesort-Wikipedia\n本题用到的类库链接：\nQuick 库\n"},{"id":270,"href":"/2-3-25/","title":"2.3.25","section":"帮助","content":"2.3.25 #  解答 #  切换到插入排序的实现比较简单，在类内添加一个成员变量 M，在 Sort 方法里添加如下代码：\nprotected void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界  return; if (hi - lo \u0026lt;= this.M) { // 调用插入排序  for (int i = lo; i \u0026lt;= hi; i++) for (int k = i; k \u0026gt; lo \u0026amp;\u0026amp; Less(a[k], a[k - 1]); k--) Exch(a, k, k - 1); return; } int j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } 下面放上实验结果：\nN=1000\nN=10000\nN=100000\nN=1000000\n小于 8 的 M 值会比较合适。\n代码 #  这里使用了 Background Worker 来防止程序失去响应，更多信息可以看 「另请参阅」部分。\nusing System; using System.ComponentModel; using System.Drawing; using System.Linq; using System.Windows.Forms; using Quick; namespace _2._3._25 { public partial class Form2 : Form { /// \u0026lt;summary\u0026gt;  /// 测试数组大小。  /// \u0026lt;/summary\u0026gt;  public int N = 100; public Form2(int n) { InitializeComponent(); this.N = n; } /// \u0026lt;summary\u0026gt;  /// 启动页面时启动后台测试。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  private void Form2_Shown(object sender, EventArgs e) { this.Text = \u0026#34;正在绘图\u0026#34;; this.backgroundWorker1.RunWorkerAsync(); } /// \u0026lt;summary\u0026gt;  /// 后台测试方法。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  private void backgroundWorker1_DoWork(object sender, DoWorkEventArgs e) { BackgroundWorker worker = sender as BackgroundWorker; QuickSortInsertion quickSortInsertion = new QuickSortInsertion(); double[] timeRecord = new double[31]; for (int i = 0; i \u0026lt;= 30; i++) { worker.ReportProgress(i * 3); quickSortInsertion.M = i; int[] data = SortCompare.GetRandomArrayInt(this.N); timeRecord[i] = SortCompare.Time(quickSortInsertion, data); } e.Result = timeRecord; } /// \u0026lt;summary\u0026gt;  /// 更新后台进度方法。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  private void backgroundWorker1_ProgressChanged(object sender, ProgressChangedEventArgs e) { this.Text = \u0026#34;正在绘图，已完成 \u0026#34; + e.ProgressPercentage + \u0026#34; %\u0026#34;; } /// \u0026lt;summary\u0026gt;  /// 测试完毕，进行绘图的方法。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  private void backgroundWorker1_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e) { if (e.Error != null) { MessageBox.Show(e.Error.Message); } double[] result = e.Result as double[]; Graphics graphics = this.CreateGraphics(); // 获得绘图区矩形。  RectangleF rect = this.ClientRectangle; float unitX = rect.Width / 10; float unitY = rect.Width / 10; // 添加 10% 边距作为文字区域。  RectangleF center = new RectangleF (rect.X + unitX, rect.Y + unitY, rect.Width - 2 * unitX, rect.Height - 2 * unitY); // 绘制坐标系。  graphics.DrawLine(Pens.Black, center.Left, center.Top, center.Left, center.Bottom); graphics.DrawLine(Pens.Black, center.Left, center.Bottom, center.Right, center.Bottom); graphics.DrawString(result.Max().ToString(), this.Font, Brushes.Black, rect.Location); graphics.DrawString(result.Length.ToString(), this.Font, Brushes.Black, center.Right, center.Bottom); graphics.DrawString(\u0026#34;0\u0026#34;, this.Font, Brushes.Black, rect.Left, center.Bottom); // 初始化点。  PointF[] bluePoints = new PointF[result.Length]; unitX = center.Width / result.Length; unitY = center.Height / (float)result.Max(); for (int i = 0; i \u0026lt; result.Length; i++) { bluePoints[i] = new PointF(center.Left + unitX * (i + 1), center.Bottom - (float)(result[i] * unitY) - 10); } // 绘制点。  for (int i = 0; i \u0026lt; result.Length; i++) { graphics.FillEllipse(Brushes.Blue, new RectangleF(bluePoints[i], new Size(10, 10))); } graphics.Dispose(); this.Text = \u0026#34;绘图结果\u0026#34;; int min = 0; for (int i = 0; i \u0026lt; result.Length; i++) { if (result[i] \u0026lt; result[min]) min = i; } string report = \u0026#34;M \u0026#34; + min + \u0026#34;\\r\\ntime \u0026#34; + result[min]; MessageBox.Show(report, \u0026#34;最优结果\u0026#34;); } } } 快速排序类\nusing System; using System.Diagnostics; using Quick; namespace _2._3._25 { /// \u0026lt;summary\u0026gt;  /// 快速排序类。  /// \u0026lt;/summary\u0026gt;  public class QuickSortInsertion : BaseSort { /// \u0026lt;summary\u0026gt;  /// 切换到插入排序的阈值。  /// \u0026lt;/summary\u0026gt;  public int M { get; set; } /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public QuickSortInsertion() { this.M = 8; } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 进行升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 的 lo ~ hi 范围排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt;  protected void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界  return; if (hi - lo \u0026lt;= this.M) { // 调用插入排序  for (int i = lo; i \u0026lt;= hi; i++) for (int k = i; k \u0026gt; lo \u0026amp;\u0026amp; Less(a[k], a[k - 1]); k--) Exch(a, k, k - 1); return; } int j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt;  /// 对数组进行切分，返回枢轴位置。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt;  private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; T v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt;  /// 打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  private void Shuffle\u0026lt;T\u0026gt;(T[] a) { Random random = new Random(); for (int i = 0; i \u0026lt; a.Length; i++) { int r = i + random.Next(a.Length - i); T temp = a[i]; a[i] = a[r]; a[r] = temp; } } } } 另请参阅 #  BackgroundWorker 组件 | Microsoft Docs\nQuick 库\n"},{"id":271,"href":"/2-3-26/","title":"2.3.26","section":"帮助","content":"2.3.26 #  解答 #  在切换为插入排序之前先记录一下当前子数组的大小。\n在排序类内添加一个大小为 M+1 的数组，用于记录每种数组大小出现的次数。\n结果如下（N=100000）：\nM=10\nM=20\nM=50\n代码 #  using System; using System.ComponentModel; using System.Drawing; using System.Linq; using System.Windows.Forms; using Quick; namespace _2._3._26 { public partial class Form2 : Form { private int M; private int N; public Form2(int m, int n) { InitializeComponent(); this.M = m; this.N = n; } /// \u0026lt;summary\u0026gt;  /// 启动页面时启动后台测试。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  private void Form2_Shown(object sender, EventArgs e) { this.Text = \u0026#34;正在绘图\u0026#34;; this.backgroundWorker1.RunWorkerAsync(); } /// \u0026lt;summary\u0026gt;  /// 后台测试方法。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  private void backgroundWorker1_DoWork(object sender, DoWorkEventArgs e) { BackgroundWorker worker = sender as BackgroundWorker; QuickSortInsertion quickSortInsertion = new QuickSortInsertion { M = this.M }; int[] data = SortCompare.GetRandomArrayInt(this.N); worker.ReportProgress(50); quickSortInsertion.Sort(data); e.Result = quickSortInsertion.Counts; } /// \u0026lt;summary\u0026gt;  /// 更新后台进度方法。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  private void backgroundWorker1_ProgressChanged(object sender, ProgressChangedEventArgs e) { this.Text = \u0026#34;正在绘图，已完成 \u0026#34; + e.ProgressPercentage + \u0026#34; %\u0026#34;; } /// \u0026lt;summary\u0026gt;  /// 测试完毕，进行绘图的方法。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  private void backgroundWorker1_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e) { if (e.Error != null) { MessageBox.Show(e.Error.Message); } //新建画布  Graphics graphics = this.CreateGraphics(); //翻转默认坐标系  graphics.TranslateTransform(0, this.Height); graphics.ScaleTransform(1, -1); int[] countsOrigin = e.Result as int[]; int[] counts = new int[countsOrigin.Length - 1]; for (int i = 0; i \u0026lt; counts.Length; i++) { counts[i] = countsOrigin[i + 1]; } //获取最大值  double max = counts.Max(); //计算间距  double unit = this.Width / (3.0 * counts.Length + 1); double marginTop = 100; //计算直方图的矩形  Rectangle[] rects = new Rectangle[counts.Length]; rects[0].X = (int)unit; rects[0].Y = 0; rects[0].Width = (int)(2 * unit); rects[0].Height = (int)((counts[0] / max) * (this.Height - marginTop)); for (int i = 1; i \u0026lt; counts.Length; ++i) { rects[i].X = (int)(rects[i - 1].X + 3 * unit); rects[i].Y = 0; rects[i].Width = (int)(2 * unit); rects[i].Height = (int)((counts[i] / (max + 1)) * (this.Height - marginTop)); } //绘图  graphics.FillRectangles(Brushes.Black, rects); //释放资源  graphics.Dispose(); this.Text = \u0026#34;绘图结果，最高次数：\u0026#34; + counts.Max() + \u0026#34; 最低次数：\u0026#34; + counts.Min(); } } } 快速排序类\nusing System; using System.Diagnostics; using Quick; namespace _2._3._26 { /// \u0026lt;summary\u0026gt;  /// 快速排序类。  /// \u0026lt;/summary\u0026gt;  public class QuickSortInsertion : BaseSort { /// \u0026lt;summary\u0026gt;  /// 切换到插入排序的阈值。  /// \u0026lt;/summary\u0026gt;  public int M { get; set; } public int[] Counts; /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public QuickSortInsertion() { this.M = 8; } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 进行升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { this.Counts = new int[this.M + 1]; for (int i = 0; i \u0026lt; this.M + 1; i++) { this.Counts[i] = 0; } Shuffle(a); Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 的 lo ~ hi 范围排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt;  protected void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界  return; if (hi - lo \u0026lt;= this.M) { this.Counts[hi - lo]++; // 调用插入排序  for (int i = lo; i \u0026lt;= hi; i++) for (int k = i; k \u0026gt; lo \u0026amp;\u0026amp; Less(a[k], a[k - 1]); k--) Exch(a, k, k - 1); return; } int j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt;  /// 对数组进行切分，返回枢轴位置。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt;  private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; T v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt;  /// 打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  private void Shuffle\u0026lt;T\u0026gt;(T[] a) { Random random = new Random(); for (int i = 0; i \u0026lt; a.Length; i++) { int r = i + random.Next(a.Length - i); T temp = a[i]; a[i] = a[r]; a[r] = temp; } } } } 另请参阅 #  BackgroundWorker 组件 | Microsoft Docs\nQuick 库\n"},{"id":272,"href":"/2-3-27/","title":"2.3.27","section":"帮助","content":"2.3.27 #  解答 #  实验结果如下：\nP.S. 测试机上的缓存是 L1 128K，L2 512K，L3 4MB。\n代码 #  QuickSortIgnore\nusing System; using System.Diagnostics; using Quick; namespace _2._3._27 { /// \u0026lt;summary\u0026gt;  /// 快速排序类。  /// \u0026lt;/summary\u0026gt;  public class QuickSortIgnore : BaseSort { /// \u0026lt;summary\u0026gt;  /// 切换到插入排序的阈值。  /// \u0026lt;/summary\u0026gt;  public int M { get; set; } /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public QuickSortIgnore() { this.M = 10; } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 进行升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); Sort(a, 0, a.Length - 1); // 插入排序处理小数组  for (int i = 0; i \u0026lt; a.Length; i++) for (int j = i; j \u0026gt; 0 \u0026amp;\u0026amp; Less(a[j], a[j - 1]); j--) Exch(a, j, j - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 的 lo ~ hi 范围排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt;  protected void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界  return; if (hi - lo \u0026lt;= this.M) { return; // 直接忽略  } int j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt;  /// 对数组进行切分，返回枢轴位置。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt;  private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; T v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt;  /// 打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  private void Shuffle\u0026lt;T\u0026gt;(T[] a) { Random random = new Random(); for (int i = 0; i \u0026lt; a.Length; i++) { int r = i + random.Next(a.Length - i); T temp = a[i]; a[i] = a[r]; a[r] = temp; } } } } QuickSortInsertion\nusing System; using System.Diagnostics; using Quick; namespace _2._3._27 { /// \u0026lt;summary\u0026gt;  /// 快速排序类。  /// \u0026lt;/summary\u0026gt;  public class QuickSortInsertion : BaseSort { /// \u0026lt;summary\u0026gt;  /// 切换到插入排序的阈值。  /// \u0026lt;/summary\u0026gt;  public int M { get; set; } /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public QuickSortInsertion() { this.M = 10; } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 进行升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 的 lo ~ hi 范围排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt;  protected void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界  return; if (hi - lo \u0026lt;= this.M) { // 调用插入排序  for (int i = lo; i \u0026lt;= hi; i++) for (int k = i; k \u0026gt; lo \u0026amp;\u0026amp; Less(a[k], a[k - 1]); k--) Exch(a, k, k - 1); return; } int j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt;  /// 对数组进行切分，返回枢轴位置。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt;  private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; T v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt;  /// 打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  private void Shuffle\u0026lt;T\u0026gt;(T[] a) { Random random = new Random(); for (int i = 0; i \u0026lt; a.Length; i++) { int r = i + random.Next(a.Length - i); T temp = a[i]; a[i] = a[r]; a[r] = temp; } } } } 测试用例\nusing System; using Quick; namespace _2._3._27 { /* * 2.3.27 * * 忽略小数组。 * 用实验对比以下处理小数组的方法和练习 2.3.25 的处理方法的效果： * 在快速排序中直接忽略小数组，仅在快速排序结束后运行一次插入排序。 * 注意： * 可以通过这些实验估计出电脑的缓存大小， * 因为当数组大小超出缓存时这种方法的性能可能会下降。 * */ class Program { static void Main(string[] args) { QuickSortInsertion insertion = new QuickSortInsertion(); QuickSortIgnore ignore = new QuickSortIgnore(); int arraySize = 20000; // 初始数组大小。  const int mSteps = 1; // M 值的递增次数。  const int trialTimes = 4; // 每次实验的重复次数。  const int trialLevel = 10; // 双倍递增的次数。  Console.WriteLine(\u0026#34;M\\tn\\t\\tignore\\tinsert\\tratio\u0026#34;); for (int i = 0; i \u0026lt; mSteps; i++) { int array = arraySize; for (int j = 0; j \u0026lt; trialLevel; j++) { double timeIgnore = 0; double timeInsertion = 0; for (int k = 0; k \u0026lt; trialTimes; k++) { int[] a = SortCompare.GetRandomArrayInt(array); int[] b = new int[a.Length]; a.CopyTo(b, 0); timeInsertion += SortCompare.Time(insertion, b); timeIgnore += SortCompare.Time(ignore, a); } timeIgnore /= trialTimes; timeInsertion /= trialTimes; if (arraySize \u0026lt; 10000000) Console.WriteLine(ignore.M + \u0026#34;\\t\u0026#34; + array + \u0026#34;\\t\\t\u0026#34; + timeIgnore + \u0026#34;\\t\u0026#34; + timeInsertion + \u0026#34;\\t\u0026#34; + timeIgnore / timeInsertion); else Console.WriteLine(ignore.M + \u0026#34;\\t\u0026#34; + array + \u0026#34;\\t\u0026#34; + timeIgnore + \u0026#34;\\t\u0026#34; + timeInsertion + \u0026#34;\\t\u0026#34; + timeIgnore / timeInsertion); array *= 2; } ignore.M++; } } } } 另请参阅 #  Quick 库\n"},{"id":273,"href":"/2-3-28/","title":"2.3.28","section":"帮助","content":"2.3.28 #  解答 #  对 Sort 方法做修改，添加一个层层传递的 depth 参数，每加一层 depth 就加一，结束时取左右较大的 depth 返回。\nprotected int Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi, int depth) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界  return depth; if (hi - lo \u0026lt;= this.M) { // 调用插入排序  for (int i = lo; i \u0026lt;= hi; i++) for (int k = i; k \u0026gt; lo \u0026amp;\u0026amp; Less(a[k], a[k - 1]); k--) Exch(a, k, k - 1); return depth; } int j = Partition(a, lo, hi); int left = Sort(a, lo, j - 1, depth + 1); int right = Sort(a, j + 1, hi, depth + 1); return Less(left, right) ? right : left; } 测试结果\n代码 #  using System; using System.Diagnostics; using Quick; namespace _2._3._28 { /// \u0026lt;summary\u0026gt;  /// 快速排序类。  /// \u0026lt;/summary\u0026gt;  public class QuickSortInsertion : BaseSort { /// \u0026lt;summary\u0026gt;  /// 切换到插入排序的阈值。  /// \u0026lt;/summary\u0026gt;  public int M { get; set; } /// \u0026lt;summary\u0026gt;  /// 上一次排序的最大递归深度。  /// \u0026lt;/summary\u0026gt;  public int Depth { get; private set; } /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public QuickSortInsertion() { this.M = 10; } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 进行升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;递归深度。\u0026lt;/returns\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); this.Depth = Sort(a, 0, a.Length - 1, 0); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 的 lo ~ hi 范围排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt;  protected int Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi, int depth) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界  return depth; if (hi - lo \u0026lt;= this.M) { // 调用插入排序  for (int i = lo; i \u0026lt;= hi; i++) for (int k = i; k \u0026gt; lo \u0026amp;\u0026amp; Less(a[k], a[k - 1]); k--) Exch(a, k, k - 1); return depth; } int j = Partition(a, lo, hi); int left = Sort(a, lo, j - 1, depth + 1); int right = Sort(a, j + 1, hi, depth + 1); return Less(left, right) ? right : left; } /// \u0026lt;summary\u0026gt;  /// 对数组进行切分，返回枢轴位置。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt;  private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; T v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt;  /// 打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  private void Shuffle\u0026lt;T\u0026gt;(T[] a) { Random random = new Random(); for (int i = 0; i \u0026lt; a.Length; i++) { int r = i + random.Next(a.Length - i); T temp = a[i]; a[i] = a[r]; a[r] = temp; } } } } 测试用例\nusing System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace _2._3._28 { /* * 2.3.28 * * 递归深度。 * 用经验性的研究估计切换阈值为 M 的快速排序 * 在将大小为 N 的不重复数组排序时的平均递归深度， * 其中 M=10、20 和 50，N=10^3、10^4、10^5 和 10^6。 * */ class Program { static void Main(string[] args) { Console.WriteLine(\u0026#34;M\\tN\\tDepth\u0026#34;); Trial(10); Trial(20); Trial(50); } /// \u0026lt;summary\u0026gt;  /// 进行一次测试。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;m\u0026#34;\u0026gt;要使用的阈值\u0026lt;/param\u0026gt;  static void Trial(int m) { QuickSortInsertion sort = new QuickSortInsertion(); int trialTime = 5; // 由于排序前有 Shuffle，因此直接输入有序数组。  // M=10  sort.M = m; int totalDepth = 0; for (int N = 1000; N \u0026lt; 10000000; N *= 10) { for (int i = 0; i \u0026lt; trialTime; i++) { int[] a = new int[N]; for (int j = 0; j \u0026lt; N; j++) { a[j] = j; } sort.Sort(a); totalDepth += sort.Depth; } Console.WriteLine(sort.M + \u0026#34;\\t\u0026#34; + N + \u0026#34;\\t\u0026#34; + totalDepth / trialTime); } } } } 另请参阅 #  Quick 库\n"},{"id":274,"href":"/2-3-29/","title":"2.3.29","section":"帮助","content":"2.3.29 #  解答 #  在快排类内部添加一个随机数发生器，每次随机取枢轴并交换至第一位进行切分。\nprivate int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; int pivot = this.RandomGenerator.Next(hi - lo) + lo; Exch(a, pivot, lo); T v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } 测试结果：\n代码 #  使用随机枢轴的快排\nusing System; using System.Diagnostics; using Quick; namespace _2._3._29 { /// \u0026lt;summary\u0026gt;  /// 快速排序类。  /// \u0026lt;/summary\u0026gt;  public class QuickSortRandomPivot : BaseSort { /// \u0026lt;summary\u0026gt;  /// 切换到插入排序的阈值。  /// \u0026lt;/summary\u0026gt;  public int M { get; set; } /// \u0026lt;summary\u0026gt;  /// 随机数发生器。  /// \u0026lt;/summary\u0026gt;  private readonly Random RandomGenerator = new Random(); /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public QuickSortRandomPivot() { this.M = 10; } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 进行升序排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public override void Sort\u0026lt;T\u0026gt;(T[] a) { Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt;  /// 用快速排序对数组 a 的 lo ~ hi 范围排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt;  protected void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界  return; if (hi - lo \u0026lt;= this.M) { // 调用插入排序  for (int i = lo; i \u0026lt;= hi; i++) for (int k = i; k \u0026gt; lo \u0026amp;\u0026amp; Less(a[k], a[k - 1]); k--) Exch(a, k, k - 1); return; } int j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt;  /// 对数组进行切分，返回枢轴位置。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt;  private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; int pivot = this.RandomGenerator.Next(hi - lo) + lo; Exch(a, pivot, lo); T v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } } } 测试用例\nusing System; using Quick; namespace _2._3._29 { /* * 2.3.29 * * 随机化。 * 用经验性的研究对比随机选择切分元素和正文所述的一开始就将数组随机化这两种策略的效果。 * 在子数组大小为 M 时进行切换，将大小为 N 的不重复数组排序， * 其中 M=10、20 和 50，N=10^3、10^4、10^5 和 10^6。 * */ class Program { static void Main(string[] args) { Console.WriteLine(\u0026#34;M\\tN\\tshuffle\\trandom\\tshuffle/random\u0026#34;); Trial(10); Trial(20); Trial(50); } /// \u0026lt;summary\u0026gt;  /// 进行一次测试。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;m\u0026#34;\u0026gt;要使用的阈值\u0026lt;/param\u0026gt;  static void Trial(int m) { QuickSortInsertion withShuffle = new QuickSortInsertion(); QuickSortRandomPivot randomPivot = new QuickSortRandomPivot(); int trialTime = 5; // M=10  withShuffle.M = m; randomPivot.M = m; double timeShuffle = 0; double timeRandomPivot = 0; for (int N = 1000; N \u0026lt; 10000000; N *= 10) { for (int i = 0; i \u0026lt; trialTime; i++) { int[] a = new int[N]; int[] b = new int[N]; for (int j = 0; j \u0026lt; N; j++) { a[j] = j; } Shuffle(a); a.CopyTo(b, 0); timeShuffle += SortCompare.Time(withShuffle, a); timeRandomPivot += SortCompare.Time(randomPivot, b); } timeShuffle /= trialTime; timeRandomPivot /= trialTime; Console.WriteLine(withShuffle.M + \u0026#34;\\t\u0026#34; + N + \u0026#34;\\t\u0026#34; + timeShuffle + \u0026#34;\\t\u0026#34; + timeRandomPivot + \u0026#34;\\t\u0026#34; + timeShuffle / timeRandomPivot); } } /// \u0026lt;summary\u0026gt;  /// 打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  static void Shuffle\u0026lt;T\u0026gt;(T[] a) { Random random = new Random(); for (int i = 0; i \u0026lt; a.Length; i++) { int r = i + random.Next(a.Length - i); T temp = a[i]; a[i] = a[r]; a[r] = temp; } } } } 另请参阅 #  Quick 库\n"},{"id":275,"href":"/2-3-30/","title":"2.3.30","section":"帮助","content":"2.3.30 #  解答 #  结果如下，在 N=5000000 时，随机选择枢轴会比事先打乱快一点。\n代码 #  using System; using Quick; namespace _2._3._30 { /* * 2.3.30 * * 极端情况。 * 用初始随机化和非初始随机化的快速排序测试练习 2.1.35 和练习 2.1.36 中描述的大型非随机数组。 * 在将这些大数组排序时，乱序对快速排序的性能有何影响？ * */ class Program { static void Main(string[] args) { QuickSortInsertion insertionSort = new QuickSortInsertion(); QuickSortRandomPivot randomSort = new QuickSortRandomPivot(); int n = 5000000; // 高斯分布（正态分布）  double[] arrayInsertion = SortCompare.GetNormalDistributionArray(n); double[] arraySelection = new double[n]; arrayInsertion.CopyTo(arraySelection, 0); Console.WriteLine(\u0026#34;Normal Distribution:\u0026#34;); Console.WriteLine(\u0026#34;Insertion: \u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Random Pivot: \u0026#34; + SortCompare.Time(randomSort, arraySelection)); Console.WriteLine(); // 泊松分布  arrayInsertion = SortCompare.GetPossionDistributionArray(n); arrayInsertion.CopyTo(arraySelection, 0); Console.WriteLine(\u0026#34;Poission Distribution:\u0026#34;); Console.WriteLine(\u0026#34;Insertion: \u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Random Pivot: \u0026#34; + SortCompare.Time(randomSort, arraySelection)); Console.WriteLine(); // 几何分布  arrayInsertion = SortCompare.GetGeometricDistributionArray(n, 0.3); arrayInsertion.CopyTo(arraySelection, 0); Console.WriteLine(\u0026#34;Geometric Distribution:\u0026#34;); Console.WriteLine(\u0026#34;Insertion: \u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Random Pivot: \u0026#34; + SortCompare.Time(randomSort, arraySelection)); Console.WriteLine(); // 离散分布  arrayInsertion = SortCompare.GetDiscretDistributionArray(n, new double[] { 0.1, 0.2, 0.3, 0.1, 0.1, 0.1, 0.1 }); arrayInsertion.CopyTo(arraySelection, 0); Console.WriteLine(\u0026#34;Discret Distribution:\u0026#34;); Console.WriteLine(\u0026#34;Insertion: \u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Random Pivot: \u0026#34; + SortCompare.Time(randomSort, arraySelection)); Console.WriteLine(); // 一半是 0 一半是 1  int[] arrayNormalInsertion = HalfZeroHalfOne(n); int[] arrayRandomPivot = new int[n]; arrayNormalInsertion.CopyTo(arrayRandomPivot, 0); Console.WriteLine(\u0026#34;half 0 and half 1\u0026#34;); Console.WriteLine(\u0026#34;Insertion:\u0026#34; + SortCompare.Time(insertionSort, arrayNormalInsertion)); Console.WriteLine(\u0026#34;Random Pivot:\u0026#34; + SortCompare.Time(randomSort, arrayRandomPivot)); Console.WriteLine(); // 一半是 0， 1/4 是 1， 1/8 是 2……  arrayNormalInsertion = HalfAndHalf(n); arrayNormalInsertion.CopyTo(arrayRandomPivot, 0); Console.WriteLine(\u0026#34;half and half and half ...\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.Time(insertionSort, arrayNormalInsertion)); Console.WriteLine(\u0026#34;Random Pivot:\u0026#34; + SortCompare.Time(randomSort, arrayRandomPivot)); Console.WriteLine(); // 一半是 0，一半是随机 int 值  arrayNormalInsertion = HalfZeroHalfRandom(n); arrayNormalInsertion.CopyTo(arrayRandomPivot, 0); Console.WriteLine(\u0026#34;half 0 half random\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.Time(insertionSort, arrayNormalInsertion)); Console.WriteLine(\u0026#34;Random Pivot:\u0026#34; + SortCompare.Time(randomSort, arrayRandomPivot)); } /// \u0026lt;summary\u0026gt;  /// 获取一半是 0 一半是 1 的随机 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;数组大小。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;一半是 0 一半是 1 的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt;数组。\u0026lt;/returns\u0026gt;  static int[] HalfZeroHalfOne(int n) { int[] result = new int[n]; Random random = new Random(); for (int i = 0; i \u0026lt; n; i++) { if (random.NextDouble() \u0026gt;= 0.5) { result[i] = 0; } else { result[i] = 1; } } return result; } /// \u0026lt;summary\u0026gt;  /// 生成 1/2 为 0， 1/4 为 1， 1/8 为 2 …… 的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;数组长度。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;1/2 为 0， 1/4 为 1， 1/8 为 2 …… 的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。\u0026lt;/returns\u0026gt;  static int[] HalfAndHalf(int n) { int[] array = new int[n]; HalfIt(0, 0, n / 2, array); Shuffle(array); return array; } /// \u0026lt;summary\u0026gt;  /// 递归生成 1/2 为 0， 1/4 为 1， 1/8 为 2 …… 的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;start\u0026#34;\u0026gt;填充起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;number\u0026#34;\u0026gt;起始编号。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;length\u0026#34;\u0026gt;填充长度\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;array\u0026#34;\u0026gt;用于填充的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;一个 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。\u0026lt;/returns\u0026gt;  static int[] HalfIt(int start, int number, int length, int[] array) { if (length == 0) return array; for (int i = 0; i \u0026lt; length; i++) { array[start + i] = number; } return HalfIt(start + length, number + 1, length / 2, array); } /// \u0026lt;summary\u0026gt;  /// 生成一半是 0 一半是随机整数的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;数组大小。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;生成一半是 0 一半是随机整数的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。\u0026lt;/returns\u0026gt;  static int[] HalfZeroHalfRandom(int n) { int[] array = new int[n]; Random random = new Random(); for (int i = 0; i \u0026lt; n / 2; i++) { array[i] = 0; } for (int i = n / 2; i \u0026lt; n; i++) { array[i] = random.Next(); } Shuffle(array); return array; } /// \u0026lt;summary\u0026gt;  /// 打乱数组。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt;  static void Shuffle(int[] a) { int N = a.Length; Random random = new Random(); for (int i = 0; i \u0026lt; N; i++) { int r = i + random.Next(N - i);// 等于StdRandom.uniform(N-i)  int temp = a[i]; a[i] = a[r]; a[r] = temp; } } } } 另请参阅 #  Quick 库\n"},{"id":276,"href":"/2-3-31/","title":"2.3.31","section":"帮助","content":"2.3.31 #  解答 #  以下所有结果 T=70\nN=1000\nN=10000\nN=100000\nN=1000000\n代码 #  using System; using System.ComponentModel; using System.Drawing; using System.Linq; using System.Windows.Forms; using Quick; namespace _2._3._31 { public partial class Form2 : Form { private int N; private int T; public Form2(int n, int t) { InitializeComponent(); this.N = n; this.T = t; } /// \u0026lt;summary\u0026gt;  /// 启动页面时启动后台测试。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  private void Form2_Shown(object sender, EventArgs e) { this.Text = \u0026#34;正在绘图\u0026#34;; this.backgroundWorker1.RunWorkerAsync(); } /// \u0026lt;summary\u0026gt;  /// 后台测试方法。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  private void backgroundWorker1_DoWork(object sender, DoWorkEventArgs e) { BackgroundWorker worker = sender as BackgroundWorker; QuickSort quick = new QuickSort(); double percentPerTrial = 100.0 / this.T; double[] totalTime = new double[this.T]; for (int i = 0; i \u0026lt; this.T; i++) { double[] data = SortCompare.GetRandomArrayDouble(this.N); totalTime[i] = SortCompare.Time(quick, data); worker.ReportProgress((int)(percentPerTrial * i)); } e.Result = totalTime; } /// \u0026lt;summary\u0026gt;  /// 更新后台进度方法。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  private void backgroundWorker1_ProgressChanged(object sender, ProgressChangedEventArgs e) { this.Text = \u0026#34;正在测试，已完成 \u0026#34; + e.ProgressPercentage + \u0026#34; %\u0026#34;; } /// \u0026lt;summary\u0026gt;  /// 测试完毕，进行绘图的方法。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  private void backgroundWorker1_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e) { if (e.Error != null) { MessageBox.Show(e.Error.Message); } //新建画布  Graphics graphics = this.CreateGraphics(); //翻转默认坐标系  graphics.TranslateTransform(0, this.Height); graphics.ScaleTransform(1, -1); double[] counts = e.Result as double[]; //获取最大值  double max = counts.Max(); //计算间距  double unit = this.Width / (3.0 * counts.Length + 1); double marginTop = 100; //计算直方图的矩形  Rectangle[] rects = new Rectangle[counts.Length]; rects[0].X = (int)unit; rects[0].Y = 0; rects[0].Width = (int)(2 * unit); rects[0].Height = (int)((counts[0] / max) * (this.Height - marginTop)); for (int i = 1; i \u0026lt; counts.Length; ++i) { rects[i].X = (int)(rects[i - 1].X + 3 * unit); rects[i].Y = 0; rects[i].Width = (int)(2 * unit); rects[i].Height = (int)((counts[i] / (max + 1)) * (this.Height - marginTop)); } //绘图  graphics.FillRectangles(Brushes.Black, rects); //释放资源  graphics.Dispose(); this.Text = \u0026#34;绘图结果，最高耗时：\u0026#34; + counts.Max() + \u0026#34; 最低耗时：\u0026#34; + counts.Min(); } } } 另请参阅 #  BackgroundWorker 组件 | Microsoft Docs\nQuick 库\n"},{"id":277,"href":"/2-4-1/","title":"2.4.1","section":"帮助","content":"2.4.1 #  解答 #  R R P O T Y I I U Q E U 优先队列的变化如下：\n   输入命令 优先队列 输出     P P    R P R    I P R I    O P R I O    * P I O R   R P I O R    * P I O R   * I O P   I I O I    * I I O   T I I T    * I I T   Y I I Y    * I I Y   * I I   *  I   Q Q    U Q U    E Q U E    * Q E U   * E Q   *  E   U U    *  U   E E     "},{"id":278,"href":"/2-4-2/","title":"2.4.2","section":"帮助","content":"2.4.2 #  解答 #  这种方式只能取出一次最大值，这个最大值就是输入序列里面的最大值。\n当需要继续取出最大值时（即继续取第二大、第三大、第 i 大的元素），\n这个方法就不再适用了（或者说不能在常数时间内完成）。\n"},{"id":279,"href":"/2-4-3/","title":"2.4.3","section":"帮助","content":"2.4.3 #  解答 #  有序数组的官方版本：https://algs4.cs.princeton.edu/24pq/OrderedArrayMaxPQ.java.html\n无序数组的官方版本：https://algs4.cs.princeton.edu/24pq/UnorderedArrayMaxPQ.java.html\n   实现 insert() delMax()     有序数组 N 1   有序链表 N 1   无序数组 1 N   无序链表 1 N    在库文件中定义了如下接口，所有的（最大）优先队列都会实现它。\nusing System; namespace PriorityQueue { /// \u0026lt;summary\u0026gt;  /// 实现优先队列 API 的接口。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Key\u0026#34;\u0026gt;优先队列容纳的元素。\u0026lt;/typeparam\u0026gt;  public interface IMaxPQ\u0026lt;Key\u0026gt; where Key : IComparable\u0026lt;Key\u0026gt; { /// \u0026lt;summary\u0026gt;  /// 向优先队列中插入一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;插入元素的类型。\u0026lt;/param\u0026gt;  void Insert(Key v); /// \u0026lt;summary\u0026gt;  /// 返回最大元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  Key Max(); /// \u0026lt;summary\u0026gt;  /// 删除并返回最大元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  Key DelMax(); /// \u0026lt;summary\u0026gt;  /// 返回队列是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  bool IsEmpty(); /// \u0026lt;summary\u0026gt;  /// 返回队列中的元素个数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  int Size(); } } 于是我们就可以使用这样的方法测试所有类型的优先队列：\nstatic void test(IMaxPQ\u0026lt;string\u0026gt; pq) { Console.WriteLine(pq.ToString()); pq.Insert(\u0026#34;this\u0026#34;); pq.Insert(\u0026#34;is\u0026#34;); pq.Insert(\u0026#34;a\u0026#34;); pq.Insert(\u0026#34;test\u0026#34;); while (!pq.IsEmpty()) Console.Write(pq.DelMax() + \u0026#34; \u0026#34;); Console.WriteLine(); } 代码 #  给出链表的实现，基于数组的实现可以点击「另请参阅」中的 PriorityQueue 库查看。\n无序链表\nusing System; namespace PriorityQueue { /// \u0026lt;summary\u0026gt;  /// 不保持元素输入顺序的优先队列。（基于链表）  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Key\u0026#34;\u0026gt;优先队列中的元素类型。\u0026lt;/typeparam\u0026gt;  public class UnorderedLinkedMaxPQ\u0026lt;Key\u0026gt; : IMaxPQ\u0026lt;Key\u0026gt; where Key : IComparable\u0026lt;Key\u0026gt; { /// \u0026lt;summary\u0026gt;  /// 保存元素的链表。  /// \u0026lt;/summary\u0026gt;  private readonly LinkedList\u0026lt;Key\u0026gt; pq; /// \u0026lt;summary\u0026gt;  /// 默认构造函数，建立一条优先队列。  /// \u0026lt;/summary\u0026gt;  public UnorderedLinkedMaxPQ() { this.pq = new LinkedList\u0026lt;Key\u0026gt;(); } /// \u0026lt;summary\u0026gt;  /// 获得（但不删除）优先队列中的最大元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key Max() { int max = 0; for (int i = 1; i \u0026lt; this.pq.Size(); i++) if (Less(this.pq.Find(max), this.pq.Find(i))) max = i; return this.pq.Find(max); } /// \u0026lt;summary\u0026gt;  /// 返回并删除优先队列中的最大值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key DelMax() { int max = 0; for (int i = 1; i \u0026lt; this.pq.Size(); i++) if (Less(this.pq.Find(max), this.pq.Find(i))) max = i; return this.pq.Delete(max); } /// \u0026lt;summary\u0026gt;  /// 向优先队列中插入一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;需要插入的元素。\u0026lt;/param\u0026gt;  public void Insert(Key v) =\u0026gt; this.pq.Insert(v); /// \u0026lt;summary\u0026gt;  /// 检查优先队列是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() =\u0026gt; this.pq.IsEmpty(); /// \u0026lt;summary\u0026gt;  /// 检查优先队列中含有的元素数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() =\u0026gt; this.pq.Size(); /// \u0026lt;summary\u0026gt;  /// 比较第一个元素是否小于第二个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;第一个元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;第二个元素。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private bool Less(Key a, Key b) =\u0026gt; a.CompareTo(b) \u0026lt; 0; } } 有序链表\nusing System; namespace PriorityQueue { /// \u0026lt;summary\u0026gt;  /// 元素保持输入顺序的优先队列。（基于链表）  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Key\u0026#34;\u0026gt;优先队列中的元素类型。\u0026lt;/typeparam\u0026gt;  public class OrderedLinkedMaxPQ\u0026lt;Key\u0026gt; : IMaxPQ\u0026lt;Key\u0026gt; where Key : IComparable\u0026lt;Key\u0026gt; { /// \u0026lt;summary\u0026gt;  /// 用于保存元素的链表。  /// \u0026lt;/summary\u0026gt;  private readonly LinkedList\u0026lt;Key\u0026gt; pq; /// \u0026lt;summary\u0026gt;  /// 默认构造函数，建立一条优先队列。  /// \u0026lt;/summary\u0026gt;  public OrderedLinkedMaxPQ() { this.pq = new LinkedList\u0026lt;Key\u0026gt;(); } /// \u0026lt;summary\u0026gt;  /// 向优先队列中插入一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;需要插入的元素。\u0026lt;/param\u0026gt;  public void Insert(Key v) { int i = this.pq.Size() - 1; while (i \u0026gt;= 0 \u0026amp;\u0026amp; Less(v, this.pq.Find(i))) i--; this.pq.Insert(v, i + 1); } /// \u0026lt;summary\u0026gt;  /// 返回并删除优先队列中的最大值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key DelMax() =\u0026gt; this.pq.Delete(this.pq.Size() - 1); /// \u0026lt;summary\u0026gt;  /// 检查优先队列是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() =\u0026gt; this.pq.IsEmpty(); /// \u0026lt;summary\u0026gt;  /// 获得（但不删除）优先队列中的最大元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key Max() =\u0026gt; this.pq.Find(this.pq.Size() - 1); /// \u0026lt;summary\u0026gt;  /// 检查优先队列中含有的元素数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() =\u0026gt; this.pq.Size(); /// \u0026lt;summary\u0026gt;  /// 比较第一个元素是否小于第二个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;第一个元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;第二个元素。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private bool Less(Key a, Key b) =\u0026gt; a.CompareTo(b) \u0026lt; 0; } } 另请参阅 #  PriorityQueue 库\n"},{"id":280,"href":"/2-4-4/","title":"2.4.4","section":"帮助","content":"2.4.4 #  解答 #  是的。\n例如这个数组：9 8 7 6 5，画成二叉堆如下：\n"},{"id":281,"href":"/2-4-5/","title":"2.4.5","section":"帮助","content":"2.4.5 #  解答 #  "},{"id":282,"href":"/2-4-6/","title":"2.4.6","section":"帮助","content":"2.4.6 #  解答 #  官方给出的最大堆实现：https://algs4.cs.princeton.edu/24pq/MaxPQ.java.html\n运行示意图：\n运行结果：\nP R P R P I R P I O P O I R P I O P O I O I O I I I I T I I I I Y I I I I I Q U Q U Q E Q E E U E 代码 #  最大堆的实现\nusing System; using System.Collections; using System.Collections.Generic; using System.Diagnostics; using System.Text; namespace PriorityQueue { /// \u0026lt;summary\u0026gt;  /// 最大堆。（数组实现）  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Key\u0026#34;\u0026gt;最大堆中保存的元素类型。\u0026lt;/typeparam\u0026gt;  public class MaxPQ\u0026lt;Key\u0026gt; : IMaxPQ\u0026lt;Key\u0026gt;, IEnumerable\u0026lt;Key\u0026gt; where Key : IComparable\u0026lt;Key\u0026gt; { protected Key[] pq; // 保存元素的数组。  protected int n; // 堆中的元素数量。  /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public MaxPQ() : this(1) { } /// \u0026lt;summary\u0026gt;  /// 建立指定容量的最大堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;最大堆的容量。\u0026lt;/param\u0026gt;  public MaxPQ(int capacity) { this.pq = new Key[capacity + 1]; this.n = 0; } /// \u0026lt;summary\u0026gt;  /// 从已有元素建立一个最大堆。（O(n)）  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;keys\u0026#34;\u0026gt;已有元素。\u0026lt;/param\u0026gt;  public MaxPQ(Key[] keys) { this.n = keys.Length; this.pq = new Key[keys.Length + 1]; for (int i = 0; i \u0026lt; keys.Length; i++) this.pq[i + 1] = keys[i]; for (int k = this.n / 2; k \u0026gt;= 1; k--) Sink(k); Debug.Assert(IsMaxHeap()); } /// \u0026lt;summary\u0026gt;  /// 删除并返回最大元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key DelMax() { if (IsEmpty()) throw new ArgumentOutOfRangeException(\u0026#34;Priority Queue Underflow\u0026#34;); Key max = this.pq[1]; Exch(1, this.n--); Sink(1); this.pq[this.n + 1] = default(Key); if ((this.n \u0026gt; 0) \u0026amp;\u0026amp; (this.n == this.pq.Length / 4)) Resize(this.pq.Length / 2); // Debug.Assert(IsMaxHeap());  return max; } /// \u0026lt;summary\u0026gt;  /// 向堆中插入一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;需要插入的元素。\u0026lt;/param\u0026gt;  public void Insert(Key v) { if (this.n == this.pq.Length - 1) Resize(2 * this.pq.Length); this.pq[++this.n] = v; Swim(this.n); // Debug.Assert(IsMaxHeap());  } /// \u0026lt;summary\u0026gt;  /// 删除一个结点。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;结点下标。\u0026lt;/param\u0026gt;  internal void Remove(int k) { if (k == this.n) { this.pq[this.n--] = default(Key); return; } else if (this.n \u0026lt;= 2) { Exch(1, k); this.pq[this.n--] = default(Key); return; } Exch(k, this.n--); this.pq[this.n + 1] = default(Key); Swim(k); Sink(k); } /// \u0026lt;summary\u0026gt;  /// 检查堆是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() =\u0026gt; this.n == 0; /// \u0026lt;summary\u0026gt;  /// 获得堆中最大元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key Max() =\u0026gt; this.pq[1]; /// \u0026lt;summary\u0026gt;  /// 获得堆中元素的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() =\u0026gt; this.n; /// \u0026lt;summary\u0026gt;  /// 输出最大堆中的元素，元素之间用空格分隔。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;形如 A B C D 的字符串。\u0026lt;/returns\u0026gt;  public override string ToString() { StringBuilder sb = new StringBuilder(); for (int i = 1; i \u0026lt; pq.Length; i++) sb.Append(pq[i] + \u0026#34; \u0026#34;); return sb.ToString(); } /// \u0026lt;summary\u0026gt;  /// 获取堆的迭代器，元素以降序排列。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public IEnumerator\u0026lt;Key\u0026gt; GetEnumerator() { MaxPQ\u0026lt;Key\u0026gt; copy = new MaxPQ\u0026lt;Key\u0026gt;(this.n); for (int i = 1; i \u0026lt;= this.n; i++) copy.Insert(this.pq[i]); while (!copy.IsEmpty()) yield return copy.DelMax(); // 下次迭代的时候从这里继续执行。  } /// \u0026lt;summary\u0026gt;  /// 获取堆的迭代器，元素以降序排列。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } /// \u0026lt;summary\u0026gt;  /// 使元素上浮。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要上浮的元素。\u0026lt;/param\u0026gt;  private void Swim(int k) { while (k \u0026gt; 1 \u0026amp;\u0026amp; Less(k / 2, k)) { Exch(k, k / 2); k /= 2; } } /// \u0026lt;summary\u0026gt;  /// 使元素下沉。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要下沉的元素。\u0026lt;/param\u0026gt;  private void Sink(int k) { while (k * 2 \u0026lt;= this.n) { int j = 2 * k; if (j \u0026lt; this.n \u0026amp;\u0026amp; Less(j, j + 1)) j++; if (!Less(k, j)) break; Exch(k, j); k = j; } } /// \u0026lt;summary\u0026gt;  /// 重新调整堆的大小。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;调整后的堆大小。\u0026lt;/param\u0026gt;  private void Resize(int capacity) { Key[] temp = new Key[capacity]; for (int i = 1; i \u0026lt;= this.n; i++) { temp[i] = this.pq[i]; } this.pq = temp; } /// \u0026lt;summary\u0026gt;  /// 判断堆中某个元素是否小于另一元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;判断是否较小的元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;判断是否较大的元素。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private bool Less(int i, int j) =\u0026gt; this.pq[i].CompareTo(this.pq[j]) \u0026lt; 0; /// \u0026lt;summary\u0026gt;  /// 交换堆中的两个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要交换的第一个元素下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;要交换的第二个元素下标。\u0026lt;/param\u0026gt;  protected virtual void Exch(int i, int j) { Key swap = this.pq[i]; this.pq[i] = this.pq[j]; this.pq[j] = swap; } /// \u0026lt;summary\u0026gt;  /// 检查当前二叉树是不是一个最大堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private bool IsMaxHeap() =\u0026gt; IsMaxHeap(1); /// \u0026lt;summary\u0026gt;  /// 确定以 k 为根节点的二叉树是不是一个最大堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要检查的二叉树根节点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private bool IsMaxHeap(int k) { if (k \u0026gt; this.n) return true; int left = 2 * k; int right = 2 * k + 1; if (left \u0026lt;= this.n \u0026amp;\u0026amp; Less(k, left)) return false; if (right \u0026lt;= this.n \u0026amp;\u0026amp; Less(k, right)) return false; return IsMaxHeap(left) \u0026amp;\u0026amp; IsMaxHeap(right); } } } 另请参阅 #  PriorityQueue 库\n"},{"id":283,"href":"/2-4-7/","title":"2.4.7","section":"帮助","content":"2.4.7 #  解答 #  k = 2 时，\n只可能出现在位置 2、3 上（根节点的子结点，深度为 2，根节点深度为 1）\nk = 3 时，\n可以直接是根节点的子结点（第 2 或第 3 位，深度为 2），\n也可以是第二大元素的子结点（第 4~7 位，也就是深度为 3 的所有位置）\nk = 4 时，\n可以直接是根节点的子结点（深度为 2 的点）\n也可以是第二大元素的子结点（深度为 3 的点）\n也可以是第三大元素的子结点（深度为 4 的点）\n故范围为第 2~15 位。\n不难看出第 k 大元素只可能出现在深度＜k 的位置（$k \\ge 2$）\n即位置小于 $2 ^ k - 1, (k \\ge 2)$\n"},{"id":284,"href":"/2-4-8/","title":"2.4.8","section":"帮助","content":"2.4.8 #  解答 #  不难看出第 k 大元素只可能出现在深度＜k 的位置（$ k \\ge 2$）\n即位置小于 $ 2^k - 1, (k \\ge 2)$。\n出现范围为 $[2, \\min {2^k -1, n}]$，其中 n 为堆的大小。\n"},{"id":285,"href":"/2-4-9/","title":"2.4.9","section":"帮助","content":"2.4.9 #  解答 #  首先 A B C D E 中，根节点必须是 E （假设为最大堆）\nD 只能选择 E 作为父结点。\nC 可以选择 D 或者 E 作为父结点。\nB 可以选择 C 或 D 或 E 作为父结点。\nA 可以选择 B 或 C 或 D 或 E 作为父结点。\n又由于堆的大小为 5，堆的结构固定，一共三层。\nE 只能为根节点\nD 可以在左侧或者右侧\n当 D 在左侧时，\nD 的子结点可以在 A B C 中任取两个，剩下一个当 E 的右侧子结点\n总共有 A(3, 2) = 6 种\n当 D 在右侧时，\nC 的子结点只能取 A 和 B ，故只有 A(2, 2) = 2 种情况。\n综上，最大堆总共有 6 + 2 = 8 种构造堆的方式。\n最小堆的构造同理，也有 8 种构造方式。\n故总共有 8 + 8 = 16 种构造方式。\n构造方式（最大堆）：\n最大堆\nB 只能作为 B 的子结点，A 可以是 B 或 A 的子结点。\n根节点恒为 B\n第二层结点有两种选择 A B 和 B A\n第三层只有一种选择 A A\n故总共有两种构造堆的方式。\n最小堆\n根节点恒为 A\n第二层可以是 A A 或 A B\n第二层是 A A 时\n第三层只能选择 B B\n第二层时 A B 时\n第三层可选择 A B 或 B A\n故总共有三种构造堆的方式。\n综上所述，总共有 2 + 3 = 5 种构造方式。\n构造方式（全部）：\n"},{"id":286,"href":"/2-4-10/","title":"2.4.10","section":"帮助","content":"2.4.10 #  解答 #  左子树位于 $2k+1$，右子树位于 $2k+2$，父结点位于 $\\lfloor (i-1)/2 \\rfloor$ 。\n"},{"id":287,"href":"/2-4-11/","title":"2.4.11","section":"帮助","content":"2.4.11 #  解答 #  有大量插入操作，选择插入操作为常数级别的无序数组实现较为合适。\n"},{"id":288,"href":"/2-4-12/","title":"2.4.12","section":"帮助","content":"2.4.12 #  解答 #  堆实现会略优于有序数组实现。\n有序数组，查找最大元素操作是 O(1) 的，插入/删除元素是 O(N) 的。\n堆要看具体实现，基于数组的实现和有序数组类似，但插入/删除元素的效率更优。\n注：\n官网给出的堆实现会在插入 / 删除操作之后对整个数组进行检查，\n确认是否为最大堆（isMaxHeap 方法）。\n在测试时务必删除/注释掉这部分代码。\n"},{"id":289,"href":"/2-4-13/","title":"2.4.13","section":"帮助","content":"2.4.13 #  解答 #  在官方实现的基础上直接删除 j\u0026lt;N 语句，随后在 DelMax() 方法中在 Sink(1) 之前让 pq[n + 1] = pq[1] 即可。\n首先保存最大值，然后把堆中的第一个元素和最后一个元素交换，随后使 n = n - 1。\n随后让 pq[n + 1] = pq[1]，这样在下沉操作时就不会下沉到 pq[n + 1]了。（相等的元素是不会交换的）\n故之后的 Sink() 语句中不再需要进行边界判断，直接删去即可。\n修改后 DelMax() 的代码如下：\npublic Key DelMax() { if (IsEmpty()) throw new ArgumentOutOfRangeException(\u0026#34;Priority Queue Underflow\u0026#34;); Key max = this.pq[1]; Exch(1, this.n--); pq[n + 1] = pq[1]; Sink(1); this.pq[this.n + 1] = default(Key); if ((this.n \u0026gt; 0) \u0026amp;\u0026amp; (this.n == this.pq.Length / 4)) Resize(this.pq.Length / 2); Debug.Assert(IsMaxHeap()); return max; } "},{"id":290,"href":"/2-4-14/","title":"2.4.14","section":"帮助","content":"2.4.14 #  解答 #  对于 n \u0026lt;= 2 的堆\n第一步让最大元素和末端元素交换。\n第二步下沉时由于 n \u0026lt;= 1，不需要交换。\n故总共发生了一次交换，两个元素发生了交换。\n对于 n = 3 的堆\n第一步让最大元素和末端元素交换。\n第二步如果末端元素大于另一侧的子结点，那么就不需要交换。\n故最优情况时总共发生一次交换，两个元素被交换。\n对于 n \u0026gt; 3 的堆。\n第一步需要让最末端元素和最大元素交换。\n由于堆中第二大的元素必定位于根节点之后。\n故最末端元素一定小于该第二大元素。\n因此在下沉操作时必定会和第二大元素进行交换。\n故至少发生两次交换，总共有三个元素发生了交换。\n构造的堆（n=15）\n92 和 100 交换，随后 92 和 99 交换\n构造最优情况堆的方式如下（取根结点为 100）：\n对于每个结点，左子结点大于右子结点，\n且左子结点的子元素都小于右子树的最小值，\n（上例中省略了这部分元素，可以将它们当作负数）\n于是第一次 DelMax 的时候，只需要两次交换，三个元素被交换。\n（即 87 最后被交换到上例中 99 的位置）\n第二次 DelMax 的时候，只需要三次交换，六个元素被交换.\n（88 交换到 97 的位置）\n因此当 n \u0026gt; 7 时，连续两次 DelMax() 最少只需要 5 次交换。\n第三次 DelMax 的时候，只需要四次交换，九个元素被交换。\n（89 交换到 95 的位置）\n因此当 n \u0026gt; 15 时，连续三次 DelMax() 最少只需要 9 次交换。\n"},{"id":291,"href":"/2-4-15/","title":"2.4.15","section":"帮助","content":"2.4.15 #  解答 #  MinPQ 的官方实现见：https://algs4.cs.princeton.edu/24pq/MinPQ.java.html\n事实上只需要把 MaxPQ 中的比较调换方向即可。\n在线性时间内检测是否是面向最小元素的堆的方法：\n/// \u0026lt;summary\u0026gt; /// 确定以 k 为根节点的二叉树是不是一个最小堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要检查的二叉树根节点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private bool IsMinHeap(int k) { if (k \u0026gt; this.n) return true; int left = 2 * k; int right = 2 * k + 1; if (left \u0026lt;= this.n \u0026amp;\u0026amp; Greater(k, left)) return false; if (right \u0026lt;= this.n \u0026amp;\u0026amp; Greater(k, right)) return false; return IsMinHeap(left) \u0026amp;\u0026amp; IsMinHeap(right); } 用递归方法遍历整个二叉树，确认都满足堆的性质。由于每个结点都只会被比较三次（与父结点比较一次，与每个子结点各比较一次），由于 3N~N，因此这个方法是 O(n) 的。\n代码 #  最小堆的接口 IMinPQ。\nusing System; namespace PriorityQueue { /// \u0026lt;summary\u0026gt;  /// 实现优先队列 API 的接口。（最小堆）  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Key\u0026#34;\u0026gt;优先队列容纳的元素。\u0026lt;/typeparam\u0026gt;  public interface IMinPQ\u0026lt;Key\u0026gt; where Key : IComparable\u0026lt;Key\u0026gt; { /// \u0026lt;summary\u0026gt;  /// 向优先队列中插入一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;插入元素的类型。\u0026lt;/param\u0026gt;  void Insert(Key v); /// \u0026lt;summary\u0026gt;  /// 返回最小元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  Key Min(); /// \u0026lt;summary\u0026gt;  /// 删除并返回最小元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  Key DelMin(); /// \u0026lt;summary\u0026gt;  /// 返回队列是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  bool IsEmpty(); /// \u0026lt;summary\u0026gt;  /// 返回队列中的元素个数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  int Size(); } } MinPQ.cs\nusing System; using System.Collections; using System.Collections.Generic; using System.Diagnostics; namespace PriorityQueue { /// \u0026lt;summary\u0026gt;  /// 最小堆。（数组实现）  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Key\u0026#34;\u0026gt;最小堆中保存的元素类型。\u0026lt;/typeparam\u0026gt;  public class MinPQ\u0026lt;Key\u0026gt; : IMinPQ\u0026lt;Key\u0026gt;, IEnumerable\u0026lt;Key\u0026gt; where Key : IComparable\u0026lt;Key\u0026gt; { private Key[] pq; // 保存元素的数组。  private int n; // 堆中的元素数量。  /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public MinPQ() : this(1) { } /// \u0026lt;summary\u0026gt;  /// 建立指定容量的最小堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;最小堆的容量。\u0026lt;/param\u0026gt;  public MinPQ(int capacity) { this.pq = new Key[capacity + 1]; this.n = 0; } /// \u0026lt;summary\u0026gt;  /// 从已有元素建立一个最小堆。（O(n)）  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;keys\u0026#34;\u0026gt;已有元素。\u0026lt;/param\u0026gt;  public MinPQ(Key[] keys) { this.n = keys.Length; this.pq = new Key[keys.Length + 1]; for (int i = 0; i \u0026lt; keys.Length; i++) this.pq[i + 1] = keys[i]; for (int k = this.n / 2; k \u0026gt;= 1; k--) Sink(k); Debug.Assert(IsMinHeap()); } /// \u0026lt;summary\u0026gt;  /// 删除并返回最小元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key DelMin() { if (IsEmpty()) throw new ArgumentOutOfRangeException(\u0026#34;Priority Queue Underflow\u0026#34;); Key min = this.pq[1]; Exch(1, this.n--); this.pq[this.n + 1] = this.pq[1]; Sink(1); this.pq[this.n + 1] = default(Key); if ((this.n \u0026gt; 0) \u0026amp;\u0026amp; (this.n == this.pq.Length / 4)) Resize(this.pq.Length / 2); //Debug.Assert(IsMinHeap());  return min; } /// \u0026lt;summary\u0026gt;  /// 向堆中插入一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;需要插入的元素。\u0026lt;/param\u0026gt;  public void Insert(Key v) { if (this.n == this.pq.Length - 1) Resize(2 * this.pq.Length); this.pq[++this.n] = v; Swim(this.n); //Debug.Assert(IsMinHeap());  } /// \u0026lt;summary\u0026gt;  /// 检查堆是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() =\u0026gt; this.n == 0; /// \u0026lt;summary\u0026gt;  /// 获得堆中最小元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key Min() =\u0026gt; this.pq[1]; /// \u0026lt;summary\u0026gt;  /// 获得堆中元素的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() =\u0026gt; this.n; /// \u0026lt;summary\u0026gt;  /// 获取堆的迭代器，元素以降序排列。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public IEnumerator\u0026lt;Key\u0026gt; GetEnumerator() { MaxPQ\u0026lt;Key\u0026gt; copy = new MaxPQ\u0026lt;Key\u0026gt;(this.n); for (int i = 1; i \u0026lt;= this.n; i++) copy.Insert(this.pq[i]); while (!copy.IsEmpty()) yield return copy.DelMax(); // 下次迭代的时候从这里继续执行。  } /// \u0026lt;summary\u0026gt;  /// 获取堆的迭代器，元素以降序排列。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } /// \u0026lt;summary\u0026gt;  /// 使元素上浮。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要上浮的元素。\u0026lt;/param\u0026gt;  private void Swim(int k) { while (k \u0026gt; 1 \u0026amp;\u0026amp; Greater(k / 2, k)) { Exch(k, k / 2); k /= 2; } } /// \u0026lt;summary\u0026gt;  /// 使元素下沉。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要下沉的元素。\u0026lt;/param\u0026gt;  private void Sink(int k) { while (k * 2 \u0026lt;= this.n) { int j = 2 * k; if (Greater(j, j + 1)) j++; if (!Greater(k, j)) break; Exch(k, j); k = j; } } /// \u0026lt;summary\u0026gt;  /// 重新调整堆的大小。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;调整后的堆大小。\u0026lt;/param\u0026gt;  private void Resize(int capacity) { Key[] temp = new Key[capacity]; for (int i = 1; i \u0026lt;= this.n; i++) { temp[i] = this.pq[i]; } this.pq = temp; } /// \u0026lt;summary\u0026gt;  /// 判断堆中某个元素是否大于另一元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;判断是否较大的元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;判断是否较小的元素。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private bool Greater(int i, int j) =\u0026gt; this.pq[i].CompareTo(this.pq[j]) \u0026gt; 0; /// \u0026lt;summary\u0026gt;  /// 交换堆中的两个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要交换的第一个元素下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;要交换的第二个元素下标。\u0026lt;/param\u0026gt;  private void Exch(int i, int j) { Key swap = this.pq[i]; this.pq[i] = this.pq[j]; this.pq[j] = swap; } /// \u0026lt;summary\u0026gt;  /// 检查当前二叉树是不是一个最小堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private bool IsMinHeap() =\u0026gt; IsMinHeap(1); /// \u0026lt;summary\u0026gt;  /// 确定以 k 为根节点的二叉树是不是一个最小堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要检查的二叉树根节点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private bool IsMinHeap(int k) { if (k \u0026gt; this.n) return true; int left = 2 * k; int right = 2 * k + 1; if (left \u0026lt;= this.n \u0026amp;\u0026amp; Greater(k, left)) return false; if (right \u0026lt;= this.n \u0026amp;\u0026amp; Greater(k, right)) return false; return IsMinHeap(left) \u0026amp;\u0026amp; IsMinHeap(right); } } } 另请参阅 #  PriorityQueue 库\n"},{"id":292,"href":"/2-4-16/","title":"2.4.16","section":"帮助","content":"2.4.16 #  解答 #  最好情况比较简单，只需要一个所有键值完全相同的数组即可。\n最坏情况的构造方法参考了一篇论文（见「另请参阅」部分），结果如下：\n最好输入：\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n最坏输入：\n1 4 7 12 10 16 14 19 17 20 5 27 8 28 2 24 9 18 6 23 11 22 21 31 13 26 25 30 15 29 3 32\n代码 #  用于构造堆排序最坏情况的类。\nusing System; using System.Collections; using System.Collections.Generic; using System.Diagnostics; namespace PriorityQueue { /// \u0026lt;summary\u0026gt;  /// 生成最大堆的最坏情况。参考论文：https://arxiv.org/abs/1504.01459  /// \u0026lt;/summary\u0026gt;  public class MaxPQWorstCase { private int[] pq; // 保存元素的数组。  private int n; // 堆中的元素数量。  /// \u0026lt;summary\u0026gt;  /// 建立指定容量的最大堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;最大堆的容量。\u0026lt;/param\u0026gt;  public MaxPQWorstCase(int capacity) { this.pq = new int[capacity + 1]; this.n = 0; } /// \u0026lt;summary\u0026gt;  /// 制造堆排序的最坏情况。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;需要构造的数组大小。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;最坏情况的输入数组。\u0026lt;/returns\u0026gt;  public int[] MakeWorst(int n) { int[] strategy = Win(n); for (int i = 0; i \u0026lt; strategy.Length; i++) { UnRemoveMax(strategy[i]); } for (int i = 1; i \u0026lt;= this.n / 2; i++) UnFixHeap(i); int[] worstCase = new int[n]; for (int i = 1; i \u0026lt;= n; i++) worstCase[i - 1] = this.pq[i]; return worstCase; } private bool Less(int i, int j) =\u0026gt; this.pq[i].CompareTo(this.pq[j]) \u0026lt; 0; private int PullDown(int i, int j) { int toReturn = this.pq[j]; for (int m = j; m / 2 \u0026gt;= i; m /= 2) { this.pq[m] = this.pq[m / 2]; } return toReturn; } private void UnFixHeap(int i) { int j = (int)(i * Math.Pow(2, Math.Floor(Math.Log10(this.n / i) / Math.Log10(2)))); this.pq[i] = PullDown(i, j); } private void UnRemoveMax(int i) { int p = (this.n + 1) / 2; if (Less(p, i)) return; this.n++; this.pq[this.n] = PullDown(1, i); this.pq[1] = this.n; } private int[] Par(int l) { int n = (int)Math.Pow(2, l) - 1; int[] s7 = { 0, 1, 2, 3, 4, 4, 5 }; int[] strategy = new int[n]; for (int i = 0; i \u0026lt; Math.Min(n, 7); i++) { strategy[i] = s7[i]; } if (n \u0026lt;= 7) return strategy; for (int lev = 3; lev \u0026lt; l; lev++) { int i = (int)Math.Pow(2, lev) - 1; strategy[i] = i; strategy[i + 1] = i - 1; strategy[i + 2] = i + 1; strategy[i + 3] = i + 2; strategy[i + 4] = i + 4; strategy[i + 5] = i + 3; for (int k = i + 6; k \u0026lt;= 2 * i; k++) { strategy[k] = k - 1; } } return strategy; } private int[] Win(int n) { int[] strategy = new int[n]; int[] s = Par((int)Math.Floor(Math.Log10(n) / Math.Log10(2)) + 1); for (int i = 1; i \u0026lt;= n - 1; i++) { strategy[i] = s[i]; } int I = (int)Math.Pow(2, Math.Floor(Math.Log10(n + 1) / Math.Log10(2))) - 1; if ((n == I) || (n \u0026lt;= 7)) return strategy; strategy[I] = I; if (n == I + 1) return strategy; strategy[I + 1] = (I + 1) / 2; if (n == I + 2) return strategy; for (int i = I + 2; i \u0026lt;= n - 1; i++) { if (i == 2 * I - 2) strategy[i] = i; else strategy[i] = i - 1; } return strategy; } } } 另请参阅 #  给出堆排序最坏情况构造方法的论文\nSuchenek M A. A Complete Worst-Case Analysis of Heapsort with Experimental Verification of Its Results, A manuscript (MS)[J]. arXiv preprint arXiv:1504.01459, 2015.\n本题用到的库文件\nPriorityQueue 库\n"},{"id":293,"href":"/2-4-17/","title":"2.4.17","section":"帮助","content":"2.4.17 #  解答 #  英文版原文是：insert followed by remove the minimum，因此是先插入再删除。\n大致上相当于一个缓冲区，把比较大的留下来，比较小的筛出去。\n首先我们有一个大小为 k 的优先队列，保证最小值在最前。\n接下来我们插入一个元素，可以分成两种情况。\n如果插入的元素比最小值还要小，那么这个插入的元素会在之后被删除，原队列中的元素不变。\n如果插入的元素比最小值大（或者相等），那么最小值会被删除，留下插入的元素。\n于是可以观察到这样一个逻辑，在不断的插入过程中，比较小的元素会被过滤，只留下较大的元素。\n那么我们可以把题目转化为：\n向一个优先队列插入 N 个元素，保证队列的大小不超过 k，如果超过 k 了就删除最小值。\n那么前 k 次插入不受影响，之后的 N-k 次插入就会按照之前说过的流程进行。\n最后只留下 N 个元素中较大的 k 个元素，得证。\n"},{"id":294,"href":"/2-4-18/","title":"2.4.18","section":"帮助","content":"2.4.18 #  解答 #  首先看第一种情况，一次 insert() 接一次 delMax()。\n由于插入的数比堆中的所有元素都大，这个元素会一路上升到根结点。\n记上升路径上的点为 $a_1,a_2,a_3, \\dots , a_k$，其中 $a_k$是插入的结点，$a_1$ 是根结点。\n插入完成后路径上点的次序变为 $a_k, a_1, a_2, \\dots, a_{k-1}$ 。\n随后进行一次 delMax()，先做交换，次序变为 $a_{k-1}, a_1, \\dots, a_{k-2}, a_k$ 。\n由于 $a_1$ 是堆中原来的最大值，下沉时一定会和它交换。\n根据定义，二叉堆是父结点总是优于子结点的完全二叉树，因此以后续结点作为根结点的子树也都是堆。\n故同理 $a_{k-1}$ 会和 $a_2, a_3, \\dots,a_{k-2}$ 交换，即沿原路径返回。\n因此这种情况下前后堆不发生改变。\n然后看第二种情况，操作顺序为 insert() insert() delMax() delMax()。\n根据之前的结论，插入最大结点之后立即删除最大元素不会使堆发生变化，中间的两个操作抵消。\n序列变为：insert() delMax()。\n同理再次利用刚才的结论，操作抵消，堆不发生变化。\n故第二种情况也不会使堆发生改变。\n"},{"id":295,"href":"/2-4-19/","title":"2.4.19","section":"帮助","content":"2.4.19 #  解答 #  官方实现已经包含了这部分的代码，见：https://algs4.cs.princeton.edu/24pq/MaxPQ.java.html\n相应的构造函数（Java）\npublic MaxPQ(Key[] keys) { n = keys.length; pq = (Key[]) new Object[keys.length + 1]; for (int i = 0; i \u0026lt; n; i++) pq[i+1] = keys[i]; for (int k = n/2; k \u0026gt;= 1; k--) sink(k); assert isMaxHeap(); } 代码 #  构造函数（C#）\n/// \u0026lt;summary\u0026gt; /// 从已有元素建立一个最大堆。（O(n)） /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;keys\u0026#34;\u0026gt;已有元素。\u0026lt;/param\u0026gt; public MaxPQ(Key[] keys) { this.n = keys.Length; this.pq = new Key[keys.Length + 1]; for (int i = 0; i \u0026lt; keys.Length; i++) this.pq[i + 1] = keys[i]; for (int k = this.n / 2; k \u0026gt;= 1; k--) Sink(k); Debug.Assert(IsMaxHeap()); } 另请参阅 #  PriorityQueue 库\n"},{"id":296,"href":"/2-4-20/","title":"2.4.20","section":"帮助","content":"2.4.20 #  解答 #  官网给出了解答：https://algs4.cs.princeton.edu/24pq/\n首先介绍第一种解法。\n设叶子结点的高度为 $0$，根结点的高度为 $ h ​$。\n于是某个结点 sink 时的最大交换次数即为该结点的高度。\n故某一层结点的最大交换次数为 该层结点数 × 该层的高度。\n于是总交换次数最大为：\n$$\n\\begin{align*}\n\u0026amp; h+2(h-1)+2^2(h-2)+ \\dots + 2^h(0) \\\n\u0026amp; =\\sum_{k=0}^{h-1} 2^k(h-k) \\\n\u0026amp; =h\\sum_{k=0}^{h-1}2^k - \\sum_{k=0}^{h-1}k2^k \\\n\\end {align*}\n$$\n第一项为等比数列的和，第二项为等差数列乘以等比数列的和。\n于是第一项可以直接通过公式求得，第二项可以利用错位相减法求得。\n$$\n\\begin{align}\n\u0026amp; h\\sum_{k=0}^{h-1}2^k - \\sum_{k=0}^{h-1}k2^k \\\n\u0026amp; =h2^{h}-h-\\sum_{k=0}^{h-1}k2^k \\\n\u0026amp; =h2^{h}-h +\\sum_{k=0}^{h-1} k2^k - 2\\sum_{k=0}^{h-1} k2^k \\\n\u0026amp; =h2^{h}-h+2^h - 2-(h-1)2^h \\\n\u0026amp; =2^{h+1}-h-2 \\\n\u0026amp; =N-h-1 \\le N\n\\end{align}\n$$\n于是交换次数小于 $N$，比较次数小于 $2N$。\n另一种解法，可以配合官网的图片帮助理解。\n首先堆中某个结点最多一路下沉到叶子结点，\n最大交换次数就是该结点的高度（记叶子结点的高度为 0）。\n考虑根结点一路下沉到叶子结点的轨迹，\n设为 $a_0, a_1, a_2, \u0026hellip; , a_k$，其中 $k$ 为根结点的高度，$a_0$ 是根结点。\n$a_0$ 下沉后结点顺序变为 $a_1, a_2, \u0026hellip;, a_k, a_0$ 。\n根据下沉的定义，有 $a_1 \u0026gt; a_2 \u0026gt; \\dots \u0026gt; a_k \u0026gt; a_0$ 。\n因此 $a_1$ 下沉时不可能与 $a_2$ 交换，而会向另一个方向下沉。\n其余结点同理，可以发现每个结点的下沉路径不会与其他结点重合。\n一棵完全二叉树共有 $N - 1$ 条边，每访问一条边代表进行了一次交换。\n故交换次数必定小于 $N$，比较次数为交换次数的两倍小于 $2N$。\n"},{"id":297,"href":"/2-4-21/","title":"2.4.21","section":"帮助","content":"2.4.21 #  解答 #  给元素添上序号组成结点，按照序号排序即可，每个结点可以用类似于这样的实现：\nclass ElemType\u0026lt;T\u0026gt; : IComparable\u0026lt;ElemType\u0026lt;T\u0026gt;\u0026gt; { private int key; private T element; public ElemType(int key) =\u0026gt; this.key = key; public int CompareTo(ElemType\u0026lt;T\u0026gt; other) { return this.key.CompareTo(other.key); } } 栈：\n用最大元素在最前的优先队列。\n每个结点都包含一个元素和一个序号，\n插入新元素时序号递增，这样最后插入的元素总在最前。\n队列：\n用最小元素在最前的优先队列。\n每个结点都包含一个元素和一个序号，\n插入新元素时序号递增，这样最先插入的元素总在最前。\n随机队列：\n优先队列的选择任意\n每个结点都包含一个元素和一个序号，\n插入新元素时随机指定一个序号，这样元素的顺序就是任意的了。\n"},{"id":298,"href":"/2-4-22/","title":"2.4.22","section":"帮助","content":"2.4.22 #  解答 #  官方实现中已经包含了调整数组大小的代码，见：https://algs4.cs.princeton.edu/24pq/MaxPQ.java.html\n截取如下：\n// helper function to double the size of the heap array  private void resize(int capacity) { assert capacity \u0026gt; n; Key[] temp = (Key[]) new Object[capacity]; for (int i = 1; i \u0026lt;= n; i++) { temp[i] = pq[i]; } pq = temp; } 只要在队列快满时重新分配空间，再把元素复制进去即可。\n在不触发重新分配空间的情况下，\n每次队列操作的比较次数上限就等于命题 Q 中给出的 $\\lg N+1$（插入） 和 $2\\lg N$（删除）。\n插入元素最多需要 $\\lg N$ 次交换（比较次数-1），\n删除元素最多需要 $1 + \\lg N - 1 = \\lg N$ 次交换 （注意开始时有一次交换）。\n同时一次比较需要 $2$ 次数组访问，一次交换需要 $4$ 次数组访问（记 a[i] 为一次数组访问）。\n换算成数组访问次数就是 $6 \\lg N + 2$（插入）和 $8 \\lg N$ （删除）。\n在触发重新分配空间的情况下，需要额外的 $2N$ 次数组访问来重新分配空间。\n故上限为 $6 \\lg N +2N + 2$ 和 $8 \\lg N + 2N$。\n如果取均摊分析，那么相当于把多出来的 $2N$ 次访问平均到 $N$ 次操作中。\n设第 $n$ 次插入触发了重新分配空间，$n$ 是 $2$ 的幂。\n重新分配空间进行了 $2 + 4 + 8 + 16 + \u0026hellip; + 2n = 2n - 2$ 次数组访问。\n平均到 $n$ 次插入过程，每次插入多进行 $2 - 2 / n$ 次数组访问。\n于是插入的上限变为 $6 \\lg N + 4 - 2 / N$。\n同理删除的上限变为 $8 \\lg N + 2 - 2 / N$。\n代码 #  重新分配空间（C#）\n/// \u0026lt;summary\u0026gt; /// 重新调整堆的大小。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;调整后的堆大小。\u0026lt;/param\u0026gt; private void Resize(int capacity) { Key[] temp = new Key[capacity]; for (int i = 1; i \u0026lt;= this.n; i++) { temp[i] = this.pq[i]; } this.pq = temp; } 另请参阅 #  PriorityQueue 库\n"},{"id":299,"href":"/2-4-23/","title":"2.4.23","section":"帮助","content":"2.4.23 #  解答 #  简单的 sink 实现 #  sink 方法会在所有的 $t$ 个子结点中寻找最大的结点。\n如果找到的结点比当前结点大，那么就进行交换。\n否则视为结点已经下沉到了合适的位置，结束循环。\n根据题意，在 $t$ 个元素中找最大值需要 $t$ 次比较。\nsink 操作需要找到 $t$ 个子结点中的最大值并与当前结点相比较。\n于是 sink 操作每次最多需要 $t + 1$ 次比较。\n建堆过程，对 2.4.20 的证明进行推广。\n设 $t$ 叉树的高度为 $h$ ，叶子结点的高度为 $0$，根结点的高度为 $h$。\n根据 sink 操作的定义，高度为 $k$ 的结点最多进行 $k$ 次交换（到达叶子结点）。\n于是建堆需要的总交换次数为：\n$$\n\\begin{align*}\n\u0026amp; h+t(h-1)+t^2(h-2)+ \\dots + t^h(0) \\\n\u0026amp; =\\sum_{k=0}^{h-1} t^k(h-k) \\\n\u0026amp; =h\\sum_{k=0}^{h-1}t^k - \\sum_{k=0}^{h-1}kt^k \\\n\\end {align*}\n$$\n其中，第一个数列是等比数列，第二个数列是等差数列和等比数列之积，可以利用错位相减法求得，即：\n$$\n\\begin{align*}\n\u0026amp; h\\sum_{k=0}^{h-1}t^k - \\sum_{k=0}^{h-1}kt^k \\\n\u0026amp; =\\frac{h-ht^{h}}{1-t}-\\sum_{k=0}^{h-1}kt^k \\\n\u0026amp; =\\frac{h-ht^{h}}{1-t} -\\frac{\\sum kt^k - t\\sum kt^k}{1-t} \\\n\u0026amp; =\\frac{h-ht^h}{1-t}-\\frac{t(1-t^{h-1})}{(1-t)^2}+\\frac{(h-1)t^h}{1-t} \\\n\u0026amp; =\\frac{h-t^h}{1-t}-\\frac{t(1-t^{h-1})}{(1-t)^2} \\\n\u0026amp; =\\frac{h-ht+t^{h+1}-t}{(1-t)^2}\n\\end{align*}\n$$\n考虑到对于 $t$ 叉堆，结点数可以表示为 $n=\\frac{t^{h+1}-1}{t-1}$ 。故交换次数可以化简为：\n$$\n\\begin{align*}\n\u0026amp; \\frac{h-ht+t^{h+1}-t}{(1-t)^2} \\\n\u0026amp; =\\frac{h-ht+t^{h+1}-t +1-1}{(1-t)^2} \\\n\u0026amp; =\\frac{t^{h+1}-1}{(1-t)^2}+\\frac{h-ht-t+1}{(1-t)^2} \\\n\u0026amp; =-\\frac{n}{1-t}+\\frac{h}{1-t}+\\frac{1}{1-t} \\\n\u0026amp; =\\frac{n-h-1}{t-1} \\le n\n\\end{align*}\n$$\n故建堆所需比较次数最大为 $(t+1)n$ 。\n每次删除最大元素都会对根结点调用一次 sink 操作，\n因此排序所需的比较次数最多为 $(t+1)n\\log_t(n)$ 。\n相加得堆排序所需的总交换次数最多为 $ (t+1)n + (t+1)n\\log_t(n) =(t+1)(n\\log_tn+n)$ 。\n利用换底公式将对数的底换成 2，得到：$\\frac{t+1}{\\lg t} n\\log n$ 。\n于是问题变为求 $f(t)= \\frac{t+1}{\\lg t}$ 的最小值，对其求导，得到：\n$$\n( \\frac{t+1}{\\lg t} )'=\\frac{-t+t\\ln t-1}{t\\ln^2t}·\\ln 2\n$$\n直接求导数的零点会比较困难，但利用勘根公式可以寻找到根所在的区间。\n由于 $\\ln 2$ 不影响正负，我们直接将其去掉，变为：\n$$\n\\frac{-t+t\\ln t-1}{t\\ln^2t}=\\frac{-1+\\ln t-\\frac{1}{t}}{\\ln^2t}\n$$\n由于 $t \u0026gt; 1$，分母总是为正，因此导函数正负就等于下面这个函数的正负：\n$$\n\\begin {align*}\ng(t)=\\ln t -1-\\frac{1}{t}\n\\end {align*}\n$$\n$t = e$ 时 $g(t) \u0026lt; 0$，$t=e+1$ 时 $g(t) \u0026gt; 0$。于是可以求得在 $(e, e+1)$ 上 $f(t)$ 存在极小值。\n又由于 $g(t)$ 在 $(e + 1, +\\infty)$ 始终为正，因此在 $(e, e+1)$ 上存在的是最小值（$t \\ge 2$）。\n因为 $t$ 为大于 $1$ 的正整数，且 $f(4) \u0026lt; f(3)$，故 $t=4$ 时系数最小，此时系数为 $2.5$ 。\nFloyd 方法 #  在删除最大元素的过程中，根结点会和最后一个结点交换，然后对新的根结点执行 sink 操作。\n大多数情况下，这个结点会被一路交换到树的最后一层。\n因此我们省去 sink 操作中与自己比较的过程，直接和子结点中的较大者进行交换。\n这样一路交换到树的底部，随后再让这个结点与自己的父结点比较，向上「回到」合适的位置。\n大多数结点都不需要向上交换，\n因此这样的优化可以减少比较次数（下降一层需要的比较次数从 $t+1$ 变为 $t$）。\n利用 Floyd 方法对于建堆没有影响（建堆也可以使用 Floyd 方法，参见「另请参阅」部分）。\n于是建堆的比较次数仍为 $(t+1)n$ 。\n排序的比较次数变为 $tn\\log_t(n)$ 。\n总的比较次数变为 $(t+1)n + tn\\log_t(n)$ 。\n我们仍然只关心 $n\\lg n$ 的系数，系数为 $f(t)= \\frac{t}{\\lg t}$ 。\n按照之前的方法再求一次最小值，求得 $t = 3$ 时系数最小，此时系数为 $1.89$ 。\n另请参阅 #  Floyd 提出的堆排序优化\nFloyd R W. Algorithm 245: treesort[J]. Communications of the ACM, 1964, 7(12): 701.\n通过将这种方法应用到建堆获得的快速建堆方法\nMcDiarmid C J H, Reed B A. Building heaps fast[J]. Journal of algorithms, 1989, 10(3): 352-365.\n"},{"id":300,"href":"/2-4-24/","title":"2.4.24","section":"帮助","content":"2.4.24 #  解答 #  链式实现，每个结点都包含一个指向父结点的指针和两个指向子结点的指针。\n交换结点可以直接用交换两个结点的值来实现（与数组的实现一样），而不是对两个结点的指针进行交换。\n于是 Sink() 和 Swim() 操作就比较简单，直接按照定义实现即可。\n比较困难的是删除和插入结点，或者更具体的说，\n如何找到按照完全二叉树定义下序号向后/向前一位的结点？\n我们首先在堆里面维护两个指针，一个指向根结点（root），另一个指向当前最后一个结点（last）。\n当需要插入新结点时，我们需要找到 last 的后一位的父结点，然后把新的结点插入为该结点的左子结点。\n这段话可能比较绕，下面这个示意图可以帮助理解，有三种情况：\n标黄的代表 last 指着的位置。\n我们先从简单的说起，中间的第二种情况，新插入的结点应该放在右侧，即作为 last 的父结点的右子结点。\n如果 last 已经是右子结点了，那么就考虑第三种情况。\n此时应该向上回溯，直到在某一次回溯中，结点是从父结点的左侧回溯上来的\n（即图中路径 A-B-B，B-B 这一步是从左子树回溯上来的）。\n于是待插入的位置就在该父结点的右子树的最左侧结点（即图中根结点的右子结点 A）。\n最后是图中第一种情况，整棵树已经是满二叉树了。\n这种情况下会一路回溯到根结点，那么只要一路下沉到最左侧的叶子结点，把新结点插入到其左子树上即可。\n删除结点同理，也是这三种情况，只是需要找前一个结点，判断条件中的左右正好相反。\n如果已经是右子结点了，只需要把 last 改为其父结点的左子树即可。\n如果是左子结点，就需要回溯，直到某一次回溯是从右子树回溯上来的，last 应该指向其左子树的最右侧结点。\n如果删除后正好变成满二叉树，那么会一直回溯到根结点，last 应该指向整棵树的最右侧结点。\n代码实现中还需要处理只有一个结点以及没有结点时的特殊情况。\n根据上面的算法，插入/删除找到相应位置所需的最大耗时为 2lgN\n（从树的一侧回溯到根结点，再下沉到另一侧的底部）。\nSink 和 Swim 是 O(lgN) 级的，因此整个插入/删除操作是 O(lgN) 的。\n代码 #  using System; namespace PriorityQueue { /// \u0026lt;summary\u0026gt;  /// 基于链式结构实现的最大堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Key\u0026#34;\u0026gt;优先队列中保存的数据类型。\u0026lt;/typeparam\u0026gt;  public class MaxPQLinked\u0026lt;Key\u0026gt; : IMaxPQ\u0026lt;Key\u0026gt; where Key : IComparable\u0026lt;Key\u0026gt; { /// \u0026lt;summary\u0026gt;  /// 二叉堆的根结点。  /// \u0026lt;/summary\u0026gt;  private TreeNode\u0026lt;Key\u0026gt; root = null; /// \u0026lt;summary\u0026gt;  /// 二叉堆的最后一个结点。  /// \u0026lt;/summary\u0026gt;  private TreeNode\u0026lt;Key\u0026gt; last = null; /// \u0026lt;summary\u0026gt;  /// 二叉堆中的结点个数。  /// \u0026lt;/summary\u0026gt;  private int nodesCount = 0; /// \u0026lt;summary\u0026gt;  /// 建立一个链式结构的最大堆。  /// \u0026lt;/summary\u0026gt;  public MaxPQLinked() { } /// \u0026lt;summary\u0026gt;  /// 删除并返回最大值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;最大值。\u0026lt;/returns\u0026gt;  public Key DelMax() { Key result = this.root.Value; Exch(this.root, this.last); if (this.nodesCount == 2) { this.root.Left = null; this.last = this.root; this.nodesCount--; return result; } else if (this.nodesCount == 1) { this.last = null; this.root = null; this.nodesCount--; return result; } // 获得前一个结点。  TreeNode\u0026lt;Key\u0026gt; newLast = this.last; if (newLast == this.last.Prev.Right) newLast = this.last.Prev.Left; else { // 找到上一棵子树。  while (newLast != this.root) { if (newLast != newLast.Prev.Left) break; newLast = newLast.Prev; } // 已经是满二叉树。  if (newLast == this.root) { // 一路向右，回到上一层。  while (newLast.Right != null) newLast = newLast.Right; } // 不是满二叉树。  else { // 向左子树移动，再一路向右。  newLast = newLast.Prev.Left; while (newLast.Right != null) newLast = newLast.Right; } } // 删除最后一个结点。  if (this.last.Prev.Left == this.last) this.last.Prev.Left = null; else this.last.Prev.Right = null; Sink(this.root); // 指向新的最后一个结点。  this.last = newLast; this.nodesCount--; return result; } /// \u0026lt;summary\u0026gt;  /// 插入一个新的结点。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;待插入的结点。\u0026lt;/param\u0026gt;  public void Insert(Key v) { TreeNode\u0026lt;Key\u0026gt; item = new TreeNode\u0026lt;Key\u0026gt;(v); // 堆为空。  if (this.last == null) { this.root = item; this.last = item; this.nodesCount++; return; } // 堆只有一个结点。  if (this.last == this.root) { item.Prev = this.root; this.root.Left = item; this.last = item; this.nodesCount++; Swim(item); return; } // 定位到最后一个节点的父结点。  TreeNode\u0026lt;Key\u0026gt; prev = this.last.Prev; // 右子节点为空，插入到右子节点。  if (prev.Right == null) { item.Prev = prev; prev.Right = item; } else { // 当前子树已满，需要向上回溯。  // 找到下一个子树（回溯的时候是从左子树回溯上去的）。  while (prev != this.root) { if (prev != prev.Prev.Right) break; prev = prev.Prev; } // 已经是满二叉树。  if (prev == this.root) { // 一路向左，进入下一层。  while (prev.Left != null) prev = prev.Left; item.Prev = prev; prev.Left = item; } // 不是满二叉树。  else { // 向右子树移动，再一路向左。  prev = prev.Prev.Right; while (prev.Left != null) prev = prev.Left; item.Prev = prev; prev.Left = item; } } this.last = item; this.nodesCount++; Swim(item); return; } /// \u0026lt;summary\u0026gt;  /// 返回二叉堆是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() =\u0026gt; this.root == null; /// \u0026lt;summary\u0026gt;  /// 返回二叉堆中的最大值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key Max() =\u0026gt; this.root.Value; /// \u0026lt;summary\u0026gt;  /// 返回二叉堆中的元素个数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() =\u0026gt; this.nodesCount; /// \u0026lt;summary\u0026gt;  /// 使结点上浮。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要上浮的结点。\u0026lt;/param\u0026gt;  private void Swim(TreeNode\u0026lt;Key\u0026gt; k) { while (k.Prev != null) { if (Less(k.Prev, k)) { Exch(k.Prev, k); k = k.Prev; } else break; } } /// \u0026lt;summary\u0026gt;  /// 使结点下沉。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要下沉的结点。\u0026lt;/param\u0026gt;  private void Sink(TreeNode\u0026lt;Key\u0026gt; k) { while (k.Left != null || k.Right != null) { TreeNode\u0026lt;Key\u0026gt; toExch = null; if (k.Left != null \u0026amp;\u0026amp; k.Right != null) toExch = Less(k.Left, k.Right) ? k.Right : k.Left; else if (k.Left != null) toExch = k.Left; else toExch = k.Right; if (Less(k, toExch)) Exch(k, toExch); else break; k = toExch; } } /// \u0026lt;summary\u0026gt;  /// 交换二叉堆中的两个结点。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;要交换的第一个结点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;要交换的第二个结点。\u0026lt;/param\u0026gt;  private void Exch(TreeNode\u0026lt;Key\u0026gt; a, TreeNode\u0026lt;Key\u0026gt; b) { Key temp = a.Value; a.Value = b.Value; b.Value = temp; } /// \u0026lt;summary\u0026gt;  /// 比较第一个结点值的是否小于第二个。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;判断是否较小的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;判断是否较大的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private bool Less(TreeNode\u0026lt;Key\u0026gt; a, TreeNode\u0026lt;Key\u0026gt; b) =\u0026gt; a.Value.CompareTo(b.Value) \u0026lt; 0; } } 另请参阅 #  PriorityQueue 库\n"},{"id":301,"href":"/2-4-25/","title":"2.4.25","section":"帮助","content":"2.4.25 #  解答 #  官方实现：https://algs4.cs.princeton.edu/24pq/CubeSum.java.html\n注意这道题并不是要打印所有的 $a^3+b^3$ 的结果，而是需要找到 $a^3+b^3=c^3+d^3$ 这个丢番图方程的解。\n因此在官方实现的基础上，每次取出最小值之后和之前的最小值比较，如果相等则输出对应的组合。\n关键代码如下：\nCubeSum prev = new CubeSum(-1, -1); long pairCount = 0; while (!pq.IsEmpty()) { CubeSum s = pq.DelMin(); if (s.sum == prev.sum)\t// 如果与之前的数相等  { Console.WriteLine(s + \u0026#34; = \u0026#34; + prev.i + \u0026#34;^3 + \u0026#34; + prev.j + \u0026#34;^3\u0026#34;); pairCount++; } if (s.j \u0026lt; n) pq.Insert(new CubeSum(s.i, s.j + 1)); prev = s; } 当然，对于 n=10^6 来说结果会非常大，程序的运行时间需要以天为单位计算（约 14 天）。\nn=10^4 时，总共可以找到 41570 对数据。（result10K.txt, 下载大小 506 KB，解压后 1.93 MB）\nn=10^5 时，总共可以找到 895023 对数据。(result100K.txt，下载大小 12.7 MB，解压后 47.5 MB)\nn=10^6 时，总共可以找到 16953323 对数据。（result1M.txt，下载大小 280 MB，解压后 0.98 GB）\n结果下载链接：百度云、Onedrive\n代码 #  CubeSum.cs\nusing System; namespace _2._4._25 { /// \u0026lt;summary\u0026gt;  /// 立方和类，保存 a^3+b^3 的值。  /// \u0026lt;/summary\u0026gt;  class CubeSum : IComparable\u0026lt;CubeSum\u0026gt; { /// \u0026lt;summary\u0026gt;  /// 立方和。  /// \u0026lt;/summary\u0026gt;  internal readonly long sum; /// \u0026lt;summary\u0026gt;  /// 第一个数。  /// \u0026lt;/summary\u0026gt;  internal readonly long i; /// \u0026lt;summary\u0026gt;  /// 第二个数。  /// \u0026lt;/summary\u0026gt;  internal readonly long j; /// \u0026lt;summary\u0026gt;  /// 建立一个立方和类。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;立方和的第一个数。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;立方和的第二个数。\u0026lt;/param\u0026gt;  public CubeSum(long i, long j) { this.sum = i * i * i + j * j * j; this.i = i; this.j = j; } /// \u0026lt;summary\u0026gt;  /// 比较两个立方和的大小，返回 1, 0, -1 中的一个。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;需要与之比较的另一个数。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int CompareTo(CubeSum other) { return this.sum.CompareTo(other.sum); } /// \u0026lt;summary\u0026gt;  /// 返回 \u0026#34;sum = i^3 + j^3\u0026#34; 形式的字符串。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public override string ToString() { return this.sum + \u0026#34; = \u0026#34; + this.i + \u0026#34;^3 + \u0026#34; + this.j + \u0026#34;^3\u0026#34;; } } } 主程序\nusing System; using System.IO; using PriorityQueue; namespace _2._4._25 { /* * 2.4.25 * * 计算数论。 * 编写程序 CubeSum.java， * 在不使用额外空间的条件下， * 按大小顺序打印所有 a^3+b^3 的结果， * 其中 a 和 b 为 0 至 N 之间所有的整数。 * 也就是说，不要全部计算 N^2 个和然后排序， * 而是创建一个最小优先队列， * 初始状态为 (0^3, 0, 0),(1^3, 0, 0),(2^3, 2, 0),...,(N^3, N, 0)。 * 这样只要优先队列非空，删除并打印最小的元素 (i^3+j^3, i, j)。 * 然后如果 j\u0026lt;N，插入元素 (i^3+(j+1)^3, i, j+1)。 * 用这段程序找出 0 到 10^6 之间 * 所有满足 a^3+b^3 = c^3+d^3 的不同整数 a, b, c, d。 * */ class Program { static void Main(string[] args) { int n = 1000000; MinPQ\u0026lt;CubeSum\u0026gt; pq = new MinPQ\u0026lt;CubeSum\u0026gt;(); Console.WriteLine(\u0026#34;正在初始化\u0026#34;); for (int i = 0; i \u0026lt;= n; i++) { pq.Insert(new CubeSum(i, i)); } FileStream ostream = new FileStream(\u0026#34;./result.txt\u0026#34;, FileMode.Create, FileAccess.Write); StreamWriter sw = new StreamWriter(ostream); Console.WriteLine(\u0026#34;正在写入文件……\u0026#34;); CubeSum prev = new CubeSum(-1, -1); long pairCount = 0; while (!pq.IsEmpty()) { CubeSum s = pq.DelMin(); if (s.sum == prev.sum) { sw.WriteLine(s + \u0026#34; = \u0026#34; + prev.i + \u0026#34;^3 + \u0026#34; + prev.j + \u0026#34;^3\u0026#34;); pairCount++; } if (s.j \u0026lt; n) pq.Insert(new CubeSum(s.i, s.j + 1)); prev = s; } sw.WriteLine(\u0026#34;共找到\u0026#34; + pairCount + \u0026#34;对数据\u0026#34;); Console.WriteLine(\u0026#34;共找到\u0026#34; + pairCount + \u0026#34;对数据\u0026#34;); sw.Close(); Console.WriteLine(\u0026#34;结果已经保存到程序所在目录下的 result.txt 文件中\u0026#34;); } } } 另请参阅 #  Diophantine Equation-3rd Powers - Wolfram MathWorld\nPriorityQueue 库\n"},{"id":302,"href":"/2-4-26/","title":"2.4.26","section":"帮助","content":"2.4.26 #  解答 #  用类似于「半交换」的方法避免频繁调用 Exch() 方法。\n上浮时，先单独保存待上浮的元素，随后进行比较，\n如果当前 k 值对应的父结点（即 k/2 ）小于待上浮的元素，令 pq[k]=pq[k/2]。\n否则令当前 k 值等于待上浮的元素，终止循环。\n下沉的过程类似。\n修改后的 sink 和 swim 方法：\n/// \u0026lt;summary\u0026gt; /// 使元素上浮。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要上浮的元素。\u0026lt;/param\u0026gt; private void Swim(int k) { Key key = this.pq[k]; while (k \u0026gt; 1 \u0026amp;\u0026amp; this.pq[k / 2].CompareTo(key) \u0026lt; 0) { this.pq[k] = this.pq[k / 2]; k /= 2; } this.pq[k] = key; } /// \u0026lt;summary\u0026gt; /// 使元素下沉。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要下沉的元素。\u0026lt;/param\u0026gt; private void Sink(int k) { Key key = this.pq[k]; while (k * 2 \u0026lt;= this.n) { int j = 2 * k; if (Less(j, j + 1)) j++; if (this.pq[j].CompareTo(key) \u0026lt; 0) break; this.pq[k] = this.pq[j]; k = j; } this.pq[k] = key; } 另请参阅 #  PriorityQueue 库\n"},{"id":303,"href":"/2-4-27/","title":"2.4.27","section":"帮助","content":"2.4.27 #  解答 #  官网有解答，只要在 MaxPQ 里面加上一个记录最小值的指针就可以了。\n初始状态下这个指针为空。\n每次插入新元素的时候先更新一下这个指针。\n删除最后一个元素的时候把它重新置空即可。\n具体实现见代码。\n代码 #  using System; using System.Collections; using System.Collections.Generic; using System.Diagnostics; namespace PriorityQueue { /// \u0026lt;summary\u0026gt;  /// 包含最小元素引用的最大堆。（数组实现）  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Key\u0026#34;\u0026gt;最大堆中保存的元素类型。\u0026lt;/typeparam\u0026gt;  public class MaxPQWithMin\u0026lt;Key\u0026gt; : IMaxPQ\u0026lt;Key\u0026gt;, IEnumerable\u0026lt;Key\u0026gt; where Key : class, IComparable\u0026lt;Key\u0026gt; { private Key[] pq; // 保存元素的数组。  private int n; // 堆中的元素数量。  private Key min; // 堆中的最小元素。  /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public MaxPQWithMin() : this(1) { } /// \u0026lt;summary\u0026gt;  /// 建立指定容量的最大堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;最大堆的容量。\u0026lt;/param\u0026gt;  public MaxPQWithMin(int capacity) { this.pq = new Key[capacity + 1]; this.n = 0; this.min = null; } /// \u0026lt;summary\u0026gt;  /// 从已有元素建立一个最大堆。（O(n)）  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;keys\u0026#34;\u0026gt;已有元素。\u0026lt;/param\u0026gt;  public MaxPQWithMin(Key[] keys) { this.n = keys.Length; this.pq = new Key[keys.Length + 1]; this.min = null; if (this.n == 0) return; // 复制元素的同时更新最小值。  this.min = keys[0]; for (int i = 0; i \u0026lt; keys.Length; i++) { this.pq[i + 1] = keys[i]; if (this.pq[i + 1].CompareTo(this.min) \u0026lt; 0) this.min = this.pq[i + 1]; } for (int k = this.n / 2; k \u0026gt;= 1; k--) Sink(k); Debug.Assert(IsMaxHeap()); } /// \u0026lt;summary\u0026gt;  /// 删除并返回最大元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key DelMax() { if (IsEmpty()) throw new ArgumentOutOfRangeException(\u0026#34;Priority Queue Underflow\u0026#34;); Key max = this.pq[1]; Exch(1, this.n--); this.pq[this.n + 1] = this.pq[1]; Sink(1); this.pq[this.n + 1] = null; if ((this.n \u0026gt; 0) \u0026amp;\u0026amp; (this.n == this.pq.Length / 4)) Resize(this.pq.Length / 2); // 如果堆变为空。  if (IsEmpty()) this.min = null; Debug.Assert(IsMaxHeap()); return max; } /// \u0026lt;summary\u0026gt;  /// 向堆中插入一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;需要插入的元素。\u0026lt;/param\u0026gt;  public void Insert(Key v) { if (this.n == this.pq.Length - 1) Resize(2 * this.pq.Length); // 更新最小值。  if (this.min == null) this.min = v; else if (v.CompareTo(this.min) \u0026lt; 0) this.min = v; this.pq[++this.n] = v; Swim(this.n); Debug.Assert(IsMaxHeap()); } /// \u0026lt;summary\u0026gt;  /// 检查堆是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() =\u0026gt; this.n == 0; /// \u0026lt;summary\u0026gt;  /// 获得堆中最大元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key Max() =\u0026gt; this.pq[1]; /// \u0026lt;summary\u0026gt;  /// 获得堆中的最小元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key Min() =\u0026gt; this.min; /// \u0026lt;summary\u0026gt;  /// 获得堆中元素的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() =\u0026gt; this.n; /// \u0026lt;summary\u0026gt;  /// 获取堆的迭代器，元素以降序排列。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public IEnumerator\u0026lt;Key\u0026gt; GetEnumerator() { MaxPQWithMin\u0026lt;Key\u0026gt; copy = new MaxPQWithMin\u0026lt;Key\u0026gt;(this.n); for (int i = 1; i \u0026lt;= this.n; i++) copy.Insert(this.pq[i]); while (!copy.IsEmpty()) yield return copy.DelMax(); // 下次迭代的时候从这里继续执行。  } /// \u0026lt;summary\u0026gt;  /// 获取堆的迭代器，元素以降序排列。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } /// \u0026lt;summary\u0026gt;  /// 使元素上浮。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要上浮的元素。\u0026lt;/param\u0026gt;  private void Swim(int k) { while (k \u0026gt; 1 \u0026amp;\u0026amp; Less(k / 2, k)) { Exch(k, k / 2); k /= 2; } } /// \u0026lt;summary\u0026gt;  /// 使元素下沉。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要下沉的元素。\u0026lt;/param\u0026gt;  private void Sink(int k) { while (k * 2 \u0026lt;= this.n) { int j = 2 * k; if (Less(j, j + 1)) j++; if (!Less(k, j)) break; Exch(k, j); k = j; } } /// \u0026lt;summary\u0026gt;  /// 重新调整堆的大小。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;调整后的堆大小。\u0026lt;/param\u0026gt;  private void Resize(int capacity) { Key[] temp = new Key[capacity]; for (int i = 1; i \u0026lt;= this.n; i++) { temp[i] = this.pq[i]; } this.pq = temp; } /// \u0026lt;summary\u0026gt;  /// 判断堆中某个元素是否小于另一元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;判断是否较小的元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;判断是否较大的元素。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private bool Less(int i, int j) =\u0026gt; this.pq[i].CompareTo(this.pq[j]) \u0026lt; 0; /// \u0026lt;summary\u0026gt;  /// 交换堆中的两个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要交换的第一个元素下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;要交换的第二个元素下标。\u0026lt;/param\u0026gt;  private void Exch(int i, int j) { Key swap = this.pq[i]; this.pq[i] = this.pq[j]; this.pq[j] = swap; } /// \u0026lt;summary\u0026gt;  /// 检查当前二叉树是不是一个最大堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private bool IsMaxHeap() =\u0026gt; IsMaxHeap(1); /// \u0026lt;summary\u0026gt;  /// 确定以 k 为根节点的二叉树是不是一个最大堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要检查的二叉树根节点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private bool IsMaxHeap(int k) { if (k \u0026gt; this.n) return true; int left = 2 * k; int right = 2 * k + 1; if (left \u0026lt;= this.n \u0026amp;\u0026amp; Less(k, left)) return false; if (right \u0026lt;= this.n \u0026amp;\u0026amp; Less(k, right)) return false; return IsMaxHeap(left) \u0026amp;\u0026amp; IsMaxHeap(right); } } } 另请参阅 #  PriorityQueue 库\n"},{"id":304,"href":"/2-4-28/","title":"2.4.28","section":"帮助","content":"2.4.28 #  解答 #  开始时让 N=10^5，在 M=10^4 不变的情况下令 N 不断翻倍，求出算法增长的数量级。\n再根据求出的增长的数量级估计 N=10^8 时所需要的时间。\n为了方便比较，需要编写一个欧几里得距离类，\n构造时输入一个点的坐标，内部自动计算并保存这个点到原点的欧几里得距离。\n欧几里得距离的计算公式如下：\n$$\nd(x,y)=\\sqrt{\\sum_{i=1}^{n}(x_i-y_i)^2}\n$$\n其中，x 和 y 分别代表两个点。\n在本题中，y 始终是原点，且使用三维坐标系，因此公式可以简化为：\n$$\nd=\\sqrt {x^2+y^2+z^2}\n$$\n同时这个类需要实现 IComparable 接口以作为最小堆的元素。\n做测试时，先随机生成 N 个点，再建立一个最小堆。\n随后开始计时，把开始的 m 个点插入。\n剩余的 n-m 个点则是先删除最小值再插入，这样可以保证最小堆的大小不变。\n最后再把堆中的所有元素输出，停止计时。\n用不断倍增的的 N 值做上述测试，获得每次的耗时，进而求得算法增长的数量级。\n求得的结果如下：\n可以推出当 N=10^8 时耗时为 $ 398 \\ ms × 1000 = 398 \\ s $\n代码 #  欧几里得距离类，EuclideanDistance3D\nusing System; namespace _2._4._28 { /// \u0026lt;summary\u0026gt;  /// 点到原点的欧几里得距离。  /// \u0026lt;/summary\u0026gt;  class EuclideanDistance3D : IComparable\u0026lt;EuclideanDistance3D\u0026gt; { private readonly int x, y, z; private double distance; /// \u0026lt;summary\u0026gt;  /// 计算点到原点的欧几里得距离。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;x 轴坐标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;y\u0026#34;\u0026gt;y 轴坐标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;z\u0026#34;\u0026gt;z 轴坐标。\u0026lt;/param\u0026gt;  public EuclideanDistance3D(int x, int y, int z) { this.x = x; this.y = y; this.z = z; this.distance = Math.Sqrt(x * x + y * y + z * z); } /// \u0026lt;summary\u0026gt;  /// 比较两个欧几里得距离的大小。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;另一个欧几里得距离。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int CompareTo(EuclideanDistance3D other) { return this.distance.CompareTo(other.distance); } /// \u0026lt;summary\u0026gt;  /// 以 \u0026#34;(x, y, z)\u0026#34; 形式输出点的坐标。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public override string ToString() { return \u0026#34;(\u0026#34; + this.x + \u0026#34;, \u0026#34; + this.y + \u0026#34;, \u0026#34; + this.z + \u0026#34;)\u0026#34;; } } } 测试类\nusing System; using System.Diagnostics; using PriorityQueue; namespace _2._4._28 { /* * 2.4.28 * * 选择过滤。 * 编写一个 TopM 的用例， * 从标准输入读入坐标 (x, y, z)，从命令行得到值 M， * 然后打印出距离原点的欧几里得距离最小的 M 个点。 * 在 N=10^8 且 M=10^4 时，预计程序的运行时间。 * */ class Program { static void Main(string[] args) { // m 不变的情况下算法是 O(n) 的  // 因此预计时间是 n=10^5 的运行时间乘以 10^3 倍。  int n = 100000, m = 10000; long prev = 0; for (int i = 0; i \u0026lt; 6; i++) { Console.Write(\u0026#34;n= \u0026#34; + n + \u0026#34; m= \u0026#34; + m); long now = test(m, n); // 获取当前 m,n 值的算法运行时间  Console.Write(\u0026#34;\\t time=\u0026#34; + now); if (prev == 0) { prev = now; Console.WriteLine(); } else { Console.WriteLine(\u0026#34;\\tratio=\u0026#34; + (double)now / prev); prev = now; } n *= 2; } } /// \u0026lt;summary\u0026gt;  /// 进行一次测试。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;m\u0026#34;\u0026gt;测试使用的 m 值。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;测试使用的 n 值。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  static long test(int m, int n) { var pq = new MinPQ\u0026lt;EuclideanDistance3D\u0026gt;(m); int[] x = new int[n]; int[] y = new int[n]; int[] z = new int[n]; Random random = new Random(); for (int i = 0; i \u0026lt; n; i++) { x[i] = random.Next(); y[i] = random.Next(); z[i] = random.Next(); } Stopwatch sw = new Stopwatch(); sw.Start();// 开始计时  for (int i = 0; i \u0026lt; m; i++) { // 先插入 m 个记录  pq.Insert(new EuclideanDistance3D(x[i], y[i], z[i])); } for (int i = m; i \u0026lt; n; i++) { // 插入剩余 n-m 个记录  pq.DelMin(); pq.Insert(new EuclideanDistance3D(x[i], y[i], z[i])); } while (pq.IsEmpty()) pq.DelMin(); sw.Stop();// 停止计时  return sw.ElapsedMilliseconds; } } } 另请参阅 #  欧几里得距离-维基百科\nPriorityQueue 库\n"},{"id":305,"href":"/2-4-29/","title":"2.4.29","section":"帮助","content":"2.4.29 #  解答 #  算法思想比较简单，但在实现上会有一些复杂。\n用一个最大堆和一个最小堆，每个堆中都保存了全部数组元素，且相同的元素之间有指针相连。\n插入元素时需要构建两个完全相同的元素分别插入到两个堆中。\n找到最小元素和找到最大元素只需要分别返回最大堆和最小堆的堆顶元素即可。\n以删除最小元素为例，先对最小堆进行 DelMin() 操作，再通过指针找到对应最大堆的元素并删除。\n下面介绍删除堆中任意元素的算法。\n首先将待删除元素与堆中最后一个元素交换，让堆的大小减一。\n随后对交换后的元素先进行 Swim 再进行 Sink，移动到正确的位置上。\n下图是一个例子，当删除最大元素 14 时，最小堆中删除元素 14 需要先 Swim。\n如果堆的层数更多一些，就需要先 Swim 再 Sink。\n现在来考虑一下实现，我们构建一个结点类，里面存放有当前结点的值、对应数组下标和另一个结点的指针。\n/// \u0026lt;summary\u0026gt; /// 最大-最小堆中的数据结点。 /// \u0026lt;/summary\u0026gt; private sealed class MinMaxNode : IComparable\u0026lt;MinMaxNode\u0026gt; { /// \u0026lt;summary\u0026gt;  /// 结点的值。  /// \u0026lt;/summary\u0026gt;  public Key Key { get; set; } /// \u0026lt;summary\u0026gt;  /// 结点在当前数组中的下标。  /// \u0026lt;/summary\u0026gt;  public readonly int Index; /// \u0026lt;summary\u0026gt;  /// 指向孪生结点的引用。  /// \u0026lt;/summary\u0026gt;  public MinMaxNode Pair { get; set; } /// \u0026lt;summary\u0026gt;  /// 这个类不能在外部实例化。  /// \u0026lt;/summary\u0026gt;  private MinMaxNode(Key key, int index) { this.Key = key; this.Index = index; } /// \u0026lt;summary\u0026gt;  /// 工厂方法，建立两个孪生的结点。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;结点中的元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;minNode\u0026#34;\u0026gt;准备放到最小堆中的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;maxNodeB\u0026#34;\u0026gt;准备放到最大堆中的结点。\u0026lt;/param\u0026gt;  public static void GetNodes(Key key, int index, out MinMaxNode minNode, out MinMaxNode maxNode) { minNode = new MinMaxNode(key, index); maxNode = new MinMaxNode(key, index); minNode.Pair = maxNode; maxNode.Pair = minNode; } /// \u0026lt;summary\u0026gt;  /// 比较两个元素的大小。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;需要与之比较的另一个元素。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int CompareTo(MinMaxNode other) { return this.Key.CompareTo(other.Key); } } 然后重写堆的 Exch 方法，交换结点时只交换指针和元素值，不交换数组下标。\n/// \u0026lt;summary\u0026gt; /// 重写的 Exch 方法，只交换元素和指针。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要交换的下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;要交换的下标。\u0026lt;/param\u0026gt; protected override void Exch(int i, int j) { this.pq[i].Pair.Pair = this.pq[j]; this.pq[j].Pair.Pair = this.pq[i]; MinMaxNode swapNode = this.pq[i].Pair; Key swapKey = this.pq[i].Key; this.pq[i].Key = this.pq[j].Key; this.pq[i].Pair = this.pq[j].Pair; this.pq[j].Key = swapKey; this.pq[j].Pair = swapNode; } 在最大堆和最小堆的实现中编写 Remove 方法，用于移除指定下标的元素。\n/// \u0026lt;summary\u0026gt; /// 删除一个结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;结点下标。\u0026lt;/param\u0026gt; internal void Remove(int k) { if (k == this.n) { this.pq[this.n--] = default(Key); return; } else if (this.n \u0026lt;= 2) { Exch(1, k); this.pq[this.n--] = default(Key); return; } Exch(k, this.n--); this.pq[this.n + 1] = default(Key); Swim(k); Sink(k); } 代码 #  最大-最小堆\nusing System; namespace PriorityQueue { /// \u0026lt;summary\u0026gt;  /// 最大-最小堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Key\u0026#34;\u0026gt;最大最小堆中保存的元素。\u0026lt;/typeparam\u0026gt;  public class MinMaxPQ\u0026lt;Key\u0026gt; : IMaxPQ\u0026lt;Key\u0026gt;, IMinPQ\u0026lt;Key\u0026gt; where Key : IComparable\u0026lt;Key\u0026gt; { /// \u0026lt;summary\u0026gt;  /// 最大-最小堆中的数据结点。  /// \u0026lt;/summary\u0026gt;  private sealed class MinMaxNode : IComparable\u0026lt;MinMaxNode\u0026gt; { /// \u0026lt;summary\u0026gt;  /// 结点的值。  /// \u0026lt;/summary\u0026gt;  public Key Key { get; set; } /// \u0026lt;summary\u0026gt;  /// 结点在当前数组中的下标。  /// \u0026lt;/summary\u0026gt;  public readonly int Index; /// \u0026lt;summary\u0026gt;  /// 指向孪生结点的引用。  /// \u0026lt;/summary\u0026gt;  public MinMaxNode Pair { get; set; } /// \u0026lt;summary\u0026gt;  /// 这个类不能在外部实例化。  /// \u0026lt;/summary\u0026gt;  private MinMaxNode(Key key, int index) { this.Key = key; this.Index = index; } /// \u0026lt;summary\u0026gt;  /// 工厂方法，建立两个孪生的结点。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;结点中的元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;minNode\u0026#34;\u0026gt;准备放到最小堆中的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;maxNodeB\u0026#34;\u0026gt;准备放到最大堆中的结点。\u0026lt;/param\u0026gt;  public static void GetNodes(Key key, int index, out MinMaxNode minNode, out MinMaxNode maxNode) { minNode = new MinMaxNode(key, index); maxNode = new MinMaxNode(key, index); minNode.Pair = maxNode; maxNode.Pair = minNode; } /// \u0026lt;summary\u0026gt;  /// 比较两个元素的大小。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;需要与之比较的另一个元素。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int CompareTo(MinMaxNode other) { return this.Key.CompareTo(other.Key); } } /// \u0026lt;summary\u0026gt;  /// 偏特化的最大堆。  /// \u0026lt;/summary\u0026gt;  private sealed class MaxPQ : MaxPQ\u0026lt;MinMaxNode\u0026gt; { public MaxPQ() : base() { } public MaxPQ(int capacity) : base(capacity) { } public MaxPQ(MinMaxNode[] nodes) : base(nodes) { } /// \u0026lt;summary\u0026gt;  /// 重写的 Exch 方法，只交换元素和指针。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要交换的下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;要交换的下标。\u0026lt;/param\u0026gt;  protected override void Exch(int i, int j) { this.pq[i].Pair.Pair = this.pq[j]; this.pq[j].Pair.Pair = this.pq[i]; MinMaxNode swapNode = this.pq[i].Pair; Key swapKey = this.pq[i].Key; this.pq[i].Key = this.pq[j].Key; this.pq[i].Pair = this.pq[j].Pair; this.pq[j].Key = swapKey; this.pq[j].Pair = swapNode; } } /// \u0026lt;summary\u0026gt;  /// 偏特化的最大堆。  /// \u0026lt;/summary\u0026gt;  private sealed class MinPQ : MinPQ\u0026lt;MinMaxNode\u0026gt; { public MinPQ() : base() { } public MinPQ(int capacity) : base(capacity) { } public MinPQ(MinMaxNode[] nodes) : base(nodes) { } /// \u0026lt;summary\u0026gt;  /// 重写的 Exch 方法，只交换元素和指针。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要交换的下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;要交换的下标。\u0026lt;/param\u0026gt;  protected override void Exch(int i, int j) { this.pq[i].Pair.Pair = this.pq[j]; this.pq[j].Pair.Pair = this.pq[i]; MinMaxNode swapNode = this.pq[i].Pair; Key swapKey = this.pq[i].Key; this.pq[i].Key = this.pq[j].Key; this.pq[i].Pair = this.pq[j].Pair; this.pq[j].Key = swapKey; this.pq[j].Pair = swapNode; } } /// \u0026lt;summary\u0026gt;  /// 最小堆。  /// \u0026lt;/summary\u0026gt;  private MinPQ minPQ; /// \u0026lt;summary\u0026gt;  /// 最大堆。  /// \u0026lt;/summary\u0026gt;  private MaxPQ maxPQ; /// \u0026lt;summary\u0026gt;  /// 堆的大小。  /// \u0026lt;/summary\u0026gt;  private int n; /// \u0026lt;summary\u0026gt;  /// 构造一个最大-最小堆。  /// \u0026lt;/summary\u0026gt;  public MinMaxPQ() : this(1) { } /// \u0026lt;summary\u0026gt;  /// 构造一个指定容量的最大-最小堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;堆的大小。\u0026lt;/param\u0026gt;  public MinMaxPQ(int capacity) { this.minPQ = new MinPQ(capacity); this.maxPQ = new MaxPQ(capacity); this.n = 0; } /// \u0026lt;summary\u0026gt;  /// 根据已有元素建立一个最大-最小堆。（O(n)）  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;keys\u0026#34;\u0026gt;需要建堆的元素。\u0026lt;/param\u0026gt;  public MinMaxPQ(Key[] keys) { this.n = keys.Length; MinMaxNode[] minNodes = new MinMaxNode[keys.Length]; MinMaxNode[] maxNodes = new MinMaxNode[keys.Length]; for (int i = 0; i \u0026lt; this.n; i++) { MinMaxNode.GetNodes(keys[i], i + 1, out minNodes[i], out maxNodes[i]); } this.minPQ = new MinPQ(minNodes); this.maxPQ = new MaxPQ(maxNodes); } /// \u0026lt;summary\u0026gt;  /// 删除并返回最大值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key DelMax() { // ⬇ 不可以交换操作顺序 ⬇  this.minPQ.Remove(this.maxPQ.Max().Pair.Index); Key key = this.maxPQ.Max().Key; this.maxPQ.DelMax(); // ⬆ 不可以交换操作顺序 ⬆  this.n--; return key; } /// \u0026lt;summary\u0026gt;  /// 删除并返回最小值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key DelMin() { // ⬇ 不可以交换操作顺序 ⬇  this.maxPQ.Remove(this.minPQ.Min().Pair.Index); Key key = this.minPQ.Min().Key; this.minPQ.DelMin(); // ⬆ 不可以交换操作顺序 ⬆  this.n--; return key; } /// \u0026lt;summary\u0026gt;  /// 插入一个新的值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;待插入的新值。\u0026lt;/param\u0026gt;  public void Insert(Key v) { this.n++; MinMaxNode.GetNodes(v, this.n, out MinMaxNode minNode, out MinMaxNode maxNode); this.maxPQ.Insert(maxNode); this.minPQ.Insert(minNode); } /// \u0026lt;summary\u0026gt;  /// 判断堆是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() =\u0026gt; this.n == 0; /// \u0026lt;summary\u0026gt;  /// 获得堆中的最大值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key Max() =\u0026gt; this.maxPQ.Max().Key; /// \u0026lt;summary\u0026gt;  /// 获得堆中的最小值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key Min() =\u0026gt; this.minPQ.Min().Key; /// \u0026lt;summary\u0026gt;  /// 获得堆的大小。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() =\u0026gt; this.n; } } 另请参阅 #  Double Ended Priority Queue-Wikipedia\nPriorityQueue 库\n"},{"id":306,"href":"/2-4-30/","title":"2.4.30","section":"帮助","content":"2.4.30 #  解答 #  单独用一个变量存放中位数，然后前半部分元素放在一个最大堆中，后半部分元素放在一个最小堆中。\n如下图所示，注意 Median 和两个堆并没有直接连接，这里只是方便理解元素顺序。\n只要左右两个堆含有元素之差不超过 1，那么 Median 变量中存放的就是整个数组的中位数。\n如果元素差大于 1，就需要进行调整，\n把 Median 变量中存放的值插入到元素较少的堆，\n再从元素较多的堆中取出元素放入 Median 变量，直到元素差不大于 1。\n插入元素时，根据插入元素的大小插入到某一个堆中去，再做一次调整。\n删除中位数时，去掉中位数，然后从元素较多的一侧堆中取元素补位，再进行一次调整。\n编写代码时要注意堆中只有一个元素的情况需要特殊处理。\n代码 #  面向中位数的堆（MedianPQ.cs）\nusing System; namespace PriorityQueue { /// \u0026lt;summary\u0026gt;  /// 面向中位数的堆。  /// \u0026lt;/summary\u0026gt;  public class MedianPQ\u0026lt;Key\u0026gt; where Key : IComparable\u0026lt;Key\u0026gt; { /// \u0026lt;summary\u0026gt;  /// 最大堆（保存前半段元素）。  /// \u0026lt;/summary\u0026gt;  private MaxPQ\u0026lt;Key\u0026gt; maxPQ; /// \u0026lt;summary\u0026gt;  /// 最小堆（保存后半段元素）。  /// \u0026lt;/summary\u0026gt;  private MinPQ\u0026lt;Key\u0026gt; minPQ; /// \u0026lt;summary\u0026gt;  /// 中位数。  /// \u0026lt;/summary\u0026gt;  private Key median; /// \u0026lt;summary\u0026gt;  /// 堆的大小  /// \u0026lt;/summary\u0026gt;  private int n; /// \u0026lt;summary\u0026gt;  /// 默认构造函数，构造一个面向中位数的堆。  /// \u0026lt;/summary\u0026gt;  public MedianPQ() { this.maxPQ = new MaxPQ\u0026lt;Key\u0026gt;(); this.minPQ = new MinPQ\u0026lt;Key\u0026gt;(); this.median = default(Key); this.n = 0; } /// \u0026lt;summary\u0026gt;  /// 构造一个指定容量的面向中位数的堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;初始容量。\u0026lt;/param\u0026gt;  public MedianPQ(int capacity) { this.maxPQ = new MaxPQ\u0026lt;Key\u0026gt;((capacity - 1) / 2); this.minPQ = new MinPQ\u0026lt;Key\u0026gt;((capacity - 1) / 2); this.n = 0; this.median = default(Key); } /// \u0026lt;summary\u0026gt;  /// 根据指定数组初始化面向中位数的堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;keys\u0026#34;\u0026gt;初始数组。\u0026lt;/param\u0026gt;  public MedianPQ(Key[] keys) { this.minPQ = new MinPQ\u0026lt;Key\u0026gt;(); this.maxPQ = new MaxPQ\u0026lt;Key\u0026gt;(); if (keys.Length == 0) { this.n = 0; this.median = default(Key); return; } this.n = keys.Length; this.median = keys[0]; for (int i = 1; i \u0026lt; keys.Length; i++) { if (this.median.CompareTo(keys[i]) \u0026lt; 0) this.minPQ.Insert(keys[i]); else this.maxPQ.Insert(keys[i]); } UpdateMedian(); } /// \u0026lt;summary\u0026gt;  /// 向面向中位数的堆中插入一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;需要插入的元素。\u0026lt;/param\u0026gt;  public void Insert(Key key) { if (this.n == 0) { this.n++; this.median = key; return; } if (key.CompareTo(this.median) \u0026lt; 0) this.maxPQ.Insert(key); else this.minPQ.Insert(key); this.n++; UpdateMedian(); } /// \u0026lt;summary\u0026gt;  /// 删除并返回中位数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key DelMedian() { if (IsEmpty()) throw new ArgumentOutOfRangeException(\u0026#34;MedianPQ underflow!\u0026#34;); Key median = this.median; if (this.n == 1) { this.n--; this.median = default(Key); return median; } // 从较大的一侧堆中取元素作为新的中位数。  if (this.minPQ.Size() \u0026gt; this.maxPQ.Size()) this.median = this.minPQ.DelMin(); else this.median = this.maxPQ.DelMax(); this.n--; return median; } /// \u0026lt;summary\u0026gt;  /// 获得中位数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key Median() =\u0026gt; this.median; /// \u0026lt;summary\u0026gt;  /// 判断堆是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() =\u0026gt; this.n == 0; /// \u0026lt;summary\u0026gt;  /// 更新中位数的值。  /// \u0026lt;/summary\u0026gt;  private void UpdateMedian() { // 根据两个堆的大小调整中位数  while (this.maxPQ.Size() - this.minPQ.Size() \u0026gt; 1) { this.minPQ.Insert(this.median); this.median = this.maxPQ.DelMax(); } while (this.minPQ.Size() - this.maxPQ.Size() \u0026gt; 1) { this.maxPQ.Insert(this.median); this.median = this.minPQ.DelMin(); } } } } 另请参阅 #  PriorityQueue 库\n"},{"id":307,"href":"/2-4-31/","title":"2.4.31","section":"帮助","content":"2.4.31 #  解答 #  首先可以观察到堆有这样一个性质，从根结点到某一个叶子结点的路径是有序的，满足二分查找的条件。\n但是，\n从叶子结点到根结点的路径可以通过不断地令 k = k / 2 得到（从下往上只有一条路径）。\n但从根结点到叶子结点的路径却不能简单地通过 k = k * 2 得到（从上往下会有两条分支）。\n因此只通过堆本身是无法满足二分查找对于随机访问的要求的。\n为了达到 ~loglogN 次比较，我们需要对 Swim() 方法做修改，\n即，先通过一个数组来保存路径，再对这个数组进行二分查找，从而获得合适的祖先结点。\n路径的长度是 ~logN（完全二叉树的性质），于是二分查找的比较次数即为 ~loglogN。\n删除操作原本就是 ~2logN 的，不需要修改。\n注意这样的方法仅仅只是减少了比较次数，\n为了保持堆的有序，即使找到了结点的合适位置也不能直接插入，\n仍然需要将路径上的结点依次下移，空出位置后再插入结点，复杂度仍然是 ~logN。\n由于增加了保存路径等操作（建立了大量的小数组），实际算法的运行时间是增加的。\n也可以用空间换时间，由于在堆中下标为 k 的结点到根结点的路径是唯一确定的。\n因此可以提前计算好路径，用一个数组保存起来（数组的数组），在 Swim 中取出对应路径进行二分查找。\n当然这样是很不划算的，除非元素比较的开销非常大。\n代码 #  修改后的 Swim() 方法，注意输入的路径是从下往上的。\n/// \u0026lt;summary\u0026gt; /// 使元素上浮。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要上浮的元素。\u0026lt;/param\u0026gt; private void Swim(int k) { if (k == 1) return; // 获取路径  int heapHeight = (int)(Math.Log(this.n) / Math.Log(2)); List\u0026lt;int\u0026gt; path = new List\u0026lt;int\u0026gt;(); int temp = k; while (temp \u0026gt;= 1) { path.Add(temp); temp /= 2; } // lo=插入结点的父结点 hi=根结点  int lo = 1, hi = path.Count - 1; while (lo \u0026lt;= hi) { int mid = lo + (hi - lo) / 2; if (Greater(k, path[mid])) hi = mid - 1; // 当前值比较大，应该向下走  else lo = mid + 1; // 值较小，向根结点方向走  } for (int i = 1; i \u0026lt; lo; i++) { Exch(path[i - 1], path[i]); } } 另请参阅 #  PriorityQueue 库\n"},{"id":308,"href":"/2-4-32/","title":"2.4.32","section":"帮助","content":"2.4.32 #  解答 #  官网解答见：https://algs4.cs.princeton.edu/24pq/\n如果这样的话，堆排序的只需要 ~nloglogn 次比较即可。\n根据 2.3 中的证明，基于比较的排序的下界是 ~nlogn。\n因此不存在这样的最小堆。\n注意上题的方法不能用于下沉操作，因为我们不能预知下沉的路径。\n"},{"id":309,"href":"/2-4-33/","title":"2.4.33","section":"帮助","content":"2.4.33 #  解答 #  官方实现见：https://algs4.cs.princeton.edu/24pq/IndexMaxPQ.java.html\n书中算法 2.6 给出的是一个最大堆的实现，但本题给出的部分解答却是最小堆的。\n同时官网给出的解答是最大堆的，这里选择和官网保持一致，给出最大堆的实现。\n初看起来可能会比较难理解，但其实就是以指针为元素的堆。\n堆中存放的只是指向元素的指针（如果元素在数组里那就变成了下标）。\n做比较的时候要先根据指针（下标）找到对应元素，再进行比较。\n再来看题目中给出的要求，keys[] 数组中用于保存元素（比如 keys[0] = ‘A’;），\n而 pq[] 中保存的是元素在 key[] 数组中的下标（比如 pq[1] = 0;)，\n而 qp[] 中保存的是某个下标在 pq[]中 的对应位置。（比如 qp[0] = 1）。\n在这三个数组中，pq[]是一个堆，我们的堆操作都作用在这个数组上。\nkeys[] 数组中的元素不随着 pq[] 中下标的移动而移动，只有当删除或添加元素时才发生变化。\nqp[]与pq[]中的索引一一对应，pq[]交换时也需要交换qp[]中的对应元素。\n代码 #  using System; using System.Collections; using System.Collections.Generic; namespace PriorityQueue { /// \u0026lt;summary\u0026gt;  /// 索引优先队列。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Key\u0026#34;\u0026gt;优先队列中包含的元素。\u0026lt;/typeparam\u0026gt;  public class IndexMaxPQ\u0026lt;Key\u0026gt; : IEnumerable\u0026lt;int\u0026gt; where Key : IComparable\u0026lt;Key\u0026gt; { /// \u0026lt;summary\u0026gt;  /// 优先队列中的元素。  /// \u0026lt;/summary\u0026gt;  private int n; /// \u0026lt;summary\u0026gt;  /// 索引最大堆。  /// \u0026lt;/summary\u0026gt;  private int[] pq; /// \u0026lt;summary\u0026gt;  /// pq 的逆索引，pq[qp[i]]=qp[pq[i]]=i  /// \u0026lt;/summary\u0026gt;  private int[] qp; /// \u0026lt;summary\u0026gt;  /// 实际元素。  /// \u0026lt;/summary\u0026gt;  private Key[] keys; /// \u0026lt;summary\u0026gt;  /// 建立指定大小的面向索引的最大堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  public IndexMaxPQ(int capacity) { if (capacity \u0026lt; 0) throw new ArgumentOutOfRangeException(); this.n = 0; this.keys = new Key[capacity + 1]; this.pq = new int[capacity + 1]; this.qp = new int[capacity + 1]; for (int i = 0; i \u0026lt;= capacity; i++) this.qp[i] = -1; } /// \u0026lt;summary\u0026gt;  /// 将与索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 相关联的元素换成 \u0026lt;paramref name=\u0026#34;k\u0026#34;/\u0026gt;。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要修改关联元素的索引。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;用于替换的新元素。\u0026lt;/param\u0026gt;  public void ChangeKey(int i, Key k) { if (!Contains(i)) throw new ArgumentNullException(\u0026#34;队列中没有该索引\u0026#34;); this.keys[i] = k; Swim(this.qp[i]); Sink(this.qp[i]); } /// \u0026lt;summary\u0026gt;  /// 确认堆包含某个索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt;。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要查询的索引。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool Contains(int i) =\u0026gt; this.qp[i] != -1; /// \u0026lt;summary\u0026gt;  /// 删除索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 对应的键值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要清空的索引。\u0026lt;/param\u0026gt;  public void Delete(int i) { if (!Contains(i)) throw new ArgumentOutOfRangeException(\u0026#34;index is not in the priority queue\u0026#34;); int index = this.qp[i]; Exch(index, this.n--); Swim(index); Sink(index); this.keys[i] = default(Key); this.qp[i] = -1; } /// \u0026lt;summary\u0026gt;  /// 删除并获得最大元素所在的索引。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int DelMax() { if (this.n == 0) throw new ArgumentOutOfRangeException(\u0026#34;Priority Queue Underflow\u0026#34;); int max = this.pq[1]; Exch(1, this.n--); Sink(1); this.qp[max] = -1; this.keys[max] = default(Key); this.pq[this.n + 1] = -1; return max; } /// \u0026lt;summary\u0026gt;  /// 将索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 对应的键值减少为 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt;。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要修改的索引。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;减少后的键值。\u0026lt;/param\u0026gt;  public void DecreaseKey(int i, Key key) { if (!Contains(i)) throw new ArgumentOutOfRangeException(\u0026#34;index is not in the priority queue\u0026#34;); if (this.keys[i].CompareTo(key) \u0026lt;= 0) throw new ArgumentException(\u0026#34;Calling IncreaseKey() with given argument would not strictly increase the Key\u0026#34;); this.keys[i] = key; Sink(this.qp[i]); } /// \u0026lt;summary\u0026gt;  /// 将索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 对应的键值增加为 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt;。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要修改的索引。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;增加后的键值。\u0026lt;/param\u0026gt;  public void IncreaseKey(int i, Key key) { if (!Contains(i)) throw new ArgumentOutOfRangeException(\u0026#34;index is not in the priority queue\u0026#34;); if (this.keys[i].CompareTo(key) \u0026gt;= 0) throw new ArgumentException(\u0026#34;Calling IncreaseKey() with given argument would not strictly increase the Key\u0026#34;); this.keys[i] = key; Swim(this.qp[i]); } /// \u0026lt;summary\u0026gt;  /// 将元素 \u0026lt;paramref name=\u0026#34;v\u0026#34;/\u0026gt; 与索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 关联。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;待插入元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;需要关联的索引。\u0026lt;/param\u0026gt;  public void Insert(Key v, int i) { if (Contains(i)) throw new ArgumentException(\u0026#34;索引已存在\u0026#34;); this.n++; this.qp[i] = this.n; this.pq[this.n] = i; this.keys[i] = v; Swim(this.n); } /// \u0026lt;summary\u0026gt;  /// 堆是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() =\u0026gt; this.n == 0; /// \u0026lt;summary\u0026gt;  /// 获得与索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 关联的元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;索引。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key KeyOf(int i) { if (!Contains(i)) throw new ArgumentNullException(\u0026#34;队列中没有该索引\u0026#34;); return this.keys[i]; } /// \u0026lt;summary\u0026gt;  /// 返回最大元素对应的索引。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int MaxIndex() { if (this.n == 0) throw new ArgumentOutOfRangeException(\u0026#34;Priority Queue Underflow\u0026#34;); return this.pq[1]; } /// \u0026lt;summary\u0026gt;  /// 获得最大元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key MaxKey() { if (this.n == 0) throw new ArgumentOutOfRangeException(\u0026#34;Priority Queue Underflow\u0026#34;); return this.keys[this.pq[1]]; } /// \u0026lt;summary\u0026gt;  /// 返回堆的元素数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() =\u0026gt; this.n; /// \u0026lt;summary\u0026gt;  /// 比较第一个元素是否小于第二个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;第一个元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;第二个元素。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private bool Less(int i, int j) =\u0026gt; this.keys[this.pq[i]].CompareTo(this.keys[this.pq[j]]) \u0026lt; 0; /// \u0026lt;summary\u0026gt;  /// 交换两个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要交换的元素下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;要交换的元素下标。\u0026lt;/param\u0026gt;  private void Exch(int i, int j) { int swap = this.pq[i]; this.pq[i] = this.pq[j]; this.pq[j] = swap; this.qp[this.pq[i]] = i; this.qp[this.pq[j]] = j; } /// \u0026lt;summary\u0026gt;  /// 使下标为 \u0026lt;paramref name=\u0026#34;k\u0026#34;/\u0026gt; 的元素上浮。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;上浮元素下标。\u0026lt;/param\u0026gt;  private void Swim(int k) { while (k \u0026gt; 1 \u0026amp;\u0026amp; Less(k / 2, k)) { Exch(k / 2, k); k /= 2; } } /// \u0026lt;summary\u0026gt;  /// 使下标为 \u0026lt;paramref name=\u0026#34;k\u0026#34;/\u0026gt; 元素下沉。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要下沉的元素。\u0026lt;/param\u0026gt;  private void Sink(int k) { while (k * 2 \u0026lt;= this.n) { int j = 2 * k; if (j \u0026lt; this.n \u0026amp;\u0026amp; Less(j, j + 1)) j++; if (!Less(k, j)) break; Exch(k, j); k = j; } } /// \u0026lt;summary\u0026gt;  /// 获取迭代器。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public IEnumerator\u0026lt;int\u0026gt; GetEnumerator() { IndexMaxPQ\u0026lt;Key\u0026gt; copy = new IndexMaxPQ\u0026lt;Key\u0026gt;(this.n); for (int i = 0; i \u0026lt; this.n; i++) copy.Insert(this.keys[this.pq[i]], this.pq[i]); while (!copy.IsEmpty()) yield return copy.DelMax(); } /// \u0026lt;summary\u0026gt;  /// 获取迭代器。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  IEnumerator IEnumerable.GetEnumerator() =\u0026gt; GetEnumerator(); } } 另请参阅 #  PriorityQueue 库\n"},{"id":310,"href":"/2-4-34/","title":"2.4.34","section":"帮助","content":"2.4.34 #  解答 #  这里给出最大堆的实现，原因同 2.4.33。\nmaxIndex()：pq[1] 就是最小元素的下标。\nchange()：首先修改 keys 数组中对应的元素，然后对堆中该下标进行重排序。\ndelete()：先从堆中删除元素，再把 keys 和 qp 数组中的对应元素初始化。\n代码 #  /// \u0026lt;summary\u0026gt; /// 返回最大元素对应的索引。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int MaxIndex() { if (this.n == 0) throw new ArgumentOutOfRangeException(\u0026#34;Priority Queue Underflow\u0026#34;); return this.pq[1]; } /// \u0026lt;summary\u0026gt; /// 将与索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 相关联的元素换成 \u0026lt;paramref name=\u0026#34;k\u0026#34;/\u0026gt;。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要修改关联元素的索引。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;用于替换的新元素。\u0026lt;/param\u0026gt; public void ChangeKey(int i, Key k) { if (!Contains(i)) throw new ArgumentNullException(\u0026#34;队列中没有该索引\u0026#34;); this.keys[i] = k; Swim(this.qp[i]); Sink(this.qp[i]); } /// \u0026lt;summary\u0026gt; /// 删除索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 对应的键值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要清空的索引。\u0026lt;/param\u0026gt; public void Delete(int i) { if (!Contains(i)) throw new ArgumentOutOfRangeException(\u0026#34;index is not in the priority queue\u0026#34;); int index = this.qp[i]; Exch(index, this.n--); Swim(index); Sink(index); this.keys[i] = default(Key); this.qp[i] = -1; } 另请参阅 #  PriorityQueue 库\n"},{"id":311,"href":"/2-4-35/","title":"2.4.35","section":"帮助","content":"2.4.35 #  解答 #  本题有两个翻译错误。\nrandom() ——返回索引 i 的概率是 p[i]/T，而非返回概率和索引。（return an index i with probability p[i]/T）\n最后一句指的是像堆那样使用数组而非显式指针实现二叉树。（Avoid explicit pointers, as we do for heaps.）\n提示已经给出了实现方案，我们用一个例子来简单说明一下。\n现在给出一个分布 p，总和 T=1，如下图所示：\n为了实现这样的随机分布，我们在 0~T 之间随机一个小数，然后根据结果返回不同的值。\n现在我们将这个思想应用到完全二叉树上。\n每次随机的过程其实构成了一棵选择树，我们把数组 p 当作一棵树，如下图：\n为方便起见，我们重新排列一下之前的随机表：\n每个值的概率并没有改变，只是每个值对应的区段换了一下。\n经过这样的变换后，你会发现，如果从根结点的角度看：\n如果随机的值小于 0.1，对应的编号就是 1。\n如果随机的值大于 0.5，那么对应编号只能是 3 或 6，即根结点的右子树。\n其他情况对应编号在左子树上。\n扩展到一般情况，就变成了：\n如果随机数小于当前结点，直接返回当前结点的编号。\n如果随机数大于左子树权值总和+当前结点的权值，减去它们，移动到右子树。\n其他情况减去当前结点的权值并移动到左子树。\n思想理解之后，代码实现就比较容易了，做了 100000 次实验的结果如下：\n代码 #  using System; namespace _2._4._35 { /// \u0026lt;summary\u0026gt;  /// 离散分布的取样。  /// \u0026lt;/summary\u0026gt;  class Sample { public double[] P; public double[] SumP; private double T = 0; private Random random = new Random(); /// \u0026lt;summary\u0026gt;  /// 构造一个离散取样类。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;取样数据。\u0026lt;/param\u0026gt;  public Sample(double[] data) { // 复制权重  this.P = new double[data.Length + 1]; for (int i = 1; i \u0026lt;= data.Length; i++) { this.P[i] = data[i - 1]; this.T += data[i - 1]; } // 记录子树权重之和  this.SumP = new double[data.Length + 1]; for (int i = data.Length; i / 2 \u0026gt; 0; i--) { this.SumP[i / 2] += this.SumP[i] + this.P[i]; } } /// \u0026lt;summary\u0026gt;  /// 根据构造时给定的取样概率返回索引。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Random() { double parcentage = this.random.NextDouble() * this.T; int index = 1; while (index * 2 \u0026lt;= this.P.Length) { // 找到结点  if (parcentage \u0026lt;= this.P[index]) break; // 减去当前结点，向子结点搜寻  parcentage -= this.P[index]; index *= 2; // 在左子树范围内  if (parcentage \u0026lt;= this.SumP[index] + this.P[index]) continue; // 在右子树范围内，减去左子树  parcentage -= this.SumP[index] + this.P[index]; index++; } return index - 1; } /// \u0026lt;summary\u0026gt;  /// 修改索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 的权重为 \u0026lt;paramref name=\u0026#34;v\u0026#34;/\u0026gt;。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;需要修改的索引。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;新的权重。\u0026lt;/param\u0026gt;  public void Change(int i, double v) { i += 1; this.T = this.T - this.P[i] + v; this.P[i] = v; // 重新计算总和  while (i \u0026gt; 1) { i /= 2; this.SumP[i] = this.P[i * 2] + this.SumP[i * 2]; if (i * 2 + 1 \u0026lt; this.P.Length) this.SumP[i] += this.P[i * 2 + 1] + this.SumP[i * 2 + 1]; } } } } 另请参阅 #  PriorityQueue 库\n"},{"id":312,"href":"/2-4-36/","title":"2.4.36","section":"帮助","content":"2.4.36 #  解答 #  测试结果如下：\n可以看出增长数量级约为 O(nlogn)。\n代码 #  using System; using System.Diagnostics; using PriorityQueue; namespace _2._4._36 { class Program { static Random random = new Random(); static void Main(string[] args) { int doubleTime = 5; int repeatTime = 5; int n = 100000; for (int i = 0; i \u0026lt; doubleTime; i++) { long totalTime = 0; Console.WriteLine(\u0026#34;n=\u0026#34; + n); for (int j = 0; j \u0026lt; repeatTime; j++) { MaxPQ\u0026lt;int\u0026gt; pq = new MaxPQ\u0026lt;int\u0026gt;(n); long time = Test(pq, n); Console.Write(time + \u0026#34;\\t\u0026#34;); totalTime += time; } Console.WriteLine(\u0026#34;平均用时：\u0026#34; + totalTime / repeatTime + \u0026#34;毫秒\u0026#34;); n *= 2; } } static long Test(MaxPQ\u0026lt;int\u0026gt; pq, int n) { // 生成数据  int[] initData = new int[n]; int[] appendData = new int[n / 2]; for (int i = 0; i \u0026lt; n; i++) initData[i] = random.Next(); for (int i = 0; i \u0026lt; n / 2; i++) appendData[i] = random.Next(); // 开始测试  Stopwatch stopwatch = new Stopwatch(); stopwatch.Start(); // 插入 n 个元素  for (int i = 0; i \u0026lt; n; i++) pq.Insert(initData[i]); // 删去一半  for (int i = 0; i \u0026lt; n / 2; i++) pq.DelMax(); // 插入一半  for (int i = 0; i \u0026lt; n / 2; i++) pq.Insert(appendData[i]); // 删除全部  for (int i = 0; i \u0026lt; n; i++) pq.DelMax(); stopwatch.Stop(); return stopwatch.ElapsedMilliseconds; } } } 另请参阅 #  PriorityQueue 库\n"},{"id":313,"href":"/2-4-37/","title":"2.4.37","section":"帮助","content":"2.4.37 #  解答 #  建立一个全局变量 isRunning ，每次 DelMax() 之前都先确认这个值是否为 true，\n设立一个 Timer 在 1 秒钟之后自动将 isRunning 置为 false。\n测试结果如下：\n随着 n 增大，一秒钟之内能执行的 DelMax() 次数会下降。\n代码 #  using System; using System.Timers; using PriorityQueue; namespace _2._4._37 { class Program { static bool isRunning = true; static Random random = new Random(); static void Main(string[] args) { int doubleTime = 6; int repeatTime = 6; int n = 1000000; for (int i = 0; i \u0026lt; doubleTime; i++) { int totalDelCount = 0; Console.WriteLine(\u0026#34;n=\u0026#34; + n); for (int j = 0; j \u0026lt; repeatTime; j++) { MaxPQ\u0026lt;int\u0026gt; pq = new MaxPQ\u0026lt;int\u0026gt;(n); int delCount = Test(n, pq); totalDelCount += delCount; Console.Write(delCount + \u0026#34;\\t\u0026#34;); } Console.WriteLine(\u0026#34;平均最大删除次数：\u0026#34; + totalDelCount / repeatTime); n *= 2; } } static int Test(int n, MaxPQ\u0026lt;int\u0026gt; pq) { Timer timer = new Timer(1000); timer.Elapsed += new ElapsedEventHandler(StopRunning); for (int i = 0; i \u0026lt; n; i++) { pq.Insert(random.Next()); } int delCount = 0; StartRunning(); timer.Start(); while (isRunning \u0026amp;\u0026amp; !pq.IsEmpty()) { pq.DelMax(); delCount++; } timer.Stop(); return delCount; } static void StartRunning() =\u0026gt; isRunning = true; static void StopRunning(object source, ElapsedEventArgs e) =\u0026gt; isRunning = false; } } 另请参阅 #  PriorityQueue 库\n"},{"id":314,"href":"/2-4-38/","title":"2.4.38","section":"帮助","content":"2.4.38 #  解答 #  直接构造相应的数组测试即可。\n测试结果如下：\n最大堆来说顺序时会比较慢，因为每次插入都要一路上升到顶部。\n逆序的时候则是删除比较慢，最后一个元素是最小的元素，交换后需要一路下沉到底部。\n由于元素相同的时候我们选择不交换（less(i, j) 返回 false），较多的重复元素并不会影响性能。\n代码 #  using System; using System.Linq; using System.Diagnostics; using PriorityQueue; namespace _2._4._38 { /* * 2.4.38 * * 练习测试。 * 编写一个练习用例， * 用算法 2.6 中实现的优先队列的接口方法处理实际应用中可能出现的高难度或是极端情况。 * 例如，元素已经有序、元素全部逆序、元素全部相同或是所有元素只有两个值。 * */ class Program { static Random random = new Random(); static void Main(string[] args) { int n = 200000; int repeatTimes = 5; int doubleTimes = 4; for (int i = 0; i \u0026lt; doubleTimes; i++) { Console.WriteLine(\u0026#34;n=\u0026#34; + n); // 升序数组  long totalTime = 0; Console.Write(\u0026#34;Ascending:\\t\u0026#34;); for (int j = 0; j \u0026lt; repeatTimes; j++) { MaxPQ\u0026lt;int\u0026gt; pq = new MaxPQ\u0026lt;int\u0026gt;(n); int[] data = GetAscending(n); long time = Test(pq, data); Console.Write(time + \u0026#34;\\t\u0026#34;); totalTime += time; } Console.WriteLine(\u0026#34;Average:\u0026#34; + totalTime / repeatTimes); // 降序数组  totalTime = 0; Console.Write(\u0026#34;Descending:\\t\u0026#34;); for (int j = 0; j \u0026lt; repeatTimes; j++) { MaxPQ\u0026lt;int\u0026gt; pq = new MaxPQ\u0026lt;int\u0026gt;(n); int[] data = GetDescending(n); long time = Test(pq, data); Console.Write(time + \u0026#34;\\t\u0026#34;); totalTime += time; } Console.WriteLine(\u0026#34;Average:\u0026#34; + totalTime / repeatTimes); // 全部元素相同  totalTime = 0; Console.Write(\u0026#34;All Same:\\t\u0026#34;); for (int j = 0; j \u0026lt; repeatTimes; j++) { MaxPQ\u0026lt;int\u0026gt; pq = new MaxPQ\u0026lt;int\u0026gt;(n); int[] data = GetSame(n, 17763); long time = Test(pq, data); Console.Write(time + \u0026#34;\\t\u0026#34;); totalTime += time; } Console.WriteLine(\u0026#34;Average:\u0026#34; + totalTime / repeatTimes); // 只有两个值  totalTime = 0; Console.Write(\u0026#34;Binary Dist.:\\t\u0026#34;); for (int j = 0; j \u0026lt; repeatTimes; j++) { MaxPQ\u0026lt;int\u0026gt; pq = new MaxPQ\u0026lt;int\u0026gt;(n); int[] data = GetBinary(n, 15254, 17763); long time = Test(pq, data); Console.Write(time + \u0026#34;\\t\u0026#34;); totalTime += time; } Console.WriteLine(\u0026#34;Average:\u0026#34; + totalTime / repeatTimes); n *= 2; } } static long Test(MaxPQ\u0026lt;int\u0026gt; pq, int[] data) { Stopwatch sw = new Stopwatch(); sw.Start(); for (int i = 0; i \u0026lt; data.Length; i++) { pq.Insert(data[i]); } for (int i = 0; i \u0026lt; data.Length; i++) { pq.DelMax(); } sw.Stop(); return sw.ElapsedMilliseconds; } static int[] GetAscending(int n) { int[] ascending = new int[n]; for (int i = 0; i \u0026lt; n; i++) ascending[i] = random.Next(); Array.Sort(ascending); return ascending; } static int[] GetDescending(int n) { int[] descending = GetAscending(n); descending = descending.Reverse().ToArray(); return descending; } static int[] GetSame(int n, int v) { int[] same = new int[n]; for (int i = 0; i \u0026lt; n; i++) { same[i] = v; } return same; } static int[] GetBinary(int n, int a, int b) { int[] binary = new int[n]; for (int i = 0; i \u0026lt; n; i++) { binary[i] = random.NextDouble() \u0026gt; 0.5 ? a : b; } return binary; } } } 另请参阅 #  PriorityQueue 库\n"},{"id":315,"href":"/2-4-39/","title":"2.4.39","section":"帮助","content":"2.4.39 #  解答 #  结果如下，约占总耗时的 2~5%。\n代码 #  using System; using System.Diagnostics; namespace _2._4._39 { /* * 2.4.39 * * 构造函数的代价。 * 对于 N=10^3、10^6 和 10^9， * 根据经验判断堆排序时构造堆所占总耗时的比例。 * */ class Program { static Random random = new Random(); static void Main(string[] args) { Console.WriteLine(\u0026#34;n\\tBuild\\tSort\\tRatio\u0026#34;); int n = 1000; // 当数据量到达 10^9 时会需要 2G 左右的内存  int multiTen = 7; for (int i = 0; i \u0026lt; multiTen; i++) { short[] data = GetRandomArray(n); Stopwatch fullSort = new Stopwatch(); Stopwatch buildHeap = new Stopwatch(); fullSort.Restart(); buildHeap.Restart(); BuildHeap(data); buildHeap.Stop(); HeapSort(data); fullSort.Stop(); long buildTime = buildHeap.ElapsedMilliseconds; long fullTime = fullSort.ElapsedMilliseconds; Console.WriteLine(n + \u0026#34;\\t\u0026#34; + buildTime + \u0026#34;\\t\u0026#34; + fullTime + \u0026#34;\\t\u0026#34; + (double)buildTime / fullTime); n *= 10; } } static short[] GetRandomArray(int n) { short[] data = new short[n]; for (int i = 0; i \u0026lt; n; i++) { data[i] = (short)random.Next(); } return data; } /// \u0026lt;summary\u0026gt;  /// 将数组构造成堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;数组。\u0026lt;/param\u0026gt;  static void BuildHeap(short[] data) { int n = data.Length; for (int k = n / 2; k \u0026gt;= 1; k--) { Sink(data, k, n); } } /// \u0026lt;summary\u0026gt;  /// 利用已经生成的堆排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;heap\u0026#34;\u0026gt;最大堆。\u0026lt;/param\u0026gt;  static void HeapSort(short[] heap) { int n = heap.Length; while (n \u0026gt; 1) { Exch(heap, 1, n--); Sink(heap, 1, n); } } /// \u0026lt;summary\u0026gt;  /// 令堆中的元素下沉。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;需要执行操作的堆。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要执行下沉的结点下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;堆中元素的数目。\u0026lt;/param\u0026gt;  static void Sink(short[] pq, int k, int n) { while (2 * k \u0026lt;= n) { int j = 2 * k; if (j \u0026lt; n \u0026amp;\u0026amp; Less(pq, j, j + 1)) j++; if (!Less(pq, k, j)) break; Exch(pq, k, j); k = j; } } /// \u0026lt;summary\u0026gt;  /// 比较堆中下标为 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 的元素是否小于下标为 \u0026lt;paramref name=\u0026#34;b\u0026#34;/\u0026gt; 的元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;元素所在的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要比较是否较小的结点序号。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;需要比较是否较大的结点序号。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  static bool Less(short[] pq, int a, int b) =\u0026gt; pq[a - 1].CompareTo(pq[b - 1]) \u0026lt; 0; /// \u0026lt;summary\u0026gt;  /// 交换堆中的两个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;要交换的元素所在堆。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;要交换的结点序号。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;要交换的结点序号。\u0026lt;/param\u0026gt;  static void Exch(short[] pq, int a, int b) { short temp = pq[a - 1]; pq[a - 1] = pq[b - 1]; pq[b - 1] = temp; } } } 另请参阅 #  PriorityQueue 库\n"},{"id":316,"href":"/2-4-40/","title":"2.4.40","section":"帮助","content":"2.4.40 #  解答 #  如同书上所说，可以节省约 50% 的比较次数。\n先沉后浮的实现也很简单，将 swim 方法加入，\n然后修改 sink 方法，去掉其中检查是否需要下沉的条件（if(!Less(pq, k, j))），\n然后在 sink 方法的循环之后调用 swim。\n为了获得比较次数，你可以添加一个静态全局变量 compareCount，\n然后修改 Less 方法，在作比较的同时使 compareCount++ ，\n每次执行 Sort 时先让 compareCount 置零，最后返回 compareCount。\n代码 #  using System; namespace PriorityQueue { /// \u0026lt;summary\u0026gt;  /// 堆排序类，提供 Floyd 优化的堆排序的静态方法。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt;  public static class HeapFloyd { /// \u0026lt;summary\u0026gt;  /// 利用堆排序对数组进行排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public static void Sort\u0026lt;T\u0026gt;(T[] pq) where T : IComparable\u0026lt;T\u0026gt; { int n = pq.Length; // 建堆  for (int k = n / 2; k \u0026gt;= 1; k--) { Sink(pq, k, n); } // 排序  while (n \u0026gt; 1) { Exch(pq, 1, n--); SinkThenSwim(pq, 1, n); } } /// \u0026lt;summary\u0026gt;  /// 令堆中的元素下沉。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;需要执行操作的堆。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要执行下沉的结点下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;堆中元素的数目。\u0026lt;/param\u0026gt;  private static void Sink\u0026lt;T\u0026gt;(T[] pq, int k, int n) where T : IComparable\u0026lt;T\u0026gt; { while (2 * k \u0026lt;= n) { int j = 2 * k; if (j \u0026lt; n \u0026amp;\u0026amp; Less(pq, j, j + 1)) j++; if (!Less(pq, k, j)) break; Exch(pq, k, j); k = j; } } /// \u0026lt;summary\u0026gt;  /// 先下沉后上浮。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;堆中的元素类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;包含堆元素的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;要下沉的元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;元素数量。\u0026lt;/param\u0026gt;  private static void SinkThenSwim\u0026lt;T\u0026gt;(T[] pq, int k, int n) where T : IComparable\u0026lt;T\u0026gt; { while (2 * k \u0026lt;= n) { int j = 2 * k; if (j \u0026lt; n \u0026amp;\u0026amp; Less(pq, j, j + 1)) j++; Exch(pq, k, j); k = j; } Swim(pq, k); } /// \u0026lt;summary\u0026gt;  /// 使元素上浮。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要上浮的元素。\u0026lt;/param\u0026gt;  private static void Swim\u0026lt;T\u0026gt;(T[] pq, int k) where T : IComparable\u0026lt;T\u0026gt; { while (k \u0026gt; 1 \u0026amp;\u0026amp; Less(pq, k / 2, k)) { Exch(pq, k, k / 2); k /= 2; } } /// \u0026lt;summary\u0026gt;  /// 比较堆中下标为 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 的元素是否小于下标为 \u0026lt;paramref name=\u0026#34;b\u0026#34;/\u0026gt; 的元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;元素所在的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要比较是否较小的结点序号。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;需要比较是否较大的结点序号。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private static bool Less\u0026lt;T\u0026gt;(T[] pq, int a, int b) where T : IComparable\u0026lt;T\u0026gt; =\u0026gt; pq[a - 1].CompareTo(pq[b - 1]) \u0026lt; 0; /// \u0026lt;summary\u0026gt;  /// 交换堆中的两个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;要交换的元素所在堆。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;要交换的结点序号。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;要交换的结点序号。\u0026lt;/param\u0026gt;  private static void Exch\u0026lt;T\u0026gt;(T[] pq, int a, int b) { T temp = pq[a - 1]; pq[a - 1] = pq[b - 1]; pq[b - 1] = temp; } } } 另请参阅 #  PriorityQueue 库\n"},{"id":317,"href":"/2-4-41/","title":"2.4.41","section":"帮助","content":"2.4.41 #  解答 #  多叉堆和二叉堆的实现上并没有很大的区别，\n只不过下沉（Sink）时需要比较的子结点数量变多了，上浮时父结点的下标不再是 $\\lfloor k /2 \\rfloor$。\n于是只要能推出 $d$ 叉堆的下标换算公式即可解决整个问题。\n先考虑 $d$ 叉堆的在数组中的保存方式，\n第一层显然只有根结点，第二层显然有 $d$ 个结点，第三层则有 $d \\times d=d^2$ 个结点，如下图所示：\n不难推出第 $k$ 层有 $d^{k-1}$ 个结点。\n接下来我们对其标号，根结点为 1，以此类推，如下图：\n现在我们来推导某个结点的子结点的下标公式。\n结点 $i$ 的第一个子结点在哪里呢？\n首先要加上本层剩下的结点，再加上它前面结点的所有子结点，再下一个就是它的第一个子结点了。\n以 2 号结点为例，它是第二层的第一个结点，第二层共有 $d^{2-1}=d$ 个结点，剩下 $d-1$ 个结点。\n2 号结点前面没有更多兄弟结点，于是第一个子结点下标即为 $2 + d - 1 + 1= 2 + d$。\n3 号结点之后剩余 $d-2$ 个结点，加上前面 2 号结点的 $d$ 个子结点，\n它的第一个子结点下标为 $3+d-2+d+1= 2+2d$。\n不难发现规律，结点序号加一，子结点的下标就要对应加上 $d$（要加上前一个结点的子结点），\n这个规律也可以从图上（$d=3$）看出来：\n1号结点的子结点范围是 $[2,d+1]$，每加一个结点子结点就要加上 $d$ 。\n于是立即可以推得结点 $i$ 的子结点下标范围是 $[d(i-1)+2,di+1]$ 。\n代入 $d=2$，可以发现是符合我们已知的规律的。\n接下来是结点 $i$ 的父结点，\n我们由上面的式子反推可以得到父结点的下标为 $ \\lfloor (i-2)/d \\rfloor +1$（或者 $\\lceil (i-2)/d \\rceil$）。\n获得这两个公式之后，只需要将 sink 和 swim 方法中上升和下降的公式做相应更改即可。\n测试结果，注意下标可能会超过 int 的范围，请使用 long。：\n代码 #  using System; namespace PriorityQueue { /// \u0026lt;summary\u0026gt;  /// d 叉堆排序类，提供堆排序的静态方法。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt;  public static class HeapMultiway { /// \u0026lt;summary\u0026gt;  /// 利用堆排序对数组进行排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;d\u0026#34;\u0026gt;堆的分叉数。\u0026lt;/param\u0026gt;  public static void Sort\u0026lt;T\u0026gt;(T[] pq, int d) where T : IComparable\u0026lt;T\u0026gt; { int n = pq.Length; // 建堆  for (int k = (n - 2) / d + 1; k \u0026gt;= 1; k--) { Sink(pq, k, n, d); } // 排序  while (n \u0026gt; 1) { Exch(pq, 1, n--); Sink(pq, 1, n, d); } } /// \u0026lt;summary\u0026gt;  /// 令堆中的元素下沉。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;需要执行操作的堆。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要执行下沉的结点下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;堆中元素的数目。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;d\u0026#34;\u0026gt;堆的分叉数。\u0026lt;/param\u0026gt;  private static void Sink\u0026lt;T\u0026gt;(T[] pq, int k, int n, int d) where T : IComparable\u0026lt;T\u0026gt; { while ((k - 1) * d + 2 \u0026lt;= n) { int j = d * (k - 1) + 2; // 在 d 个子结点中找到最大的那个  for (int i = 0, q = j; i \u0026lt; d; i++) { if (q + i \u0026lt;= n \u0026amp;\u0026amp; Less(pq, j, q + i)) j = q + i; } if (!Less(pq, k, j)) break; Exch(pq, k, j); k = j; } } /// \u0026lt;summary\u0026gt;  /// 比较堆中下标为 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 的元素是否小于下标为 \u0026lt;paramref name=\u0026#34;b\u0026#34;/\u0026gt; 的元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;元素所在的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要比较是否较小的结点序号。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;需要比较是否较大的结点序号。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private static bool Less\u0026lt;T\u0026gt;(T[] pq, int a, int b) where T : IComparable\u0026lt;T\u0026gt; =\u0026gt; pq[a - 1].CompareTo(pq[b - 1]) \u0026lt; 0; /// \u0026lt;summary\u0026gt;  /// 交换堆中的两个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;要交换的元素所在堆。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;要交换的结点序号。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;要交换的结点序号。\u0026lt;/param\u0026gt;  private static void Exch\u0026lt;T\u0026gt;(T[] pq, int a, int b) { T temp = pq[a - 1]; pq[a - 1] = pq[b - 1]; pq[b - 1] = temp; } } } 另请参阅 #  D-ary Heap-Wikipedia\nPriorityQueue 库\n"},{"id":318,"href":"/2-4-42/","title":"2.4.42","section":"帮助","content":"2.4.42 #  解答 #  前序序列与完全二叉树 #  二叉树前序遍历的顺序是：自身，左子树，右子树。\n因此对于一个前序遍历序列，第一个元素是根结点，第二个元素是左子结点。\n再把左子结点找到，就可以把数组分成三部分：根结点，左子树，右子树，进而递归的构造出整个二叉树。\n现在问题是，右子结点在哪，或者说，左子树有多大？\n这里就要用到完全二叉树的性质了，我们先从比较简单的满二叉树入手。\n就满二叉树而言，根结点的左子树和右子树是一样大的，即左右子树大小均为 $(n-1)/2$ 。\n在这种情形下，右子结点的下标显然是 $(n+1)/2$ ，根结点下标为 0。\n完全二叉树可以视为在满二叉树的基础上加了一层叶子结点，现在我们已知结点总数 $n$。\n于是可以求得二叉树的高度 $k=\\lfloor \\log_2(n) \\rfloor$ ，注意只有一个结点的树高度为 0。\n那么最后一层的叶子结点数目为 $l=n-2^{k}+1$ 个，如下图所示：\n如果把最后一层（第 $k$ 层）去掉，剩余部分即为高度为 $k-1$ 的满二叉树，结点总数为 $2^k - 1$ 。\n按照之前的说明可以知道左右子树大小都等于 $(2^{k}-2)/2=2^{k-1}-1$。\n现在要将第 $k$ 层的 $l$ 个结点分到左右子树里面去。\n第 $k$ 层最多能有 $2^k$ 个结点，取半就是 $2^k / 2 = 2^{k-1}$ 个。\n于是当 $l\u0026lt;=2^{k-1}$ 时，左右子树大小分别为 $2^{k-1}-1+l$ 和 $2^{k-1}-1$ 。\n当 $l \u0026gt; 2^{k-1}$ 时，左右子树大小分别为 $2^{k} - 1$ 和 $2^{k-1} -1 +l -2^{k-1}=l-1$ 。\n实际上，我们只要先取根结点，然后再取 $2^{k-1} -1$ 个结点给左子树，再做判断：\n如果 $n-2^{k-1} \u0026lt; 2^{k}-1$ ，那么对应第一种情况，末尾的 $2^{k-1}-1$ 个结点即为右子树。\n否则就是第二种情况，前面的 $ 2^k$ 个结点就是根结点和左子树，剩下的为右子树。\n堆排序的实现 #  现在我们能够根据结点总数 $n$ 来确定相应的完全二叉树，接下来则是如何进行堆排序。\n堆排序的第一步就是建堆，建堆时最主要的就是 sink 操作了。\n但前序序列中除了第一个结点（根结点）之外，其他结点的左右子结点下标是不能直接通过计算得到的。\n因此在前序实现中，sink 操作只能对根结点进行，引出了下面的递归建堆方法。\n如果根结点的左右两棵子树都已经是堆了，那么只要对根结点进行 sink 操作即可使整个二叉树变成堆。\n第一步先检查子树的大小，如果小于等于 1 则说明是叶结点，直接返回。\n否则计算出左右子结点的位置，递归地建堆。\n最后对根结点进行 sink 操作。\n那么这个 sink 操作是怎么做的呢？\n计算得到了左右子结点的下标后，比较得出较大的那个，如果大于根结点则交换，否则返回。\n交换后根结点变成了某一侧子树的根结点，递归地进行 sink 即可。\n接下来是排序，最主要的操作是 DelMax。\n前序序列的根结点好找，但是最后一个结点就比较麻烦了，它既可能在左子树也可能在右子树。\n但我们可以根据之前的大小关系来寻找，\n如果左子树小于等于 $2^k - 1$ ，那么最后一个结点一定在左子树，否则就在右子树。\n递归进行上述过程，直到到达叶子结点，该叶子结点就是最后一个结点。\n之后我们将最后一个结点暂存，整个数组从后向前补缺（这一步将导致算法变成 $O(n^2)$ ），\n再把第一个结点放到最后的空位上，最后把存起来的结点放到第一位，对该结点进行 sink 操作。\n依次往复即可完成排序。\n测试结果：\n这个算法在设计上与一般实现的比较次数大体相等，\n只是移动数组耗时较长，这里只给到 $10^7$。\n代码 #  using System; namespace PriorityQueue { /// \u0026lt;summary\u0026gt;  /// 前序堆排序类，提供堆排序的静态方法。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt;  public static class HeapPreorderAnalysis { private static long compareTimes = 0; /// \u0026lt;summary\u0026gt;  /// 利用堆排序对数组进行排序。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt;  public static long Sort\u0026lt;T\u0026gt;(T[] pq) where T : IComparable\u0026lt;T\u0026gt; { compareTimes = 0; int n = pq.Length; BuildTree(pq, 0, pq.Length); // 排序  while (n \u0026gt; 1) { int tail = GetTail(pq, 0, n); T temp = pq[tail]; for (int i = tail + 1; i \u0026lt; n; i++) pq[i - 1] = pq[i]; n--; Exch(pq, 0, n); pq[0] = temp; Sink(pq, 0, n); } return compareTimes; } private static int GetTail\u0026lt;T\u0026gt;(T[] pq, int p, int n) { if (n \u0026lt;= 1) return p; int k = (int)(Math.Log10(n) / Math.Log10(2)); // 高度  int left = (int)Math.Pow(2, k - 1) - 1; int right = left; if (n - left \u0026lt;= (int)Math.Pow(2, k)) { // 叶子结点全在左侧  left = n - right - 1; return GetTail(pq, p + 1, left); } else { left = (int)Math.Pow(2, k) - 1; right = n - left - 1; return GetTail(pq, p + 1 + left, right); } } /// \u0026lt;summary\u0026gt;  /// 递归建堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;堆中元素。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;堆所在的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;堆的起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;堆的元素数目。\u0026lt;/param\u0026gt;  private static void BuildTree\u0026lt;T\u0026gt;(T[] pq, int p, int n) where T : IComparable\u0026lt;T\u0026gt; { if (n \u0026lt;= 1) return; int k = (int)(Math.Log10(n) / Math.Log10(2)); // 高度  int left = (int)Math.Pow(2, k - 1) - 1; int right = left; if (n - left \u0026lt;= (int)Math.Pow(2, k)) { // 叶子结点全在左侧  left = n - right - 1; } else { left = (int)Math.Pow(2, k) - 1; right = n - left - 1; } BuildTree(pq, p + 1, left); BuildTree(pq, p + 1 + left, right); Sink(pq, p, n); } /// \u0026lt;summary\u0026gt;  /// 令堆中的元素下沉。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;需要执行操作的堆。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要执行下沉的结点下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;堆中元素的数目。\u0026lt;/param\u0026gt;  private static void Sink\u0026lt;T\u0026gt;(T[] pq, int p, int n) where T : IComparable\u0026lt;T\u0026gt; { if (n \u0026lt;= 1) return; int k = (int)(Math.Log10(n) / Math.Log10(2)); // 高度  int left = (int)Math.Pow(2, k - 1) - 1; int right = left; if (n - left \u0026lt;= (int)Math.Pow(2, k)) { // 叶子结点全在左侧  left = n - right - 1; } else { left = (int)Math.Pow(2, k) - 1; right = n - left - 1; } // 找出较大的子结点  int j = p + 1, size = left; if (right != 0) // 有右结点  { if (Less(pq, j, p + left + 1)) { j = p + left + 1; size = right; } } // 与根结点比较  if (!Less(pq, p, j)) return; // 交换，继续下沉  Exch(pq, p, j); Sink(pq, j, size); } /// \u0026lt;summary\u0026gt;  /// 比较堆中下标为 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 的元素是否小于下标为 \u0026lt;paramref name=\u0026#34;b\u0026#34;/\u0026gt; 的元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;元素所在的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要比较是否较小的结点序号。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;需要比较是否较大的结点序号。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private static bool Less\u0026lt;T\u0026gt;(T[] pq, int a, int b) where T : IComparable\u0026lt;T\u0026gt; { compareTimes++; return pq[a].CompareTo(pq[b]) \u0026lt; 0; } /// \u0026lt;summary\u0026gt;  /// 交换堆中的两个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;要交换的元素所在堆。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;要交换的结点序号。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;要交换的结点序号。\u0026lt;/param\u0026gt;  private static void Exch\u0026lt;T\u0026gt;(T[] pq, int a, int b) { T temp = pq[a]; pq[a] = pq[b]; pq[b] = temp; } } } 另请参阅 #  PriorityQueue 库\n"},{"id":319,"href":"/2-5-1/","title":"2.5.1","section":"帮助","content":"2.5.1 #  解答 #  如果比较的两个 String 引用的是同一个对象，那么就直接返回相等，不必再逐字符比较。\n一个例子：\nstring s = \u0026#34;abcabc\u0026#34;; string p = s; Console.WriteLine(s.CompareTo(p)); "},{"id":320,"href":"/2-5-2/","title":"2.5.2","section":"帮助","content":"2.5.2 #  解答 #  将字符串数组 keywords 按照长度排序，于是 keywords[0] 就是最短的字符串。\n组合词的最短长度 minLength = 最短字符串的长度 * 2 = keywords[0] * 2。\n先找到第一个长度大于等于 minLength 的字符串，下标为 canCombine。\n我们从 canCombine 开始，一个个检查是否是组合词。\n如果 keywords[canCombine] 是一个组合词，那么它一定是由位于它之前的某两个字符串组合而成的。\n组合词的长度一定等于被组合词的长度之和，因此我们可以通过长度快速判断有可能的组合词。\n现在题目转化为了如何解决 ThreeSum 问题，即求 a + b = c 型问题，根据 1.4.41 中的解法求解。\nkeywords[canCombine] 的长度已知，i 从 0 到 canCombine 之间循环，\n用二分查找确认 i 到 canCombine 之间有没有符合条件的字符串，注意多个字符串可能长度相等。\n代码 #  using System; using System.Collections.Generic; namespace _2._5._2 { /* * 2.5.2 * * 编写一段程序，从标准输入读入一列单词并打印出其中所有由两个单词组成的组合词。 * 例如，如果输入的单词为 after、thought 和 afterthought， * 那么 afterthought 就是一个组合词。 * */ class Program { /// \u0026lt;summary\u0026gt;  /// 根据字符串长度进行比较。  /// \u0026lt;/summary\u0026gt;  class StringLengthComparer : IComparer\u0026lt;string\u0026gt; { public int Compare(string x, string y) { return x.Length.CompareTo(y.Length); } } /// \u0026lt;summary\u0026gt;  /// 二分查找，返回符合条件的最小下标。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;keys\u0026#34;\u0026gt;搜索范围。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;length\u0026#34;\u0026gt;搜索目标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;起始下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;终止下标。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  static int BinarySearch(string[] keys, int length, int lo, int hi) { while (lo \u0026lt;= hi) { int mid = lo + (hi - lo) / 2; if (keys[mid].Length == length) { while (mid \u0026gt;= lo \u0026amp;\u0026amp; keys[mid].Length == length) mid--; return mid + 1; } else if (length \u0026gt; keys[mid].Length) lo = mid + 1; else hi = mid - 1; } return -1; } static void Main(string[] args) { string[] keywords = Console.ReadLine().Split(\u0026#39; \u0026#39;); Array.Sort(keywords, new StringLengthComparer()); int minLength = keywords[0].Length * 2; // 找到第一个大于 minLength 的字符串  int canCombine = 0; while (keywords[canCombine].Length \u0026lt; minLength \u0026amp;\u0026amp; canCombine \u0026lt; keywords.Length) canCombine++; // 依次测试是否可能  while (canCombine \u0026lt; keywords.Length) { int sum = keywords[canCombine].Length; for (int i = 0; i \u0026lt; canCombine; i++) { int start = BinarySearch(keywords, sum - keywords[i].Length, i, canCombine); if (start != -1) { while (keywords[start].Length + keywords[i].Length == sum) { if (keywords[start] + keywords[i] == keywords[canCombine]) Console.WriteLine(keywords[canCombine] + \u0026#34; = \u0026#34; + keywords[start] + \u0026#34; + \u0026#34; + keywords[i]); else if (keywords[i] + keywords[start] == keywords[canCombine]) Console.WriteLine(keywords[canCombine] + \u0026#34; = \u0026#34; + keywords[i] + \u0026#34; + \u0026#34; + keywords[start]); start++; } } } canCombine++; } } } } "},{"id":321,"href":"/2-5-3/","title":"2.5.3","section":"帮助","content":"2.5.3 #  解答 #  这样会破坏相等的传递性。\n例如 a = 0.005, b=0.000, c=-0.005，则 a == b, c == b，但是 a != c。\n"},{"id":322,"href":"/2-5-4/","title":"2.5.4","section":"帮助","content":"2.5.4 #  解答 #  先排序，然后用书中的代码进行去重。\nstatic string[] Dedup(string[] a) { if (a.Length == 0) return a; string[] sorted = new string[a.Length]; for (int i = 0; i \u0026lt; a.Length; i++) { sorted[i] = a[i]; } Array.Sort(sorted); // sorted = sorted.Distinct().ToArray();  string[] distinct = new string[sorted.Length]; distinct[0] = sorted[0]; int j = 1; for (int i = 1; i \u0026lt; sorted.Length; i++) { if (sorted[i].CompareTo(sorted[i - 1]) != 0) distinct[j++] = sorted[i]; } return distinct; } "},{"id":323,"href":"/2-5-5/","title":"2.5.5","section":"帮助","content":"2.5.5 #  解答 #  因为选择排序会交换不相邻的元素。\n例如：\nB1 B2 A A B2 B1 此时 B1 和 B2 的相对位置被改变，如果将交换限定在相邻元素之间（插入排序）。\nB1 B2 A B1 A B2 A B2 B2 此时排序就是稳定的了。\n"},{"id":324,"href":"/2-5-6/","title":"2.5.6","section":"帮助","content":"2.5.6 #  解答 #  非递归官网实现见：https://algs4.cs.princeton.edu/23quicksort/QuickPedantic.java.html\n原本是和快速排序一块介绍的，将数组重新排列，使得 a[k] 正好是第 k 小的元素，k 从 0 开始。\n具体思路类似于二分查找，\n先切分，如果切分位置小于 k，那么在右半部分继续切分，否则在左半部分继续切分。\n直到切分位置正好等于 k，直接返回 a[k] 。\n代码 #  /// \u0026lt;summary\u0026gt; /// 使 a[k] 变为第 k 小的数，k 从 0 开始。 /// a[0] ~ a[k-1] 都小于等于 a[k], a[k+1]~a[n-1] 都大于等于 a[k] /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要调整的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;序号。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;终止下标。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static T Select\u0026lt;T\u0026gt;(T[] a, int k, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (k \u0026gt; a.Length || k \u0026lt; 0) throw new ArgumentOutOfRangeException(\u0026#34;select out of bound\u0026#34;); if (lo \u0026gt;= hi) return a[lo]; int i = Partition(a, lo, hi); if (i \u0026gt; k) return Select(a, k, lo, i - 1); else if (i \u0026lt; k) return Select(a, k, i + 1, hi); else return a[i]; } 另请参阅 #  SortApplication 库\n"},{"id":325,"href":"/2-5-7/","title":"2.5.7","section":"帮助","content":"2.5.7 #  解答 #  参考书中给出的快速排序性能分析方法（中文版 P186，英文版 P293）。\n设 $C_n$ 代表找出 $n$ 个元素中的最小值所需要的比较次数。\n一次切分需要 $n+1$ 次比较，下一侧的元素个数从 $0$ 到 $ n-1 ​$ 都有可能，\n于是根据全概率公式，有：\n$$\n\\begin{eqnarray}\nC_n\u0026amp;=\u0026amp;\\frac {1}{n} (n+1) +\\frac{1}{n} (n+1+C_1)+ \\cdots + \\frac{1}{n}(n+1+C_{n-1}) \\\nC_n\u0026amp;=\u0026amp;n+1+\\frac{1}{n}(C_1+C_2+\\cdots+C_{n-1}) \\\nnC_n\u0026amp;=\u0026amp;n(n+1)+(C_1+C_2+\\cdots+C_{n-1}) \\\nnC_n-(n-1)C_{n-1}\u0026amp;=\u0026amp;2n+C_{n-1} \\\nnC_n\u0026amp;=\u0026amp;2n+nC_{n-1} \\\nC_n\u0026amp;=\u0026amp;2+C_{n-1} \\\nC_n \u0026amp;=\u0026amp; C_1+2(n-1) \\\nC_n \u0026amp;=\u0026amp; 2n-2 \u0026lt; 2n\n\\end{eqnarray}\n$$\n测试结果符合我们的预期。\n附加：找出第 $k$ 小的数平均需要的比较次数。\n类似的方法也在计算快速排序的平均比较次数时使用，见 {% post_link 2-3-14.md %}。\n首先和快速排序类似，select 方法的所有元素比较都发生在切分过程中。\n接下来考虑第 $i$ 小和第 $j$ 小的元素（$x_i$ ，$x_j$），\n当枢轴选为 $x_i$ 或 $x_j$ 时，它们会发生比较；\n如果枢轴选为 $x_i$ 和 $x_j$ 之间的元素，那么它们会被切分到两侧，不可能发生比较；\n如果枢轴选为小于 $x_i$ 或大于 $x_j$ 的元素，它们会被切分到同一侧，进入下次切分。\n但要注意的是，select 只会对切分的一侧进行再切分，另一侧会被抛弃（快速排序则是两侧都会再切分）。\n因此我们需要将第 $k$ 小的数 $x_k$ 纳入考虑。\n如果 $x_k\u0026gt;x_j\u0026gt;x_i$ ，且枢轴选了 $x_k$ 到 $x_j$ 之间的元素，切分后 $x_i$ 和 $x_j$ 会被一起抛弃，不发生比较。\n如果 $x_j \u0026gt; x_k \u0026gt; x_i$ ，枢轴的选择情况和快速排序一致。\n如果 $x_j \u0026gt; x_i \u0026gt; x_k$ ，且枢轴选了 $x_i$ 到 $x_k$ 之间的元素，切分后 $x_i$ 和 $x_j$ 会被一起抛弃，不发生比较。\n综上我们可以得到 $x_i$ 和 $x_j$ 之间发生比较的概率 $\\frac{2}{\\max(j-i+1, k-i+1,j-k+1)}$ 。\n我们利用线性规划的知识把最大值函数的区域画出来，如下图所示：\n对蓝色区域积分得：\n$$\n\\begin{eqnarray}\n\u0026amp;\u0026amp;\\int_{0}^{k} dj \\int_{0}^{j} \\frac{2}{j-k+1}\\ di \\\n\u0026amp;=\u0026amp; 2 \\int_{0}^{k} \\frac{j}{j-k+1} \\ dj \\\n\u0026amp;\u0026lt;\u0026amp; 2 k\n\\end{eqnarray}\n$$\n对红色区域积分得：\n$$\n\\begin {eqnarray}\n\u0026amp;\u0026amp; \\int_{k}^{n} di \\int_{i}^{n} \\frac{2}{k-i+1} dj \\\n\u0026amp;=\u0026amp; 2\\int_{k}^{n} \\frac{n-i}{k-i+1} di \\\n\u0026amp;\u0026lt;\u0026amp; 2(n-k)\n\\end {eqnarray}\n$$\n对绿色区域积分得：\n$$\n\\begin{eqnarray}\n\u0026amp;\u0026amp; \\int_{0}^{k}di\\int_{k}^{n} \\frac{2}{j-i+1} dj \\\n\u0026amp;\u0026lt;\u0026amp; \\int_{0}^{k}di\\int_{k}^{n} \\frac{2}{j-i} dj \\\n\u0026amp;=\u0026amp; 2\\int_{0}^{k} \\ln (n-i) di - 2\\int_{0}^{k} \\ln(k-i)di \\\n\u0026amp;=\u0026amp; 2i\\ln(n-i) \\bigg|{0}^{k} + 2\\int{0}^{k}\\frac{i}{n-i} di -\n\\left[ i\\ln(k-i) \\bigg|{0}^{k} + 2\\int{0}^{k} \\frac{i}{k-i} di \\right] \\\n\u0026amp;=\u0026amp; 2k\\ln(n-k)+2\\int_{0}^{k}\\frac{n}{n-i}-1 \\ di -2\\int_{0}^{k} \\frac{k}{k-i}-1 \\ di \\\n\u0026amp;=\u0026amp; 2k\\ln(n-k)+2\\int_{0}^{k}\\frac{n}{n-i} \\ di -2k - 2\\int_{0}^{k} \\frac{k}{k-i} \\ di +2k \\\n\u0026amp;=\u0026amp; 2k\\ln(n-k) -2n\\ln(n-i) \\bigg|{0}^{k} +2k\\ln(k-i)\\bigg|{0}^{k} \\\n\u0026amp;=\u0026amp; 2k\\ln(n-k)-2n\\ln(n-k)+2n\\ln n -2k\\ln k\n\\end{eqnarray}\n$$\n全部相加得到：\n$$\n\\begin{eqnarray}\n\u0026amp;\u0026amp; 2k+2(n-k)+2k\\ln(n-k)-2n\\ln(n-k)+2n\\ln n -2k\\ln k \\\n\u0026amp;=\u0026amp; 2n + 2k\\ln(n-k)-2n\\ln(n-k)+2n\\ln n -2k\\ln k \\\n\u0026amp;=\u0026amp; 2n + 2k\\ln(n-k)-2n\\ln(n-k)+2n\\ln n-2k\\ln k +2k\\ln n-2k\\ln n \\\n\u0026amp;=\u0026amp; 2n + 2k\\ln n-2k\\ln k+2n\\ln n-2n\\ln(n-k) - 2k\\ln n + 2k\\ln(n-k) \\\n\u0026amp;=\u0026amp; 2n + 2k\\ln \\left(\\frac{n}{k} \\right)+2n\\ln\\left(\\frac{n}{n-k} \\right) - 2k\\ln\\left(\\frac{n}{n-k} \\right) \\\n\u0026amp;=\u0026amp; 2n+2k\\ln\\left(\\frac{n}{k}\\right)+2(n-k)\\ln\\left(\\frac{n}{n-k} \\right)\n\\end{eqnarray}\n$$\n于是得到了命题 U 中的结果（中文版 P221，英文版 P347）。\n另请参阅 #  Blum-style analysis of Quickselect\n"},{"id":326,"href":"/2-5-8/","title":"2.5.8","section":"帮助","content":"2.5.8 #  解答 #  官网实现见：https://algs4.cs.princeton.edu/25applications/Frequency.java.html\n用到的数据来自（右键另存为）：https://introcs.cs.princeton.edu/java/data/tale.txt\n先把所有单词读入，然后排序，一样的单词会被放在一起，\n接下来遍历一遍记录每个单词出现的次数。\n然后按照频率排序，倒序输出即可。\n定义了一个嵌套类 Record 来记录单词及出现次数，实现的比较器按照出现次数排序。\nclass Record : IComparable\u0026lt;Record\u0026gt; { public string Key { get; set; } // 单词  public int Value { get; set; } // 频率  public Record(string key, int value) { this.Key = key; this.Value = value; } public int CompareTo(Record other) { return this.Value.CompareTo(other.Value); } } 测试结果（前 1% 的单词）：\n代码 #  using System; using System.IO; namespace _2._5._8 { class Program { class Record : IComparable\u0026lt;Record\u0026gt; { public string Key { get; set; } // 单词  public int Value { get; set; } // 频率  public Record(string key, int value) { this.Key = key; this.Value = value; } public int CompareTo(Record other) { return this.Value.CompareTo(other.Value); } } static void Main(string[] args) { string filename = \u0026#34;tale.txt\u0026#34;; StreamReader sr = new StreamReader(File.OpenRead(filename)); string[] a = sr.ReadToEnd().Split(new char[] { \u0026#39; \u0026#39;, \u0026#39;\\n\u0026#39;, \u0026#39;\\r\u0026#39; }, StringSplitOptions.RemoveEmptyEntries); Array.Sort(a); Record[] records = new Record[a.Length]; string word = a[0]; int freq = 1; int m = 0; for (int i = 0; i \u0026lt; a.Length; i++) { if (!a[i].Equals(word)) { records[m++] = new Record(word, freq); word = a[i]; freq = 0; } freq++; } records[m++] = new Record(word, freq); Array.Sort(records, 0, m); // 只显示频率为前 1% 的单词  for (int i = m - 1; i \u0026gt;= m * 0.99; i--) Console.WriteLine(records[i].Value + \u0026#34; \u0026#34; + records[i].Key); } } } "},{"id":327,"href":"/2-5-9/","title":"2.5.9","section":"帮助","content":"2.5.9 #  解答 #  右侧给出的是道琼斯指数，官方数据（右键另存为）：DJI\n设计一个类保存日期和交易量，然后按照交易量排序即可。\n/// \u0026lt;summary\u0026gt; /// 道琼斯指数。 /// \u0026lt;/summary\u0026gt; class DJIA : IComparable\u0026lt;DJIA\u0026gt; { public string Date { get; set; } public long Volume { get; set; } public DJIA(string date, long vol) { this.Date = date; this.Volume = vol; } public int CompareTo(DJIA other) { return this.Volume.CompareTo(other.Volume); } } "},{"id":328,"href":"/2-5-10/","title":"2.5.10","section":"帮助","content":"2.5.10 #  解答 #  用一个 int 数组来保存版本号，按顺序进行比较。\n如果两个版本号不等长且前缀相同，那么较长的版本号比较高，例如：1.2.1 和 1.2。\nusing System; namespace _2._5._10 { /// \u0026lt;summary\u0026gt;  /// 版本号。  /// \u0026lt;/summary\u0026gt;  class Version : IComparable\u0026lt;Version\u0026gt; { private int[] versionNumber; public Version(string version) { string[] versions = version.Split(\u0026#39;.\u0026#39;); this.versionNumber = new int[versions.Length]; for (int i = 0; i \u0026lt; versions.Length; i++) { this.versionNumber[i] = int.Parse(versions[i]); } } public int CompareTo(Version other) { for (int i = 0; i \u0026lt; this.versionNumber.Length \u0026amp;\u0026amp; i \u0026lt; other.versionNumber.Length; i++) { if (this.versionNumber[i].CompareTo(other.versionNumber[i]) != 0) return this.versionNumber[i].CompareTo(other.versionNumber[i]); } return this.versionNumber.Length.CompareTo(other.versionNumber.Length); } public override string ToString() { string result = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; this.versionNumber.Length - 1; i++) { result += this.versionNumber[i] + \u0026#34;.\u0026#34;; } result += this.versionNumber[this.versionNumber.Length - 1].ToString(); return result; } } } "},{"id":329,"href":"/2-5-11/","title":"2.5.11","section":"帮助","content":"2.5.11 #  解答 #  结果如下，其中快速排序去掉了一开始打乱数组的步骤：\n只有快速排序和堆排序会进行交换，剩下四种排序都不会进行交换。\n插入排序在排序元素完全相同的数组时只会进行一次遍历，不会交换。\n选择排序第 i 次找到的最小值就是 a[i] ，只会让 a[i] 和 a[i] 交换，不会影响顺序。\n希尔排序和插入排序类似，每轮排序都不会进行交换。\n归并排序是稳定的，就本例而言，只会从左到右依次归并，不会发生顺序变化。\n快速排序在遇到相同元素时会交换，因此顺序会发生变化，且每次都是对半切分。\n堆排序在删除最大元素时会将第一个元素和最后一个元素交换，使元素顺序发生变化。\n代码 #  using System; using SortApplication; namespace _2._5._11 { class Program { /// \u0026lt;summary\u0026gt;  /// 用来排序的元素，记录有自己的初始下标。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;\u0026lt;/typeparam\u0026gt;  class Item\u0026lt;T\u0026gt; : IComparable\u0026lt;Item\u0026lt;T\u0026gt;\u0026gt; where T : IComparable\u0026lt;T\u0026gt; { public int Index; public T Key; public Item(int index, T key) { this.Index = index; this.Key = key; } public int CompareTo(Item\u0026lt;T\u0026gt; other) { return this.Key.CompareTo(other.Key); } } static void Main(string[] args) { // 插入排序  Console.WriteLine(\u0026#34;Insertion Sort\u0026#34;); Test(new InsertionSort(), 7, 1); // 选择排序  Console.WriteLine(\u0026#34;Selection Sort\u0026#34;); Test(new SelectionSort(), 7, 1); // 希尔排序  Console.WriteLine(\u0026#34;Shell Sort\u0026#34;); Test(new ShellSort(), 7, 1); // 归并排序  Console.WriteLine(\u0026#34;Merge Sort\u0026#34;); Test(new MergeSort(), 7, 1); // 快速排序  Console.WriteLine(\u0026#34;Quick Sort\u0026#34;); QuickSortAnalyze quick = new QuickSortAnalyze { NeedShuffle = false, NeedPath = false }; Test(quick, 7, 1); // 堆排序  Console.WriteLine(\u0026#34;Heap Sort\u0026#34;); Item\u0026lt;int\u0026gt;[] array = new Item\u0026lt;int\u0026gt;[7]; for (int i = 0; i \u0026lt; 7; i++) array[i] = new Item\u0026lt;int\u0026gt;(i, 1); Heap.Sort(array); for (int i = 0; i \u0026lt; 7; i++) Console.Write(array[i].Index + \u0026#34; \u0026#34;); Console.WriteLine(); } static void Test(BaseSort sort, int n, int constant) { Item\u0026lt;int\u0026gt;[] array = new Item\u0026lt;int\u0026gt;[n]; for (int i = 0; i \u0026lt; n; i++) array[i] = new Item\u0026lt;int\u0026gt;(i, constant); sort.Sort(array); for (int i = 0; i \u0026lt; n; i++) Console.Write(array[i].Index + \u0026#34; \u0026#34;); Console.WriteLine(); } } } 另请参阅 #  SortApplication 库\n"},{"id":330,"href":"/2-5-12/","title":"2.5.12","section":"帮助","content":"2.5.12 #  解答 #  官方解答：https://algs4.cs.princeton.edu/25applications/SPT.java.html\n把任务按照处理时间升序排序即可。\n建立 Job 类，保存任务的名称和处理时间，并实现了 IConparable\u0026lt;Job\u0026gt; 接口。\nclass Job : IComparable\u0026lt;Job\u0026gt; { public string Name; public double Time; public Job(string name, double time) { this.Name = name; this.Time = time; } public int CompareTo(Job other) { return this.Time.CompareTo(other.Time); } } 代码 #  using System; namespace _2._5._12 { class Program { class Job : IComparable\u0026lt;Job\u0026gt; { public string Name; public double Time; public Job(string name, double time) { this.Name = name; this.Time = time; } public int CompareTo(Job other) { return this.Time.CompareTo(other.Time); } } static void Main(string[] args) { // 官方解答：https://algs4.cs.princeton.edu/25applications/SPT.java.html  int n = int.Parse(Console.ReadLine()); Job[] jobs = new Job[n]; for (int i = 0; i \u0026lt; n; i++) { string[] input = Console.ReadLine().Split(\u0026#39; \u0026#39;); jobs[i] = new Job(input[0], double.Parse(input[1])); } Array.Sort(jobs); for (int i = 0; i \u0026lt; jobs.Length; i++) { Console.WriteLine(jobs[i].Name + \u0026#34; \u0026#34; + jobs[i].Time); } } } } "},{"id":331,"href":"/2-5-13/","title":"2.5.13","section":"帮助","content":"2.5.13 #  解答 #  官方解答见：https://algs4.cs.princeton.edu/25applications/LPT.java.html\n使用上题的 Job 类，在本题建立 Processor 类来代表处理器，定义如下：\nclass Processor : IComparable\u0026lt;Processor\u0026gt; { private List\u0026lt;Job\u0026gt; jobs = new List\u0026lt;Job\u0026gt;(); private double busyTime = 0; public Processor() { } public void Add(Job job) { this.jobs.Add(job); this.busyTime += job.Time; } public int CompareTo(Processor other) { return this.busyTime.CompareTo(other.busyTime); } public override string ToString() { StringBuilder sb = new StringBuilder(); Job[] nowList = this.jobs.ToArray(); for (int i = 0; i \u0026lt; nowList.Length; i++) { sb.AppendLine(nowList[i].Name + \u0026#34; \u0026#34; + nowList[i].Time); } return sb.ToString(); } } 按照读入所有的任务并排序，再将所有的处理器放进一个最小堆里。\n从最小堆取出任务最轻的处理器，按取耗时最长的任务分配给它，再将它放回最小堆中。\n最后依次打印处理器的任务分配即可。\n代码 #  using System; using System.Collections.Generic; using System.Text; using SortApplication; namespace _2._5._13 { class Program { class Job : IComparable\u0026lt;Job\u0026gt; { public string Name; public double Time; public Job(string name, double time) { this.Name = name; this.Time = time; } public int CompareTo(Job other) { return this.Time.CompareTo(other.Time); } } class Processor : IComparable\u0026lt;Processor\u0026gt; { private List\u0026lt;Job\u0026gt; jobs = new List\u0026lt;Job\u0026gt;(); private double busyTime = 0; public Processor() { } public void Add(Job job) { this.jobs.Add(job); this.busyTime += job.Time; } public int CompareTo(Processor other) { return this.busyTime.CompareTo(other.busyTime); } public override string ToString() { StringBuilder sb = new StringBuilder(); Job[] nowList = this.jobs.ToArray(); for (int i = 0; i \u0026lt; nowList.Length; i++) { sb.AppendLine(nowList[i].Name + \u0026#34; \u0026#34; + nowList[i].Time); } return sb.ToString(); } } static void Main(string[] args) { int processorNum = int.Parse(Console.ReadLine()); int jobNum = int.Parse(Console.ReadLine()); Job[] jobs = new Job[jobNum]; for (int i = 0; i \u0026lt; jobNum; i++) { string[] jobDesc = Console.ReadLine().Split(\u0026#39; \u0026#39;); jobs[i] = new Job(jobDesc[0], double.Parse(jobDesc[1])); } Array.Sort(jobs); MinPQ\u0026lt;Processor\u0026gt; processors = new MinPQ\u0026lt;Processor\u0026gt;(processorNum); for (int i = 0; i \u0026lt; processorNum; i++) { processors.Insert(new Processor()); } for (int i = jobs.Length - 1; i \u0026gt;= 0; i--) { Processor min = processors.DelMin(); min.Add(jobs[i]); processors.Insert(min); } while (!processors.IsEmpty()) { Console.WriteLine(processors.DelMin()); } } } } 另请参阅 #  SortApplication 库\n"},{"id":332,"href":"/2-5-14/","title":"2.5.14","section":"帮助","content":"2.5.14 #  解答 #  官方解答：https://algs4.cs.princeton.edu/25applications/Domain.java.html\n按照逆域名排序，例如输入的是 com.google 和 com.apple ，\n比较的时候是按照 google.com 和 apple.com 进行比较的。\n排序结果自然是 apple.com, google.com。\n编写的 Domain 类，CompareTo() 中是按照倒序进行比较的。\nusing System; using System.Text; namespace _2._5._14 { /// \u0026lt;summary\u0026gt;  /// 域名类。  /// \u0026lt;/summary\u0026gt;  class Domain : IComparable\u0026lt;Domain\u0026gt; { private string[] fields; private int n; /// \u0026lt;summary\u0026gt;  /// 构造一个域名。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;url\u0026#34;\u0026gt;域名的 url。\u0026lt;/param\u0026gt;  public Domain(string url) { this.fields = url.Split(\u0026#39;.\u0026#39;); this.n = this.fields.Length; } public int CompareTo(Domain other) { int minLength = Math.Min(this.n, other.n); for (int i = 0; i \u0026lt; minLength; i++) { int c = this.fields[minLength - i - 1].CompareTo(other.fields[minLength - i - 1]); if (c != 0) return c; } return this.n.CompareTo(other.n); } public override string ToString() { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; this.fields.Length; i++) { if (i != 0) sb.Append(\u0026#39;.\u0026#39;); sb.Append(this.fields[i]); } return sb.ToString(); } } } 代码 #  using System; namespace _2._5._14 { class Program { static void Main(string[] args) { Domain[] domains = new Domain[5]; domains[0] = new Domain(\u0026#34;edu.princeton.cs\u0026#34;); domains[1] = new Domain(\u0026#34;edu.princeton.ee\u0026#34;); domains[2] = new Domain(\u0026#34;com.google\u0026#34;); domains[3] = new Domain(\u0026#34;edu.princeton\u0026#34;); domains[4] = new Domain(\u0026#34;com.apple\u0026#34;); Array.Sort(domains); for (int i = 0; i \u0026lt; domains.Length; i++) { Console.WriteLine(domains[i]); } } } } "},{"id":333,"href":"/2-5-15/","title":"2.5.15","section":"帮助","content":"2.5.15 #  解答 #  利用上一题的逆域名排序将域名相同的电子邮件分在一起。\n代码 #  using System; namespace _2._5._15 { class Program { static void Main(string[] args) { // 利用上一题的逆域名排序，将相同的域名放在一起。  Domain[] emails = new Domain[5]; emails[0] = new Domain(\u0026#34;wayne@cs.princeton.edu\u0026#34;); emails[1] = new Domain(\u0026#34;windy@apple.com\u0026#34;); emails[2] = new Domain(\u0026#34;rs@cs.princeton.edu\u0026#34;); emails[3] = new Domain(\u0026#34;ike@ee.princeton.edu\u0026#34;); emails[4] = new Domain(\u0026#34;admin@princeton.edu\u0026#34;); Array.Sort(emails); for (int i = 0; i \u0026lt; emails.Length; i++) { Console.WriteLine(emails[i]); } } } } "},{"id":334,"href":"/2-5-16/","title":"2.5.16","section":"帮助","content":"2.5.16 #  解答 #  官方解答：https://algs4.cs.princeton.edu/25applications/California.java.html\n数据来源：https://introcs.cs.princeton.edu/java/data/california-gov.txt\n建立一个 string 的比较器，按照题目给定的顺序比较。\nprivate class CandidateComparer : IComparer\u0026lt;string\u0026gt; { private static readonly string order = \u0026#34;RWQOJMVAHBSGZXNTCIEKUPDYFL\u0026#34;; public int Compare(string x, string y) { int n = Math.Min(x.Length, y.Length); for (int i = 0; i \u0026lt; n; i++) { int a = order.IndexOf(x[i]); int b = order.IndexOf(y[i]); if (a != b) return a.CompareTo(b); } return x.Length.CompareTo(y.Length); } } 代码 #  using System; using System.IO; using System.Collections.Generic; namespace _2._5._16 { class Program { // 官方解答：https://algs4.cs.princeton.edu/25applications/California.java.html  private class CandidateComparer : IComparer\u0026lt;string\u0026gt; { private static readonly string order = \u0026#34;RWQOJMVAHBSGZXNTCIEKUPDYFL\u0026#34;; public int Compare(string x, string y) { int n = Math.Min(x.Length, y.Length); for (int i = 0; i \u0026lt; n; i++) { int a = order.IndexOf(x[i]); int b = order.IndexOf(y[i]); if (a != b) return a.CompareTo(b); } return x.Length.CompareTo(y.Length); } } static void Main(string[] args) { // 数据来源：https://introcs.cs.princeton.edu/java/data/california-gov.txt  StreamReader sr = new StreamReader(File.OpenRead(\u0026#34;california-gov.txt\u0026#34;)); string[] names = sr.ReadToEnd() .ToUpper() .Split (new char[] { \u0026#39;\\n\u0026#39;, \u0026#39;\\r\u0026#39; }, StringSplitOptions.RemoveEmptyEntries); Array.Sort(names, new CandidateComparer()); for (int i = 0; i \u0026lt; names.Length; i++) { Console.WriteLine(names[i]); } } } } "},{"id":335,"href":"/2-5-17/","title":"2.5.17","section":"帮助","content":"2.5.17 #  解答 #  用一个 Wrapper 类包装准备排序的元素，在排序前同时记录元素的内容和下标。\n随后对 Wrapper 数组排序，相同的元素会被放在一起，检查它们的下标是否是递增的。\n如果不是递增的，则排序算法就是不稳定的；否则排序算法就有可能是稳定的。\n（不稳定的排序算法也可能不改变相同元素的相对位置，比如用选择排序对有序数组排序）\n代码 #  using System; using SortApplication; namespace _2._5._17 { class Program { class Wrapper\u0026lt;T\u0026gt; : IComparable\u0026lt;Wrapper\u0026lt;T\u0026gt;\u0026gt; where T : IComparable\u0026lt;T\u0026gt; { public int Index; public T Key; public Wrapper(int index, T elements) { this.Index = index; this.Key = elements; } public int CompareTo(Wrapper\u0026lt;T\u0026gt; other) { return this.Key.CompareTo(other.Key); } } static void Main(string[] args) { int[] data = new int[] { 7, 7, 4, 8, 8, 5, 1, 7, 7 }; MergeSort merge = new MergeSort(); InsertionSort insertion = new InsertionSort(); ShellSort shell = new ShellSort(); SelectionSort selection = new SelectionSort(); QuickSort quick = new QuickSort(); Console.WriteLine(\u0026#34;Merge Sort: \u0026#34; + CheckStability(data, merge)); Console.WriteLine(\u0026#34;Insertion Sort: \u0026#34; + CheckStability(data, insertion)); Console.WriteLine(\u0026#34;Shell Sort: \u0026#34; + CheckStability(data, shell)); Console.WriteLine(\u0026#34;Selection Sort: \u0026#34; + CheckStability(data, selection)); Console.WriteLine(\u0026#34;Quick Sort: \u0026#34; + CheckStability(data, quick)); } static bool CheckStability\u0026lt;T\u0026gt;(T[] data, BaseSort sort) where T : IComparable\u0026lt;T\u0026gt; { Wrapper\u0026lt;T\u0026gt;[] items = new Wrapper\u0026lt;T\u0026gt;[data.Length]; for (int i = 0; i \u0026lt; data.Length; i++) items[i] = new Wrapper\u0026lt;T\u0026gt;(i, data[i]); sort.Sort(items); int index = 0; while (index \u0026lt; data.Length - 1) { while (index \u0026lt; data.Length - 1 \u0026amp;\u0026amp; items[index].Key.Equals(items[index + 1].Key)) { if (items[index].Index \u0026gt; items[index + 1].Index) return false; index++; } index++; } return true; } } } 另请参阅 #  SortApplication 库\n"},{"id":336,"href":"/2-5-18/","title":"2.5.18","section":"帮助","content":"2.5.18 #  解答 #  用和上题一样的 Wrapper 类进行排序。\n排序之后，相同的元素会被放在一起，形成一个个子数组。\n根据事先保存的原始下标对它们进行排序，即可将不稳定的排序稳定化。\n结果：\n代码 #  using System; using SortApplication; namespace _2._5._18 { class Program { class Wrapper\u0026lt;T\u0026gt; : IComparable\u0026lt;Wrapper\u0026lt;T\u0026gt;\u0026gt; where T : IComparable\u0026lt;T\u0026gt; { public int Index; public T Key; public Wrapper(int index, T elements) { this.Index = index; this.Key = elements; } public int CompareTo(Wrapper\u0026lt;T\u0026gt; other) { return this.Key.CompareTo(other.Key); } } static void Main(string[] args) { int[] data = new int[] { 5, 7, 3, 4, 7, 3, 6, 3, 3 }; QuickSort quick = new QuickSort(); ShellSort shell = new ShellSort(); Console.WriteLine(\u0026#34;Quick Sort\u0026#34;); Stabilize(data, quick); Console.WriteLine(); Console.WriteLine(\u0026#34;Shell Sort\u0026#34;); Stabilize(data, shell); } static void Stabilize\u0026lt;T\u0026gt;(T[] data, BaseSort sort) where T : IComparable\u0026lt;T\u0026gt; { Wrapper\u0026lt;T\u0026gt;[] items = new Wrapper\u0026lt;T\u0026gt;[data.Length]; for (int i = 0; i \u0026lt; data.Length; i++) { items[i] = new Wrapper\u0026lt;T\u0026gt;(i, data[i]); } sort.Sort(items); Console.Write(\u0026#34;Index:\\t\u0026#34;); for (int i = 0; i \u0026lt; items.Length; i++) { Console.Write(items[i].Index + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.Write(\u0026#34;Elem:\\t\u0026#34;); for (int i = 0; i \u0026lt; items.Length; i++) { Console.Write(items[i].Key + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.WriteLine(); int index = 0; while (index \u0026lt; items.Length - 1) { while (index \u0026lt; items.Length - 1 \u0026amp;\u0026amp; items[index].Key.Equals(items[index + 1].Key)) { // 插入排序  for (int j = index + 1; j \u0026gt; 0 \u0026amp;\u0026amp; items[j].Index \u0026lt; items[j - 1].Index; j--) { if (!items[j].Key.Equals(items[j - 1].Key)) break; Wrapper\u0026lt;T\u0026gt; temp = items[j]; items[j] = items[j - 1]; items[j - 1] = temp; } index++; } index++; } Console.Write(\u0026#34;Index:\\t\u0026#34;); for (int i = 0; i \u0026lt; items.Length; i++) { Console.Write(items[i].Index + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.Write(\u0026#34;Elem:\\t\u0026#34;); for (int i = 0; i \u0026lt; items.Length; i++) { Console.Write(items[i].Key + \u0026#34; \u0026#34;); } Console.WriteLine(); } } } 另请参阅 #  SortApplication 库\n"},{"id":337,"href":"/2-5-19/","title":"2.5.19","section":"帮助","content":"2.5.19 #  解答 #  官方解答：\nKendall Tau：https://algs4.cs.princeton.edu/25applications/KendallTau.java.html\nInversion：https://algs4.cs.princeton.edu/22mergesort/Inversions.java.html\n由书中 2.5.3.2 节得，两个数组之间的 Kendall Tau 距离即为两数组之间顺序不同的数对数目。\n如果能够把其中一个数组变成标准排列（即 1,2,3,4... 这样的数组），\n那么此时 Kendall Tau 距离就等于另一个数组中的逆序对数量。\n现在我们来解决如何把一个数组 a 变成标准排列的方法。\n也就是找到函数 $ f(x) ​$，使得 $ f(a[i])=i ​$ ，这样的函数其实就是数组 a 的逆数组。\n如下图所示，逆数组 ainv 即为满足 ainv[a[i]] = i 的数组。\n获得逆数组之后，对另一个数组 b 做同样的变换，令数组 bnew[i] = ainv[b[i]] 。\n即 ainv[a[i]] = i, ainv[b[i]] = bnew[i] 。\n于是问题转化为了 bnew 和标准排列之间的 Kendall Tau 距离，即 bnew 的逆序对数量。\n逆序对数量的求法见 {% post_link 2-2-19 %}。\n代码 #  using System; namespace _2._5._19 { class Program { static void Main(string[] args) { // 官方解答：  // https://algs4.cs.princeton.edu/25applications/KendallTau.java.html  // https://algs4.cs.princeton.edu/22mergesort/Inversions.java.html  int[] testA = { 0, 3, 1, 6, 2, 5, 4 }; int[] testB = { 1, 0, 3, 6, 4, 2, 5 }; Console.WriteLine(Distance(testA, testB)); } public static long Distance(int[] a, int[] b) { if (a.Length != b.Length) throw new ArgumentException(\u0026#34;Array dimensions disagree\u0026#34;); int n = a.Length; int[] ainv = new int[n]; for (int i = 0; i \u0026lt; n; i++) { ainv[a[i]] = i; } int[] bnew = new int[n]; for (int i = 0; i \u0026lt; n; i++) { bnew[i] = ainv[b[i]]; } Inversions inversions = new Inversions(); inversions.Count(bnew); return inversions.Counter; } } } "},{"id":338,"href":"/2-5-20/","title":"2.5.20","section":"帮助","content":"2.5.20 #  解答 #  我们以事件为单位进行处理，每个事件包含任务名，记录时刻和开始/结束标记。\n随后按照时间从小到大排序，遍历事件数组。\n设开始的时候机器空闲，设置计数器，作为当前正在运行的任务数量。\n当遇到开始事件时，计数器加一；遇到结束事件时，计数器减一。\n如果计数器加一之前计数器为 0，说明空闲状态结束，记录并更新空闲时间，当前时间为忙碌开始的时间。\n如果计数器减一之后计数器为 0，说明忙碌状态结束，记录并更新忙碌时间，当前时间为空闲开始的时间。\n测试结果：\n代码 #  using System; namespace _2._5._20 { class Program { /// \u0026lt;summary\u0026gt;  /// 任务变化事件。  /// \u0026lt;/summary\u0026gt;  class JobEvent : IComparable\u0026lt;JobEvent\u0026gt; { public string JobName; public int Time; public bool IsFinished = false; // false = 开始，true = 结束  public int CompareTo(JobEvent other) { return this.Time.CompareTo(other.Time); } } static void Main(string[] args) { // 输入格式： JobName 15:02 17:02  int nowRunning = 0; // 正在运行的程序数量  int maxIdle = 0; int maxBusy = 0; int items = int.Parse(Console.ReadLine()); JobEvent[] jobs = new JobEvent[items * 2]; for (int i = 0; i \u0026lt; jobs.Length; i += 2) { jobs[i] = new JobEvent(); jobs[i + 1] = new JobEvent(); jobs[i].IsFinished = false; // 开始事件  jobs[i + 1].IsFinished = true; // 停止事件  string[] record = Console.ReadLine().Split(new char[] { \u0026#39; \u0026#39;, \u0026#39;:\u0026#39; }, StringSplitOptions.RemoveEmptyEntries); jobs[i].JobName = record[0]; jobs[i + 1].JobName = record[0]; jobs[i].Time = int.Parse(record[1]) * 60 + int.Parse(record[2]); jobs[i + 1].Time = int.Parse(record[3]) * 60 + int.Parse(record[4]); } Array.Sort(jobs); // 事件处理  int idleStart = 0; int busyStart = 0; for (int i = 0; i \u0026lt; jobs.Length; i++) { // 启动事件  if (!jobs[i].IsFinished) { // 空闲状态结束  if (nowRunning == 0) { int idle = jobs[i].Time - idleStart; if (idle \u0026gt; maxIdle) maxIdle = idle; // 开始忙碌  busyStart = jobs[i].Time; } nowRunning++; } else { nowRunning--; // 忙碌状态结束  if (nowRunning == 0) { int busy = jobs[i].Time - busyStart; if (busy \u0026gt; maxBusy) maxBusy = busy; // 开始空闲  idleStart = jobs[i].Time; } } } Console.WriteLine(\u0026#34;Max Idle: \u0026#34; + maxIdle); Console.WriteLine(\u0026#34;Max Busy: \u0026#34; + maxBusy); } } } "},{"id":339,"href":"/2-5-21/","title":"2.5.21","section":"帮助","content":"2.5.21 #  解答 #  与之前的版本号比较十分类似，对数组进行包装，然后按照次序依次比较即可。\nusing System; using System.Text; namespace _2._5._21 { class Vector : IComparable\u0026lt;Vector\u0026gt; { private int[] data; public int Length { get; set; } public Vector(int[] data) { this.data = data; this.Length = data.Length; } public int CompareTo(Vector other) { int maxN = Math.Max(this.Length, other.Length); for (int i = 0; i \u0026lt; maxN; i++) { int comp = this.data[i].CompareTo(other.data[i]); if (comp != 0) return comp; } return this.Length.CompareTo(other.Length); } public override string ToString() { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; this.Length; i++) { if (i != 0) sb.Append(\u0026#39; \u0026#39;); sb.Append(this.data[i]); } return sb.ToString(); } } } "},{"id":340,"href":"/2-5-22/","title":"2.5.22","section":"帮助","content":"2.5.22 #  解答 #  建立最小堆和最大堆，最小堆保存卖家的报价，最大堆保存买家的报价。\n如果最小堆中的最低卖出价低于最大堆的最高买入价，交易达成，交易份额较大的一方需要重新回到堆内。\n测试结果：\n代码 #  using System; using SortApplication; namespace _2._5._22 { class Program { class Ticket : IComparable\u0026lt;Ticket\u0026gt; { public double Price; public int Share; public int CompareTo(Ticket other) { return this.Price.CompareTo(other.Price); } } static void Main(string[] args) { // 输入格式： buy 20.05 100  MaxPQ\u0026lt;Ticket\u0026gt; buyer = new MaxPQ\u0026lt;Ticket\u0026gt;(); MinPQ\u0026lt;Ticket\u0026gt; seller = new MinPQ\u0026lt;Ticket\u0026gt;(); int n = int.Parse(Console.ReadLine()); for (int i = 0; i \u0026lt; n; i++) { Ticket ticket = new Ticket(); string[] item = Console.ReadLine().Split(\u0026#39; \u0026#39;); ticket.Price = double.Parse(item[1]); ticket.Share = int.Parse(item[2]); if (item[0] == \u0026#34;buy\u0026#34;) buyer.Insert(ticket); else seller.Insert(ticket); } while (!buyer.IsEmpty() \u0026amp;\u0026amp; !seller.IsEmpty()) { if (buyer.Max().Price \u0026lt; seller.Min().Price) break; Ticket buy = buyer.DelMax(); Ticket sell = seller.DelMin(); Console.Write(\u0026#34;sell $\u0026#34; + sell.Price + \u0026#34; * \u0026#34; + sell.Share); if (buy.Share \u0026gt; sell.Share) { Console.WriteLine(\u0026#34; -\u0026gt; \u0026#34; + sell.Share + \u0026#34; -\u0026gt; $\u0026#34; + buy.Price + \u0026#34; * \u0026#34; + buy.Share + \u0026#34; buy\u0026#34;); buy.Share -= sell.Share; buyer.Insert(buy); } else if (buy.Share \u0026lt; sell.Share) { sell.Share -= buy.Share; seller.Insert(sell); Console.WriteLine(\u0026#34; -\u0026gt; \u0026#34; + buy.Share + \u0026#34; -\u0026gt; $\u0026#34; + buy.Price + \u0026#34; * \u0026#34; + buy.Share + \u0026#34; buy\u0026#34;); } else { Console.WriteLine(\u0026#34; -\u0026gt; \u0026#34; + sell.Share + \u0026#34; -\u0026gt; $\u0026#34; + buy.Price + \u0026#34; * \u0026#34; + buy.Share + \u0026#34; buy\u0026#34;); } } } } } 另请参阅 #  SortApplication 库\n"},{"id":341,"href":"/2-5-23/","title":"2.5.23","section":"帮助","content":"2.5.23 #  解答 #  这里我们使用 Floyd-Rivest 算法进行优化，大致思想是：\n我们期望第 $k$ 大的元素位于 a[k] 附近，因此优先对 a[k] 附近的区域进行选择。\n每次切分时枢轴都选择 a[k]，先递归对样本区域选择，再对整个数组进行选择。\n运行示意图：\n测试结果：\n代码 #  /// \u0026lt;summary\u0026gt; /// Floyd–Rivest 方法优化，令 a[k] 变成第 k 小的元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;序号\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static T Select\u0026lt;T\u0026gt;(T[] a, int lo, int hi, int k) where T : IComparable\u0026lt;T\u0026gt; { if (k \u0026lt; 0 || k \u0026gt; a.Length) throw new IndexOutOfRangeException(\u0026#34;Select elements out of bounds\u0026#34;); while (hi \u0026gt; lo) { if (hi - lo \u0026gt; 600) { int n = hi - lo + 1; int i = k - lo + 1; int z = (int)Math.Log(n); int s = (int)(Math.Exp(2 * z / 3) / 2); int sd = (int)Math.Sqrt(z * s * (n - s) / n) * Math.Sign(i - n / 2) / 2; int newLo = Math.Max(lo, k - i * s / n + sd); int newHi = Math.Min(hi, k + (n - i) * s / n + sd); Select(a, newLo, newHi, k); } Exch(a, lo, k); int j = Partition(a, lo, hi); if (j \u0026gt; k) hi = j - 1; else if (j \u0026lt; k) lo = j + 1; else return a[j]; } return a[lo]; } 另请参阅 #  Floyd–Rivest algorithm - Wikipedia\n"},{"id":342,"href":"/2-5-24/","title":"2.5.24","section":"帮助","content":"2.5.24 #  解答 #  官方解答：https://algs4.cs.princeton.edu/25applications/StableMinPQ.java.html\n在元素插入的同时记录插入顺序，比较的时候把插入顺序也纳入比较。\n对于值一样的元素，插入顺序在前的的元素比较小。\n交换的时候需要同时交换插入次序。\n代码 #  using System; using System.Collections; using System.Collections.Generic; namespace SortApplication { /// \u0026lt;summary\u0026gt;  /// 稳定的最小堆。（数组实现）  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Key\u0026#34;\u0026gt;最小堆中保存的元素类型。\u0026lt;/typeparam\u0026gt;  public class MinPQStable\u0026lt;Key\u0026gt; : IMinPQ\u0026lt;Key\u0026gt;, IEnumerable\u0026lt;Key\u0026gt; where Key : IComparable\u0026lt;Key\u0026gt; { protected Key[] pq; // 保存元素的数组。  protected int n; // 堆中的元素数量。  private long[] time; // 元素的插入次序。  private long timeStamp = 1; // 元素插入次序计数器。  /// \u0026lt;summary\u0026gt;  /// 默认构造函数。  /// \u0026lt;/summary\u0026gt;  public MinPQStable() : this(1) { } /// \u0026lt;summary\u0026gt;  /// 建立指定容量的最小堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;最小堆的容量。\u0026lt;/param\u0026gt;  public MinPQStable(int capacity) { this.time = new long[capacity + 1]; this.pq = new Key[capacity + 1]; this.n = 0; } /// \u0026lt;summary\u0026gt;  /// 删除并返回最小元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key DelMin() { if (IsEmpty()) throw new ArgumentOutOfRangeException(\u0026#34;Priority Queue Underflow\u0026#34;); Key min = this.pq[1]; Exch(1, this.n--); Sink(1); this.pq[this.n + 1] = default(Key); this.time[this.n + 1] = 0; if ((this.n \u0026gt; 0) \u0026amp;\u0026amp; (this.n == this.pq.Length / 4)) Resize(this.pq.Length / 2); Debug.Assert(IsMinHeap()); return min; } /// \u0026lt;summary\u0026gt;  /// 向堆中插入一个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;需要插入的元素。\u0026lt;/param\u0026gt;  public void Insert(Key v) { if (this.n == this.pq.Length - 1) Resize(2 * this.pq.Length); this.pq[++this.n] = v; this.time[this.n] = ++this.timeStamp; Swim(this.n); //Debug.Assert(IsMinHeap());  } /// \u0026lt;summary\u0026gt;  /// 检查堆是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() =\u0026gt; this.n == 0; /// \u0026lt;summary\u0026gt;  /// 获得堆中最小元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key Min() =\u0026gt; this.pq[1]; /// \u0026lt;summary\u0026gt;  /// 获得堆中元素的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() =\u0026gt; this.n; /// \u0026lt;summary\u0026gt;  /// 获取堆的迭代器，元素以降序排列。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public IEnumerator\u0026lt;Key\u0026gt; GetEnumerator() { MaxPQ\u0026lt;Key\u0026gt; copy = new MaxPQ\u0026lt;Key\u0026gt;(this.n); for (int i = 1; i \u0026lt;= this.n; i++) copy.Insert(this.pq[i]); while (!copy.IsEmpty()) yield return copy.DelMax(); // 下次迭代的时候从这里继续执行。  } /// \u0026lt;summary\u0026gt;  /// 获取堆的迭代器，元素以降序排列。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } /// \u0026lt;summary\u0026gt;  /// 使元素上浮。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要上浮的元素。\u0026lt;/param\u0026gt;  private void Swim(int k) { while (k \u0026gt; 1 \u0026amp;\u0026amp; Greater(k / 2, k)) { Exch(k, k / 2); k /= 2; } } /// \u0026lt;summary\u0026gt;  /// 使元素下沉。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要下沉的元素。\u0026lt;/param\u0026gt;  private void Sink(int k) { while (k * 2 \u0026lt;= this.n) { int j = 2 * k; if (j \u0026lt; this.n \u0026amp;\u0026amp; Greater(j, j + 1)) j++; if (!Greater(k, j)) break; Exch(k, j); k = j; } } /// \u0026lt;summary\u0026gt;  /// 重新调整堆的大小。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;调整后的堆大小。\u0026lt;/param\u0026gt;  private void Resize(int capacity) { Key[] temp = new Key[capacity]; long[] timeTemp = new long[capacity]; for (int i = 1; i \u0026lt;= this.n; i++) { temp[i] = this.pq[i]; timeTemp[i] = this.time[i]; } this.pq = temp; this.time = timeTemp; } /// \u0026lt;summary\u0026gt;  /// 判断堆中某个元素是否大于另一元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;判断是否较大的元素。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;判断是否较小的元素。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private bool Greater(int i, int j) { int cmp = this.pq[i].CompareTo(this.pq[j]); if (cmp == 0) return this.time[i].CompareTo(this.time[j]) \u0026gt; 0; return cmp \u0026gt; 0; } /// \u0026lt;summary\u0026gt;  /// 交换堆中的两个元素。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要交换的第一个元素下标。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;要交换的第二个元素下标。\u0026lt;/param\u0026gt;  protected virtual void Exch(int i, int j) { Key swap = this.pq[i]; this.pq[i] = this.pq[j]; this.pq[j] = swap; long temp = this.time[i]; this.time[i] = this.time[j]; this.time[j] = temp; } /// \u0026lt;summary\u0026gt;  /// 检查当前二叉树是不是一个最小堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private bool IsMinHeap() =\u0026gt; IsMinHeap(1); /// \u0026lt;summary\u0026gt;  /// 确定以 k 为根节点的二叉树是不是一个最小堆。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要检查的二叉树根节点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private bool IsMinHeap(int k) { if (k \u0026gt; this.n) return true; int left = 2 * k; int right = 2 * k + 1; if (left \u0026lt;= this.n \u0026amp;\u0026amp; Greater(k, left)) return false; if (right \u0026lt;= this.n \u0026amp;\u0026amp; Greater(k, right)) return false; return IsMinHeap(left) \u0026amp;\u0026amp; IsMinHeap(right); } } } 另请参阅 #  SortApplication 库\n"},{"id":343,"href":"/2-5-25/","title":"2.5.25","section":"帮助","content":"2.5.25 #  解答 #  官方解答见：https://algs4.cs.princeton.edu/25applications/Point2D.java.html\n这些比较器都以嵌套类的形式在 Point2D 中定义。\n静态比较器直接在类中以静态成员的方式声明。\n非静态比较器则需要提供工厂方法，该方法新建并返回对应的比较器对象。\n代码 #  /// \u0026lt;summary\u0026gt; /// 按照 X 顺序比较。 /// \u0026lt;/summary\u0026gt; private class XOrder : Comparer\u0026lt;Point2D\u0026gt; { public override int Compare(Point2D x, Point2D y) { if (x.X \u0026lt; y.X) return -1; if (x.X \u0026gt; y.X) return 1; return 0; } } /// \u0026lt;summary\u0026gt; /// 按照 Y 顺序比较。 /// \u0026lt;/summary\u0026gt; private class YOrder : Comparer\u0026lt;Point2D\u0026gt; { public override int Compare(Point2D x, Point2D y) { if (x.Y \u0026lt; y.Y) return -1; if (x.Y \u0026gt; y.Y) return 1; return 0; } } /// \u0026lt;summary\u0026gt; /// 按照极径顺序比较。 /// \u0026lt;/summary\u0026gt; private class ROrder : Comparer\u0026lt;Point2D\u0026gt; { public override int Compare(Point2D x, Point2D y) { double delta = (x.X * x.X + x.Y * x.Y) - (y.X * y.X + y.Y * y.Y); if (delta \u0026lt; 0) return -1; if (delta \u0026gt; 0) return 1; return 0; } } /// \u0026lt;summary\u0026gt; /// 按照 atan2 值顺序比较。 /// \u0026lt;/summary\u0026gt; private class Atan2Order : Comparer\u0026lt;Point2D\u0026gt; { private Point2D parent; public Atan2Order() { } public Atan2Order(Point2D parent) { this.parent = parent; } public override int Compare(Point2D x, Point2D y) { double angle1 = this.parent.AngleTo(x); double angle2 = this.parent.AngleTo(y); if (angle1 \u0026lt; angle2) return -1; if (angle1 \u0026gt; angle2) return 1; return 0; } } /// \u0026lt;summary\u0026gt; /// 按照极角顺序比较。 /// \u0026lt;/summary\u0026gt; private class PolorOrder : Comparer\u0026lt;Point2D\u0026gt; { private Point2D parent; public PolorOrder() { } public PolorOrder(Point2D parent) { this.parent = parent; } public override int Compare(Point2D q1, Point2D q2) { double dx1 = q1.X - this.parent.X; double dy1 = q1.Y - this.parent.Y; double dx2 = q2.X - this.parent.X; double dy2 = q2.Y - this.parent.Y; if (dy2 \u0026gt;= 0 \u0026amp;\u0026amp; dy2 \u0026lt; 0) return -1; else if (dy2 \u0026gt;= 0 \u0026amp;\u0026amp; dy1 \u0026lt; 0) return 1; else if (dy1 == 0 \u0026amp;\u0026amp; dy2 == 0) { if (dx1 \u0026gt;= 0 \u0026amp;\u0026amp; dx2 \u0026lt; 0) return -1; else if (dx2 \u0026gt;= 0 \u0026amp;\u0026amp; dx1 \u0026lt; 0) return 1; return 0; } else return -CCW(this.parent, q1, q2); } } /// \u0026lt;summary\u0026gt; /// 按照距离顺序比较。 /// \u0026lt;/summary\u0026gt; private class DistanceToOrder : Comparer\u0026lt;Point2D\u0026gt; { private Point2D parent; public DistanceToOrder() { } public DistanceToOrder(Point2D parent) { this.parent = parent; } public override int Compare(Point2D p, Point2D q) { double dist1 = this.parent.DistanceSquareTo(p); double dist2 = this.parent.DistanceSquareTo(q); if (dist1 \u0026lt; dist2) return -1; else if (dist1 \u0026gt; dist2) return 1; else return 0; } } /// \u0026lt;summary\u0026gt; /// 提供到当前点极角的比较器。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public Comparer\u0026lt;Point2D\u0026gt; Polor_Order() { return new PolorOrder(this); } /// \u0026lt;summary\u0026gt; /// 提供到当前点 Atan2 值的比较器。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public Comparer\u0026lt;Point2D\u0026gt; Atan2_Order() { return new Atan2Order(this); } /// \u0026lt;summary\u0026gt; /// 提供到当前点距离的比较器。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public Comparer\u0026lt;Point2D\u0026gt; DistanceTo_Order() { return new DistanceToOrder(this); } 另请参阅 #  SortApplication 库\n"},{"id":344,"href":"/2-5-26/","title":"2.5.26","section":"帮助","content":"2.5.26 #  解答 #  提示中已经给出了方法，使用上一题编写的比较器进行排序即可。\n效果演示：\n代码 #  绘图部分代码：\nusing System.Collections.Generic; using System.Drawing; using System.Windows.Forms; using SortApplication; namespace _2._5._26 { public partial class Form2 : Form { Graphics panel; List\u0026lt;Point2D\u0026gt; points; Point2D startPoint; double maxX = 0, maxY = 0; public Form2() { InitializeComponent(); } /// \u0026lt;summary\u0026gt;  /// 显示并初始化绘图窗口。  /// \u0026lt;/summary\u0026gt;  public void Init() { Show(); this.panel = CreateGraphics(); this.points = new List\u0026lt;Point2D\u0026gt;(); this.startPoint = null; } /// \u0026lt;summary\u0026gt;  /// 向画板中添加一个点。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;point\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  public void Add(Point2D point) { this.points.Add(point); if (this.startPoint == null) { this.startPoint = point; this.maxX = point.X * 1.1; this.maxY = point.Y * 1.1; } else if (this.startPoint.Y \u0026gt; point.Y) this.startPoint = point; else if (this.startPoint.Y == point.Y \u0026amp;\u0026amp; this.startPoint.X \u0026gt; point.X) this.startPoint = point; if (point.X \u0026gt; this.maxX) this.maxX = point.X * 1.1; if (point.Y \u0026gt; this.maxY) this.maxY = point.Y * 1.1; this.points.Sort(this.startPoint.Polor_Order()); RefreashPoints(); } public void RefreashPoints() { double unitX = this.ClientRectangle.Width / this.maxX; double unitY = this.ClientRectangle.Height / this.maxY; double left = this.ClientRectangle.Left; double bottom = this.ClientRectangle.Bottom; this.panel.Clear(this.BackColor); Pen line = (Pen)Pens.Red.Clone(); line.Width = 6; Point2D before = this.startPoint; foreach (var p in this.points) { this.panel.FillEllipse(Brushes.Black, (float)(left + p.X * unitX - 5.0), (float)(bottom - p.Y * unitY - 5.0), (float)10.0, (float)10.0); this.panel.DrawLine(line, (float)(left + before.X * unitX), (float)(bottom - before.Y * unitY), (float)(left + p.X * unitX), (float)(bottom - p.Y * unitY)); before = p; } this.panel.DrawLine(line, (float)(left + before.X * unitX), (float)(bottom - before.Y * unitY), (float)(left + this.startPoint.X * unitX), (float)(bottom - this.startPoint.Y * unitY)); } } } 另请参阅 #  SortApplication 库\n"},{"id":345,"href":"/2-5-27/","title":"2.5.27","section":"帮助","content":"2.5.27 #  解答 #  类似于索引排序的做法，访问数组都通过一层索引来间接实现。\n首先创建一个数组 index，令 index[i] = i。\n排序时的交换变成 index 数组中元素的交换，\n读取元素时使用 a[index[i]] 而非 a[i] 。\n代码 #  /// \u0026lt;summary\u0026gt; /// 间接排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;keys\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static int[] IndirectSort\u0026lt;T\u0026gt;(T[] keys) where T : IComparable\u0026lt;T\u0026gt; { int n = keys.Length; int[] index = new int[n]; for (int i = 0; i \u0026lt; n; i++) index[i] = i; for (int i = 0; i \u0026lt; n; i++) for (int j = i; j \u0026gt; 0 \u0026amp;\u0026amp; keys[index[j]].CompareTo(keys[index[j - 1]]) \u0026lt; 0; j--) { int temp = index[j]; index[j] = index[j - 1]; index[j - 1] = temp; } return index; } "},{"id":346,"href":"/2-5-28/","title":"2.5.28","section":"帮助","content":"2.5.28 #  解答 #  官方解答：https://algs4.cs.princeton.edu/25applications/FileSorter.java.html\n先获得目录里的所有文件名，然后排序输出即可。\n代码 #  using System; using System.IO; namespace _2._5._28 { class Program { // 官方解答：https://algs4.cs.princeton.edu/25applications/FileSorter.java.html  static void Main(string[] args) { // 输入 ./ 获得当前目录文件。  string directoryName = Console.ReadLine(); if (!Directory.Exists(directoryName)) { Console.WriteLine(directoryName + \u0026#34; doesn\u0026#39;t exist or isn\u0026#39;t a directory\u0026#34;); return; } string[] directoryFiles = Directory.GetFiles(directoryName); Array.Sort(directoryFiles); for (int i = 0; i \u0026lt; directoryFiles.Length; i++) Console.WriteLine(directoryFiles[i]); } } } "},{"id":347,"href":"/2-5-29/","title":"2.5.29","section":"帮助","content":"2.5.29 #  解答 #  首先定义一系列比较器，分别根据文件大小、文件名和最后修改日期比较。\n然后修改 Less 的实现，接受一个比较器数组，使用数组中的比较器依次比较，直到比较结果为两者不相同。\n最后使用插入排序作为稳定排序，传入比较器数组用于 Less 函数。\n代码 #  using System; using System.IO; using System.Collections.Generic; namespace _2._5._29 { class Program { class FileSizeComparer : Comparer\u0026lt;FileInfo\u0026gt; { public override int Compare(FileInfo x, FileInfo y) { return x.Length.CompareTo(y.Length); } } class FileNameComparer : Comparer\u0026lt;FileInfo\u0026gt; { public override int Compare(FileInfo x, FileInfo y) { return x.FullName.CompareTo(y.FullName); } } class FileTimeStampComparer : Comparer\u0026lt;FileInfo\u0026gt; { public override int Compare(FileInfo x, FileInfo y) { return x.LastWriteTime.CompareTo(y.LastWriteTime); } } static void InsertionSort\u0026lt;T\u0026gt;(T[] keys, Comparer\u0026lt;T\u0026gt;[] comparers) { for (int i = 0; i \u0026lt; keys.Length; i++) for (int j = i; j \u0026gt; 0 \u0026amp;\u0026amp; Less(keys, j, j - 1, comparers); j--) { T temp = keys[j]; keys[j] = keys[j - 1]; keys[j - 1] = temp; } } static bool Less\u0026lt;T\u0026gt;(T[] keys, int x, int y, Comparer\u0026lt;T\u0026gt;[] comparables) { int cmp = 0; for (int i = 0; i \u0026lt; comparables.Length \u0026amp;\u0026amp; cmp == 0; i++) { cmp = comparables[i].Compare(keys[x], keys[y]); } return cmp \u0026lt; 0; } static void Main(string[] args) { string[] arguments = Console.ReadLine().Split(\u0026#39; \u0026#39;); string directoryPath = arguments[0]; string[] filenames = Directory.GetFiles(directoryPath); FileInfo[] fileInfos = new FileInfo[filenames.Length]; for (int i = 0; i \u0026lt; filenames.Length; i++) fileInfos[i] = new FileInfo(filenames[i]); List\u0026lt;Comparer\u0026lt;FileInfo\u0026gt;\u0026gt; comparers = new List\u0026lt;Comparer\u0026lt;FileInfo\u0026gt;\u0026gt;(); for (int i = 1; i \u0026lt; arguments.Length; i++) { string command = arguments[i]; switch (command) { case \u0026#34;-t\u0026#34;: comparers.Add(new FileTimeStampComparer()); break; case \u0026#34;-s\u0026#34;: comparers.Add(new FileSizeComparer()); break; case \u0026#34;-n\u0026#34;: comparers.Add(new FileNameComparer()); break; } } InsertionSort(fileInfos, comparers.ToArray()); for (int i = 0; i \u0026lt; fileInfos.Length; i++) { Console.WriteLine(fileInfos[i].Name + \u0026#34;\\t\u0026#34; + fileInfos[i].Length + \u0026#34;\\t\u0026#34; + fileInfos[i].LastWriteTime); } } } } "},{"id":348,"href":"/2-5-30/","title":"2.5.30","section":"帮助","content":"2.5.30 #  解答 #  不妨按照升序排序，$x_{ij}$ 代表第 $i$ 行第 $j$ 列的元素。\n首先保证每列都是有序的。\n对第一行排序，对于第一行的元素 $x_{1i}$ ，排序结果无非两种。\n要么 $x_{1i}$ 不改变，要么和更小的元素进行交换。\n显然，无论哪种情况，第 $i$ 列都是有序的。\n因此对第一行排序之后，第一行有序，每一列都分别有序。\n之后我们对第二行排序，考虑元素 $x_{11}$。\n此时 $x_{11}$ 小于第一列的所有其他元素，也小于第一行的所有其他元素。\n又每一列都分别有序，因此 $x_{11}$ 是整个矩阵的最小值，第二行不存在比它小的元素。\n考虑使用选择排序，我们把第二行的最小值和 $x_{21}$ 交换，第一列仍然有序。\n现在去掉第一列，对剩下的矩阵做一样的操作，可以将第二行依次排序。\n同时保证第二行的元素都小于同列的第一行元素。\n接下来的行都可以依次类推，最终将整个矩阵的所有行排序，定理得证。\n"},{"id":349,"href":"/2-5-31/","title":"2.5.31","section":"帮助","content":"2.5.31 #  解答 #  编写代码进行实验即可，实验结果如下，可以发现十分接近：\n代码 #  using System; namespace _2._5._31 { class Program { /// \u0026lt;summary\u0026gt;  /// 计算数组中重复元素的个数。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;\u0026lt;/typeparam\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要计算重复元素的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  static int Distinct\u0026lt;T\u0026gt;(T[] a) where T : IComparable\u0026lt;T\u0026gt; { if (a.Length == 0) return 0; Array.Sort(a); int distinct = 1; for (int i = 1; i \u0026lt; a.Length; i++) if (a[i].CompareTo(a[i - 1]) != 0) distinct++; return distinct; } static void Main(string[] args) { int T = 10; // 重复次数  int n = 1000; // 数组初始大小  int nMultipleBy10 = 4; // 数组大小 ×10 的次数  int mMultipleBy2 = 3; // 数据范围 ×2 的次数  Random random = new Random(); for (int i = 0; i \u0026lt; nMultipleBy10; i++) { Console.WriteLine(\u0026#34;n=\u0026#34; + n); Console.WriteLine(\u0026#34;\\tm\\temprical\\ttheoretical\u0026#34;); int m = n / 2; for (int j = 0; j \u0026lt; mMultipleBy2; j++) { int distinctSum = 0; for (int k = 0; k \u0026lt; T; k++) { int[] data = new int[n]; for (int l = 0; l \u0026lt; n; l++) data[l] = random.Next(m); distinctSum += Distinct(data); } double empirical = (double)distinctSum / T; double alpha = (double)n / m; double theoretical = m * (1 - Math.Exp(-alpha)); Console.WriteLine(\u0026#34;\\t\u0026#34; + m + \u0026#34;\\t\u0026#34; + empirical + \u0026#34;\\t\u0026#34; + theoretical); m *= 2; } n *= 10; } } } } "},{"id":350,"href":"/2-5-32/","title":"2.5.32","section":"帮助","content":"2.5.32 #  解答 #  （前置知识：提前了解 Dijkstra 算法能够降低理解 A* 算法的难度。）\nA* 算法是 Dijkstra 算法和最佳优先算法的一种结合。\nDijkstra 算法需要遍历所有结点来找到最短路径，唯一的优化条件就是路径长度。\n建立队列 queue ，把所有的结点加入 queue 中；建立数组 d，d[v] 代表起点到点 v 的距离。\n开始时只有起点到起点的距离为 0，其他都为无穷大，然后重复如下步骤：\n从队列中取出已知距离最短的结点 u，检查该结点的所有边。\n如果通过这个点能够以更近的距离到达 v，更新起点到 v 的距离 d[v] = d[u] + distance(u, v)。\n等到队列为空之后数组 d 中就存放着起点到其他所有结点的最短距离。\nDijkstra 算法会计算起点到所有点的最短路径，因此会均匀的遍历所有结点，效率较低。\n很多时候，我们只需要找到起点到某一终点的最短路径即可，为此遍历整个图显然是不必要的。\n通过修改算法，使得比较接近终点的结点优先得到搜索，我们就可能在遍历完全部结点之前获得结果。\n在 Dijkstra 算法中，离起点最近的点会被优先搜索，记结点离起点的距离为 g[n] 。\n现在引入新的条件，用于估计结点和终点的接近程度，记结点离终点的估计距离为 h[n] 。\n令 f[n] = g[n] + h[n]，我们按照 f[n] 对等待搜索的结点进行排序。\n同时令 h[n] 始终小于 g[n] ，保证离起点的距离 g[n] 权重大于离终点的估计距离 h[n] 。\n（h[n]也被称之为容许估计）\n于是在离起点距离接近的条件下，离终点比较近的点会被优先搜索，减少搜索范围。\n接下来就是算法的具体内容，与 Dijkstra 算法不同，A* 算法不一定需要访问所有结点，\n因此 A* 算法需要维护两个集合，openSet 保存等待搜索的结点，closeSet 保存已经搜索过的结点。\n和 Dijkstra 算法类似，一开始 openSet 中只有起点，closeSet 则是空的。\n然后重复执行如下步骤，直到 openSet 为空：\n从 openSet 中取出 f[n] 最小的结点 u ，放入 closeSet。（标记为已访问）\n如果 u 就是终点，算法结束。\n计算结点 u 直接可达的周围结点，放入集合 neighbors。\n遍历 neighbors 中的所有结点 v，做如下判断：\n如果 v 已经存在于 closeSet ，忽略之。（防止走回头路）\n如果经过 u 不能缩短起点到 v 的路径长度 g[v]，忽略之。（和 Dijkstra 算法一样的做法）\n否则将 v 放入 openSet，更新 g[v] = g[u] + distance(u, v) ，计算 f[v] = g[v] + h[v]。（更新结点）\n以上是 A* 算法的核心逻辑，\n为了结合具体问题，我们需要自定义计算 g[n] 和 h[n] 的方法，以及获得某个结点周围结点的方法。\n这里有个问题，openSet 和 closeSet 应该用什么数据结构？\ncloseSet 比较简单，只需要添加和查找即可，哈希表 HashSet 是不二选择。\nopenSet 需要读取并删除最小元素，以及添加和查找元素，用最小堆 MinPQ 会是比较方便的方法。\n书中给出的最小堆 MinPQ 没有实现 Contains 方法，需要自己实现一个，简单顺序查找就够用了。\n同时 MinPQ 的 Greater 比较方法也需要重新实现，需要使用基于 f[n] 进行比较的比较器。\n现在我们考虑 8 字谜题如何用 A* 算法实现。\n棋盘的每一个状态就是一个结点，每走一步就能进入下一个状态，结点可以这么定义：\nclass SearchNode { int[] Board;\t// 棋盘状态  int Steps;\t// 已经使用的步数 } g(start, goal) 直接就是 goal.Steps - start.Steps，h(start, goal) 则根据题意有不同的实现。\n获得周围结点的方法 GetNeighbors(current)，会返回一个数组，其中有从 current 上下左右走获得的棋盘状态。\n运行结果，初始状态为：\n0 1 3 4 2 5 7 9 6 代码 #  A* 算法的泛型实现\nusing System; using System.Collections.Generic; namespace SortApplication { /// \u0026lt;summary\u0026gt;  /// A* 搜索器。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;\u0026lt;/typeparam\u0026gt;  public abstract class AStar\u0026lt;T\u0026gt; where T : IComparable\u0026lt;T\u0026gt; { /// \u0026lt;summary\u0026gt;  /// 相等比较器。  /// \u0026lt;/summary\u0026gt;  private readonly IEqualityComparer\u0026lt;T\u0026gt; equalityComparer; /// \u0026lt;summary\u0026gt;  /// 默认相等比较器。  /// \u0026lt;/summary\u0026gt;  class DefaultEqualityComparer : IEqualityComparer\u0026lt;T\u0026gt; { public bool Equals(T x, T y) { return x.Equals(y); } public int GetHashCode(T obj) { return obj.GetHashCode(); } } /// \u0026lt;summary\u0026gt;  /// 根据 FScore 进行比较的比较器。  /// \u0026lt;/summary\u0026gt;  class FScoreComparer : IComparer\u0026lt;T\u0026gt; { Dictionary\u0026lt;T, int\u0026gt; fScore; public FScoreComparer(Dictionary\u0026lt;T, int\u0026gt; fScore) { this.fScore = fScore; } public int Compare(T x, T y) { if (!this.fScore.ContainsKey(x)) this.fScore[x] = int.MaxValue; if (!this.fScore.ContainsKey(y)) this.fScore[y] = int.MaxValue; return this.fScore[x].CompareTo(this.fScore[y]); } } /// \u0026lt;summary\u0026gt;  /// 新建一个 Astar 寻路器，使用元素默认相等比较器。  /// \u0026lt;/summary\u0026gt;  protected AStar() : this(new DefaultEqualityComparer()) { } /// \u0026lt;summary\u0026gt;  /// 新建一个 AStar 寻路器。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;equalityComparer\u0026#34;\u0026gt;用于确定状态之间相等的比较器。\u0026lt;/param\u0026gt;  protected AStar(IEqualityComparer\u0026lt;T\u0026gt; equalityComparer) { this.equalityComparer = equalityComparer; } /// \u0026lt;summary\u0026gt;  /// 获得最短路径。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;start\u0026#34;\u0026gt;起始状态。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;goal\u0026#34;\u0026gt;终止状态。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public T[] GetPath(T start, T goal) { Dictionary\u0026lt;T, T\u0026gt; comeFrom = new Dictionary\u0026lt;T, T\u0026gt;(this.equalityComparer); Dictionary\u0026lt;T, int\u0026gt; gScore = new Dictionary\u0026lt;T, int\u0026gt;(this.equalityComparer); Dictionary\u0026lt;T, int\u0026gt; fScore = new Dictionary\u0026lt;T, int\u0026gt;(this.equalityComparer); MinPQ\u0026lt;T\u0026gt; openSet = new MinPQ\u0026lt;T\u0026gt;(new FScoreComparer(fScore), this.equalityComparer); HashSet\u0026lt;T\u0026gt; closeSet = new HashSet\u0026lt;T\u0026gt;(this.equalityComparer); openSet.Insert(start); gScore.Add(start, 0); fScore.Add(start, HeuristicDistance(start, goal)); while (!openSet.IsEmpty()) { T current = openSet.DelMin(); if (this.equalityComparer.Equals(current, goal)) return ReconstructPath(comeFrom, current); closeSet.Add(current); T[] neighbors = GetNeighbors(current); foreach (T neighbor in neighbors) { if (closeSet.Contains(neighbor)) continue; int gScoreTentative = gScore[current] + ActualDistance(current, neighbor); // 新状态  if (!openSet.Contains(neighbor)) openSet.Insert(neighbor); else if (gScoreTentative \u0026gt;= gScore[neighbor]) continue; // 记录新状态  comeFrom[neighbor] = current; gScore[neighbor] = gScoreTentative; fScore[neighbor] = gScore[neighbor] + HeuristicDistance(neighbor, goal); } } return null; } /// \u0026lt;summary\u0026gt;  /// 倒回重建最佳路径。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;status\u0026#34;\u0026gt;包含所有状态的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;from\u0026#34;\u0026gt;记载了状态之间顺序的数组。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;current\u0026#34;\u0026gt;当前状态位置。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private T[] ReconstructPath(Dictionary\u0026lt;T, T\u0026gt; comeFrom, T current) { Stack\u0026lt;T\u0026gt; pathReverse = new Stack\u0026lt;T\u0026gt;(); while (comeFrom.ContainsKey(current)) { pathReverse.Push(current); current = comeFrom[current]; } T[] path = new T[pathReverse.Count]; for (int i = 0; i \u0026lt; path.Length; i++) { path[i] = pathReverse.Pop(); } return path; } /// \u0026lt;summary\u0026gt;  /// 计算两个状态之间的估计距离，即 h(n)。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;start\u0026#34;\u0026gt;初始状态。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;goal\u0026#34;\u0026gt;目标状态。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  protected abstract int HeuristicDistance(T start, T goal); /// \u0026lt;summary\u0026gt;  /// 计算两个状态之间的实际距离，即 g(n)。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;start\u0026#34;\u0026gt;初始状态。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;goal\u0026#34;\u0026gt;目标状态。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  protected abstract int ActualDistance(T start, T goal); /// \u0026lt;summary\u0026gt;  /// 获得当前状态的周围状态。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;current\u0026#34;\u0026gt;当前状态。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  protected abstract T[] GetNeighbors(T current); } } 另请参阅 #  A* search algorithm-Wikipedia\nSortApplication 库\n"},{"id":351,"href":"/2-5-33/","title":"2.5.33","section":"帮助","content":"2.5.33 #  解答 #  编写代码实验即可，结果如下：\n代码 #  随机交易生成器 TransactionGenerator\nusing System; using System.Text; using SortApplication; namespace _2._5._33 { /// \u0026lt;summary\u0026gt;  /// 随机交易生成器。  /// \u0026lt;/summary\u0026gt;  class TransactionGenerator { private static Random random = new Random(); /// \u0026lt;summary\u0026gt;  /// 生成 n 条随机交易记录。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;交易记录的数量。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static Transaction[] Generate(int n) { Transaction[] trans = new Transaction[n]; for (int i = 0; i \u0026lt; n; i++) { trans[i] = new Transaction (GenerateName(), GenerateDate(), random.NextDouble() * 1000); } return trans; } /// \u0026lt;summary\u0026gt;  /// 获取随机姓名。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private static string GenerateName() { int nameLength = random.Next(4, 7); StringBuilder sb = new StringBuilder(); sb.Append(random.Next(\u0026#39;A\u0026#39;, \u0026#39;Z\u0026#39; + 1)); for (int i = 1; i \u0026lt; nameLength; i++) sb.Append(random.Next(\u0026#39;a\u0026#39;, \u0026#39;z\u0026#39; + 1)); return sb.ToString(); } /// \u0026lt;summary\u0026gt;  /// 获取随机日期。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private static Date GenerateDate() { int year = random.Next(2017, 2019); int month = random.Next(1, 13); int day; if (month == 2) day = random.Next(1, 29); else if ((month \u0026lt; 8 \u0026amp;\u0026amp; month % 2 == 1) || (month \u0026gt; 7 \u0026amp;\u0026amp; month % 2 == 0)) day = random.Next(1, 32); else day = random.Next(1, 31); Date date = new Date(month, day, year); return date; } } } 另请参阅 #  SortApplication 库\n"},{"id":352,"href":"/3-1-1/","title":"3.1.1","section":"帮助","content":"3.1.1 #  解答 #  官方解答：https://algs4.cs.princeton.edu/31elementary/GPA.java.html\nST.java：https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/ST.java.html\n建立一个符号表，然后把键值放进去，读取计算即可。\n和上一章节用过的方法类似，先定义了一个接口 IST\u0026lt;Key, Value\u0026gt; ，包含书中提到的基本 API。\n然后定义类 ST ，用标准库里面的 Dictionary 实现了 IST 。\n代码 #  using System.Collections; using System.Collections.Generic; namespace SymbolTable { /// \u0026lt;summary\u0026gt; 利用库函数实现的标准符号表。 \u0026lt;/summary\u0026gt;  public class ST\u0026lt;Key, Value\u0026gt; : IST\u0026lt;Key, Value\u0026gt;, IEnumerable\u0026lt;Key\u0026gt; { private Dictionary\u0026lt;Key, Value\u0026gt; st; /// \u0026lt;summary\u0026gt; 新建一个符号表。 \u0026lt;/summary\u0026gt;  public ST() =\u0026gt; this.st = new Dictionary\u0026lt;Key, Value\u0026gt;(); /// \u0026lt;summary\u0026gt; 检查符号表中是否存在与键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 对应的值。 \u0026lt;/summary\u0026gt;  public virtual bool Contains(Key key) =\u0026gt; this.st.ContainsKey(key); /// \u0026lt;summary\u0026gt; 从符号表中删除键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 及对应的值。 \u0026lt;/summary\u0026gt;  public virtual void Delete(Key key) =\u0026gt; this.st.Remove(key); /// \u0026lt;summary\u0026gt; 获取键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 对应的值，不存在时返回 null。 \u0026lt;/summary\u0026gt;  public virtual Value Get(Key key) =\u0026gt; this.st[key]; /// \u0026lt;summary\u0026gt; 获取枚举器。 \u0026lt;/summary\u0026gt;  public IEnumerator\u0026lt;Key\u0026gt; GetEnumerator() =\u0026gt; this.st.Keys.GetEnumerator(); /// \u0026lt;summary\u0026gt; 检查符号表是否为空。 \u0026lt;/summary\u0026gt;  public virtual bool IsEmpty() =\u0026gt; this.st.Count == 0; /// \u0026lt;summary\u0026gt; 获得符号表中所有键的集合。 \u0026lt;/summary\u0026gt;  public virtual IEnumerable\u0026lt;Key\u0026gt; Keys() =\u0026gt; this.st.Keys; /// \u0026lt;summary\u0026gt; 向符号表中插入新的键值对。 \u0026lt;/summary\u0026gt;  public virtual void Put(Key key, Value value) =\u0026gt; this.st.Add(key, value); /// \u0026lt;summary\u0026gt; 获取符号表中键值对的数量。 \u0026lt;/summary\u0026gt;  public virtual int Size() =\u0026gt; this.st.Count; /// \u0026lt;summary\u0026gt; 获取枚举器。 \u0026lt;/summary\u0026gt;  IEnumerator IEnumerable.GetEnumerator() =\u0026gt; GetEnumerator(); } } 另请参阅 #  SymbolTable 库\n"},{"id":353,"href":"/3-1-2/","title":"3.1.2","section":"帮助","content":"3.1.2 #  解答 #  官方解答：https://algs4.cs.princeton.edu/31elementary/ArrayST.java.html\n建立两个数组，分别存放键和值，一一对应。\n添加时直接将新键值对放到数组最后即可。\n删除时将待删除的键值对和位于最后的键值对交换，然后将其置空即可。\n代码 #  using System; using System.Collections.Generic; namespace SymbolTable { /// \u0026lt;summary\u0026gt;  /// 符号表（数组实现）。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Key\u0026#34;\u0026gt;键类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Value\u0026#34;\u0026gt;值类型。\u0026lt;/typeparam\u0026gt;  public class ArrayST\u0026lt;Key, Value\u0026gt; : IST\u0026lt;Key, Value\u0026gt; { private Key[] keys; // 键数组  private Value[] values; // 值数组  private int n = 0; // 键值对数目  /// \u0026lt;summary\u0026gt;  /// 建立基于数组实现的符号表。  /// \u0026lt;/summary\u0026gt;  public ArrayST() : this(8) { } /// \u0026lt;summary\u0026gt;  /// 建立基于数组实现的符号表。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;initCapacity\u0026#34;\u0026gt;初始大小。\u0026lt;/param\u0026gt;  public ArrayST(int initCapacity) { this.keys = new Key[initCapacity]; this.values = new Value[initCapacity]; } /// \u0026lt;summary\u0026gt;  /// 检查键 \u0026lt;typeparamref name=\u0026#34;Key\u0026#34;/\u0026gt; 是否存在。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;需要检查是否存在的键。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool Contains(Key key) =\u0026gt; Get(key).Equals(default(Key)); /// \u0026lt;summary\u0026gt;  /// 删除键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 及对应的值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;需要删除的键。\u0026lt;/param\u0026gt;  public void Delete(Key key) { for (int i = 0; i \u0026lt; this.n; i++) { if (key.Equals(this.keys[i])) { this.keys[i] = this.keys[this.n - 1]; this.values[i] = this.values[this.n - 1]; this.keys[this.n - 1] = default(Key); this.values[this.n - 1] = default(Value); this.n--; if (this.n \u0026gt; 0 \u0026amp;\u0026amp; this.n == this.keys.Length / 4) Resize(this.keys.Length / 2); return; } } } /// \u0026lt;summary\u0026gt;  /// 获取键对应的值，若键不存在则返回 null。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;需要查找的键。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Value Get(Key key) { for (int i = 0; i \u0026lt; this.n; i++) if (this.keys[i].Equals(key)) return this.values[i]; return default(Value); } /// \u0026lt;summary\u0026gt;  /// 检查符号表是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() =\u0026gt; this.n == 0; /// \u0026lt;summary\u0026gt;  /// 获得包含全部键的集合。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public IEnumerable\u0026lt;Key\u0026gt; Keys() { Key[] result = new Key[this.n]; Array.Copy(this.keys, result, this.n); return result; } /// \u0026lt;summary\u0026gt;  /// 向符号表中插入新元素，若键存在将被替换。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;值。\u0026lt;/param\u0026gt;  public void Put(Key key, Value value) { Delete(key); if (this.n \u0026gt;= this.values.Length) Resize(this.n * 2); this.keys[this.n] = key; this.values[this.n] = value; this.n++; } /// \u0026lt;summary\u0026gt;  /// 返回符号表中键值对的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;键值对数量。\u0026lt;/returns\u0026gt;  public int Size() =\u0026gt; this.n; /// \u0026lt;summary\u0026gt;  /// 为符号表重新分配空间。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;新分配的空间大小。\u0026lt;/param\u0026gt;  private void Resize(int capacity) { Key[] tempKey = new Key[capacity]; Value[] tempValue = new Value[capacity]; for (int i = 0; i \u0026lt; this.n; i++) tempKey[i] = this.keys[i]; for (int i = 0; i \u0026lt; this.n; i++) tempValue[i] = this.values[i]; this.keys = tempKey; this.values = tempValue; } } } 另请参阅 #  SymbolTable 库\n"},{"id":354,"href":"/3-1-3/","title":"3.1.3","section":"帮助","content":"3.1.3 #  解答 #  基于无序链表的官方实现：https://algs4.cs.princeton.edu/31elementary/SequentialSearchST.java.html\n有序符号表的 API 见书中表 3.1.4（中文版 P230，英文版 P366）。\n在官方实现的基础上修改 Put 方法，先找到合适位置再插入新的键值对，保证链表有序。\n为方便插入操作，可以使用双向链表作为基础进行实现。\n表中同时维护开头和末尾引用，加快获得最值的速度。\n代码 #  using System; using System.Collections.Generic; namespace SymbolTable { /// \u0026lt;summary\u0026gt;  /// 基于有序链表的有序符号表实现。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Key\u0026#34;\u0026gt;符号表键类型。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;Value\u0026#34;\u0026gt;符号表值类型。\u0026lt;/typeparam\u0026gt;  public class OrderedSequentialSearchST\u0026lt;Key, Value\u0026gt; : IST\u0026lt;Key, Value\u0026gt;, IOrderedST\u0026lt;Key, Value\u0026gt; where Key : IComparable\u0026lt;Key\u0026gt; { /// \u0026lt;summary\u0026gt;  /// 符号表结点。  /// \u0026lt;/summary\u0026gt;  private class Node { public Key Key { get; set; } // 键。  public Value Value { get; set; } // 值。  public Node Next { get; set; } // 后继。  public Node Prev { get; set; } // 前驱。  } private Node first = null; // 起始结点。  private Node tail = null; // 末尾结点。  private int n = 0; // 键值对数量。  /// \u0026lt;summary\u0026gt;  /// 构造基于有序链表的有序符号表。  /// \u0026lt;/summary\u0026gt;  public OrderedSequentialSearchST() { } /// \u0026lt;summary\u0026gt;  /// 大于等于 key 的最小值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key Ceiling(Key key) { Node pointer = this.tail; while (pointer != null \u0026amp;\u0026amp; Greater(key, pointer.Key)) pointer = pointer.Prev; return pointer == null ? default(Key) : pointer.Key; } /// \u0026lt;summary\u0026gt;  /// 键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 在表中是否存在对应的值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool Contains(Key key) =\u0026gt; Floor(key).Equals(key); /// \u0026lt;summary\u0026gt;  /// 从表中删去键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 对应的值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt;  public void Delete(Key key) { Node pointer = this.first; while (pointer != null \u0026amp;\u0026amp; !pointer.Key.Equals(key)) pointer = pointer.Next; if (pointer == null) return; Delete(pointer); } /// \u0026lt;summary\u0026gt;  /// 从链表中删除结点 \u0026lt;paramref name=\u0026#34;node\u0026#34;/\u0026gt;。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;node\u0026#34;\u0026gt;待删除的结点。\u0026lt;/param\u0026gt;  private void Delete(Node node) { Node prev = node.Prev; Node next = node.Next; if (prev == null) this.first = next; else prev.Next = next; if (next == null) this.tail = prev; this.n--; } /// \u0026lt;summary\u0026gt;  /// 删除最大的键。  /// \u0026lt;/summary\u0026gt;  public void DeleteMax() { if (this.n == 0) throw new Exception(\u0026#34;ST Underflow\u0026#34;); Delete(this.tail); } /// \u0026lt;summary\u0026gt;  /// 删除最小的键。  /// \u0026lt;/summary\u0026gt;  public void DeleteMin() { if (this.n == 0) throw new Exception(\u0026#34;ST Underflow\u0026#34;); Delete(this.first); } /// \u0026lt;summary\u0026gt;  /// 小于等于 Key 的最大值。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key Floor(Key key) { Node pointer = this.first; while (pointer != null \u0026amp;\u0026amp; Less(key, pointer.Key)) pointer = pointer.Next; return pointer == null ? default(Key) : pointer.Key; } /// \u0026lt;summary\u0026gt;  /// 获取键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 对应的值，不存在则返回 null。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Value Get(Key key) { Node pointer = this.first; while (pointer != null \u0026amp;\u0026amp; Greater(key, pointer.Key)) pointer = pointer.Next; if (pointer == null) return default(Value); else if (pointer.Key.Equals(key)) return pointer.Value; else return default(Value); } /// \u0026lt;summary\u0026gt;  /// 符号表是否为空。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() =\u0026gt; this.n == 0; /// \u0026lt;summary\u0026gt;  /// 获得符号表中所有键的集合。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public IEnumerable\u0026lt;Key\u0026gt; Keys() =\u0026gt; this.n == 0 ? new List\u0026lt;Key\u0026gt;() : Keys(this.first.Key, this.tail.Key); /// \u0026lt;summary\u0026gt;  /// 获得符号表中 [\u0026lt;paramref name=\u0026#34;lo\u0026#34;/\u0026gt;, \u0026lt;paramref name=\u0026#34;hi\u0026#34;/\u0026gt;] 之间的键。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public IEnumerable\u0026lt;Key\u0026gt; Keys(Key lo, Key hi) { List\u0026lt;Key\u0026gt; list = new List\u0026lt;Key\u0026gt;(); Node pointer = this.first; while (pointer != null \u0026amp;\u0026amp; Less(pointer.Key, lo)) pointer = pointer.Next; while (pointer != null \u0026amp;\u0026amp; Less(pointer.Key, hi)) { list.Add(pointer.Key); pointer = pointer.Next; } if (pointer.Key.Equals(hi)) list.Add(pointer.Key); return list; } /// \u0026lt;summary\u0026gt;  /// 最大的键。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key Max() =\u0026gt; this.tail == null ? default(Key) : this.tail.Key; /// \u0026lt;summary\u0026gt;  /// 最小的键。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key Min() =\u0026gt; this.first == null ? default(Key) : this.first.Key; /// \u0026lt;summary\u0026gt;  /// 向符号表插入键值对，重复值将被替换。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;值。\u0026lt;/param\u0026gt;  public void Put(Key key, Value value) { Delete(key); Node temp = new Node() { Key = key, Value = value, Prev = null, Next = null }; Node left = null, right = this.first; while (right != null \u0026amp;\u0026amp; Less(right.Key, temp.Key)) { left = right; right = right.Next; } Insert(left, right, temp); if (left == null) this.first = temp; if (right == null) this.tail = temp; this.n++; } /// \u0026lt;summary\u0026gt;  /// 小于 Key 的键的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Rank(Key key) { int counter = 0; Node pointer = this.first; while (pointer != null \u0026amp;\u0026amp; Less(pointer.Key, key)) { pointer = pointer.Next; counter++; } return counter; } /// \u0026lt;summary\u0026gt;  /// 获得排名为 k 的键（从 0 开始）。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;排名\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public Key Select(int k) { if (k \u0026gt;= this.n) throw new Exception(\u0026#34;k must less than ST size!\u0026#34;); Node pointer = this.first; for (int i = 0; i \u0026lt; k; i++) pointer = pointer.Next; return pointer.Key; } /// \u0026lt;summary\u0026gt;  /// 获得符号表中键值对的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size() =\u0026gt; this.n; /// \u0026lt;summary\u0026gt;  /// [\u0026lt;paramref name=\u0026#34;lo\u0026#34;/\u0026gt;, \u0026lt;paramref name=\u0026#34;hi\u0026#34;/\u0026gt;] 之间键的数量。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Size(Key lo, Key hi) { int counter = 0; Node pointer = this.first; while (pointer != null \u0026amp;\u0026amp; Less(pointer.Key, lo)) pointer = pointer.Next; while (pointer != null \u0026amp;\u0026amp; Less(pointer.Key, hi)) { pointer = pointer.Next; counter++; } return counter; } /// \u0026lt;summary\u0026gt;  /// 键 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 是否小于 \u0026lt;paramref name=\u0026#34;b\u0026#34;/\u0026gt;。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;检查是否较小的键。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;检查是否较大的键。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private bool Less(Key a, Key b) =\u0026gt; a.CompareTo(b) \u0026lt; 0; /// \u0026lt;summary\u0026gt;  /// 键 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 是否大于 \u0026lt;paramref name=\u0026#34;b\u0026#34;/\u0026gt;。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;检查是否较大的键。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;检查是否较小的键。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private bool Greater(Key a, Key b) =\u0026gt; a.CompareTo(b) \u0026gt; 0; /// \u0026lt;summary\u0026gt;  /// 将结点 \u0026lt;paramref name=\u0026#34;k\u0026#34;/\u0026gt; 插入到 \u0026lt;paramref name=\u0026#34;left\u0026#34;/\u0026gt; 和 \u0026lt;paramref name=\u0026#34;right\u0026#34;/\u0026gt; 之间。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;left\u0026#34;\u0026gt;作为前驱的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;right\u0026#34;\u0026gt;作为后继的结点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;insert\u0026#34;\u0026gt;待插入的结点。\u0026lt;/param\u0026gt;  private void Insert(Node left, Node right, Node k) { k.Prev = left; k.Next = right; if (left != null) left.Next = k; if (right != null) right.Prev = k; } } } 另请参阅 #  SymbolTable 库\n"},{"id":355,"href":"/3-1-4/","title":"3.1.4","section":"帮助","content":"3.1.4 #  解答 #  利用 Time 类型记录时间，用 Event 来记录事件内容。\nTime 类型包含时分秒三个 int 变量，同时实现 IComparable 接口。\nEvent 类型只包含事件的名称，相当于对 string 做了一个封装。\n随后以 Time 为键类型，Event 为值类型，利用上一题编写的有序符号表进行操作。\n代码 #  Time 类\nusing System; using System.Text; namespace _3._1._4 { /// \u0026lt;summary\u0026gt;  /// 时间类。  /// \u0026lt;/summary\u0026gt;  public class Time : IComparable\u0026lt;Time\u0026gt; { public int Hour { get; set; } public int Minute { get; set; } public int Second { get; set; } public Time() : this(0, 0, 0) { } public Time(int hour, int minute, int second) { this.Hour = hour; this.Minute = minute; this.Second = second; } public int CompareTo(Time other) { int result = this.Hour.CompareTo(other.Hour); if (result == 0) result = this.Minute.CompareTo(other.Minute); if (result == 0) result = this.Second.CompareTo(other.Second); return result; } public override bool Equals(object obj) { if (this == obj) return true; return CompareTo((Time)obj) == 0; } public override int GetHashCode() { int result = 1; result += this.Hour; result *= 31; result += this.Minute; result *= 31; result += this.Second; return result; } public override string ToString() { StringBuilder sb = new StringBuilder(); sb.Append(this.Hour \u0026lt; 10 ? \u0026#34;0\u0026#34; + this.Hour : this.Hour.ToString()); sb.Append(\u0026#34;:\u0026#34;); sb.Append(this.Minute \u0026lt; 10 ? \u0026#34;0\u0026#34; + this.Minute : this.Minute.ToString()); sb.Append(\u0026#34;:\u0026#34;); sb.Append(this.Second \u0026lt; 10 ? \u0026#34;0\u0026#34; + this.Second : this.Second.ToString()); return sb.ToString(); } } } Event 类\nnamespace _3._1._4 { public class Event { public string EventMessage { get; set; } public Event() : this(null) { } public Event(string message) { this.EventMessage = message; } public override string ToString() { return this.EventMessage; } } } 另请参阅 #  SymbolTable 库\n"},{"id":356,"href":"/3-1-5/","title":"3.1.5","section":"帮助","content":"3.1.5 #  解答 #  官方解答：https://algs4.cs.princeton.edu/31elementary/SequentialSearchST.java.html\nsize() 方法只需要直接返回当前的 n 值即可。\ndelete() 方法需要遍历链表，找到对应结点并删除。\nkeys() 方法只需要根据当前的 n 新建一个数组，把链表中的键值存入即可。\n代码 #  /// \u0026lt;summary\u0026gt; /// 从表中删去键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 及其对应的值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要删除的键。\u0026lt;/param\u0026gt; public void Delete(Key key) { if (key == null) throw new ArgumentNullException(\u0026#34;key can\u0026#39;t be null\u0026#34;); Node before = null, target = this.first; while (target != null \u0026amp;\u0026amp; !target.Key.Equals(key)) { before = target; target = target.Next; } if (target != null) Delete(before, target); } /// \u0026lt;summary\u0026gt; /// 从链表中删除指定的结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;before\u0026#34;\u0026gt;\u0026lt;paramref name=\u0026#34;target\u0026#34;/\u0026gt; 的前驱。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;target\u0026#34;\u0026gt;准备删除的结点。\u0026lt;/param\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentNullException\u0026#34;\u0026gt;当 \u0026lt;paramref name=\u0026#34;target\u0026#34;/\u0026gt; 为 \u0026lt;c\u0026gt;null\u0026lt;/c\u0026gt; 时抛出此异常。\u0026lt;/exception\u0026gt; private void Delete(Node before, Node target) { if (target == null) throw new ArgumentNullException(\u0026#34;target can\u0026#39;t be null\u0026#34;); if (before == null) this.first = target.Next; else before.Next = target.Next; this.n--; } /// \u0026lt;summary\u0026gt; /// 获得所有的键。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;包含所有键的集合。\u0026lt;/returns\u0026gt; public IEnumerable\u0026lt;Key\u0026gt; Keys() { Key[] keys = new Key[this.n]; Node pointer = this.first; for (int i = 0; i \u0026lt; this.n; i++) { keys[i] = pointer.Key; pointer = pointer.Next; } return keys; } /// \u0026lt;summary\u0026gt; /// 获取符号表中的键值对数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;当前符号表中的键值对数量。\u0026lt;/returns\u0026gt; public int Size() =\u0026gt; this.n; 另请参阅 #  SymbolTable 库\n"},{"id":357,"href":"/3-1-6/","title":"3.1.6","section":"帮助","content":"3.1.6 #  解答 #  FrequencyCounter 的官方实现：https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html\n每个单词都会被放进符号表一次，\n因此 Put 的调用次数就等于单词总数 W +1（注意寻找最大值的时候有一次 Put 调用）\n对于重复的单词，输入时会先调用 Get 获得当前计数之后再 Put 回去。\n寻找最大值时，对于符号表中的每个键值都会调用两次 Get。\n重复的单词数量 = (W - D)。\n因此 Get 方法的调用次数 = (W - D) + 2D\n"},{"id":358,"href":"/3-1-7/","title":"3.1.7","section":"帮助","content":"3.1.7 #  解答 #  在 FrequencyCounter 中添加一个 CountDistinct 方法，计算不重复的键数。\npublic static int CountDistinct\u0026lt;TKey\u0026gt;(TKey[] keys, IST\u0026lt;TKey, int\u0026gt; st) { int distinct = 0; for (int i = 0; i \u0026lt; keys.Length; i++) { if (!st.Contains(keys[i])) st.Put(keys[i], distinct++); } return distinct; } 结果如下：\n另请参阅 #  SymbolTable 库\n"},{"id":359,"href":"/3-1-8/","title":"3.1.8","section":"帮助","content":"3.1.8 #  解答 #  FrequencyCounter 的官方实现：https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html\n《双城记》：https://introcs.cs.princeton.edu/java/data/tale.txt\n官网给出的数据末尾有完整的版权说明，因此使用频率最高的单词变成了版权方的名字 Gutenberg-tm。\n去掉末尾的版权声明之后，获得的单词是：Monseigneur\n另请参阅 #  SymbolTable 库\n"},{"id":360,"href":"/3-1-9/","title":"3.1.9","section":"帮助","content":"3.1.9 #  解答 #  FrequencyCounter 的官方实现：https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html\n《双城记》：https://introcs.cs.princeton.edu/java/data/tale.txt\n对 FrequencyCounter 做修改，在调用 Put 方法之前，将单词记录在字符串变量 lastPut 中。\n在读入单词结束之后输出 lastPut 和 words 变量。\n将末尾的版权信息删除后，得到的结果如下：\n代码 #  public static string MostFrequentlyWord(string filename, int minLength, IST\u0026lt;string, int\u0026gt; st) { int distinct = 0, words = 0; StreamReader sr = new StreamReader(File.OpenRead(filename)); string[] inputs = sr .ReadToEnd() .Split(new char[] { \u0026#39; \u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\n\u0026#39; }, StringSplitOptions.RemoveEmptyEntries); string lastPut = \u0026#34;\u0026#34;; foreach (string s in inputs) { if (s.Length \u0026lt; minLength) continue; words++; if (st.Contains(s)) { lastPut = s; st.Put(s, st.Get(s) + 1); } else { lastPut = s; st.Put(s, 1); distinct++; } } Console.WriteLine(\u0026#34;Last Put: \u0026#34; + lastPut + \u0026#34;\\t words count: \u0026#34; + words); string max = \u0026#34;\u0026#34;; st.Put(max, 0); foreach (string s in st.Keys()) if (st.Get(s) \u0026gt; st.Get(max)) max = s; return max; } 另请参阅 #  SymbolTable 库\n"},{"id":361,"href":"/3-1-10/","title":"3.1.10","section":"帮助","content":"3.1.10 #  解答 #  如图所示：\n插入新的键值对需要遍历整个链表，比较次数等于链表在插入前的键值对数目。\n修改已有的键值对则需要遍历链表直到找到该键值对，比较次数等于该键值对以及它之前所有键值对的数目。\n共比较 0 + 1 + 2 + 3 + 4 + 5 + 6 + 4 + 6 + 7 + 8 + 9 = 55 次。\n"},{"id":362,"href":"/3-1-11/","title":"3.1.11","section":"帮助","content":"3.1.11 #  解答 #  键的轨迹如下图所示：\n键查找使用二分查找优化，插入新的键时不必与每个键都进行比较。\n共进行了 0 + 1 + 2 + 2 + 2 + 3 + 3 + 3 + 3 + 3 + 3 + 4 = 29 次比较。\n"},{"id":363,"href":"/3-1-12/","title":"3.1.12","section":"帮助","content":"3.1.12 #  解答 #  建立类 Item：\npublic class Item\u0026lt;TKey, TValue\u0026gt; : IComparable\u0026lt;Item\u0026lt;TKey, TValue\u0026gt;\u0026gt; where TKey : IComparable\u0026lt;TKey\u0026gt; { public TKey Key { get; set; } public TValue Value { get; set; } public int CompareTo(Item\u0026lt;TKey, TValue\u0026gt; other) { return this.Key.CompareTo(other.Key); } } 之后修改 BinarySearchST，将其中的 TKey[] keys 和 TValue[] values 数组用 Item[] items 数组代替。\n例如 keys[i] 变为 items[i].Key，values[i] 变为 items[i].Value。\n添加一个构造函数，调用之前编写的归并排序实现。\n/// \u0026lt;summary\u0026gt; /// 根据已有的键值对构造一个符号表。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;items\u0026#34;\u0026gt;已有的键值对。\u0026lt;/param\u0026gt; public ItemBinarySearchST(Item\u0026lt;TKey, TValue\u0026gt;[] items) { this.items = new Item\u0026lt;TKey, TValue\u0026gt;[items.Length]; Array.Copy(items, this.items, items.Length); this.n = items.Length; MergeSort merge = new MergeSort(); merge.Sort(this.items); } 另请参阅 #  Merge 库\nSymbolTable 库\n"},{"id":364,"href":"/3-1-13/","title":"3.1.13","section":"帮助","content":"3.1.13 #  解答 #  Get() 调用次数比 Put() 调用次数多了三个数量级，\nBinarySearchST 和 SequentialSearchST 的平均 Put() 开销是一样的，\n因此选择平均 Get() 开销更小的 BinarySearchST。\n"},{"id":365,"href":"/3-1-14/","title":"3.1.14","section":"帮助","content":"3.1.14 #  解答 #  根据上题给出的结论，选择 BinarySearchST。\n由于 BinarySearchST 和 SequentialSearchST 执行 Put() 的开销相同\n因此选择 Get() 开销更低的 BinarySearchST。\n"},{"id":366,"href":"/3-1-15/","title":"3.1.15","section":"帮助","content":"3.1.15 #  解答 #  假设先全部 Put()，再进行查找操作。\n即分别进行 $1$, $10 ^ 3$, $10 ^ 6$ 次插入\n$N = 1$ 时，可以直接得出比例 $0.1 %$。\n$N = 10 ^ 3$ 时，\n插入耗时 $= 1 + 2 + \u0026hellip; + 10 ^ 3 = 500500$，\n查询耗时 $= 10 ^ 6 * \\lg(10 ^ 3) = 9965784$，\n比例为 $4.782 %$。\n$N = 10 ^ 6$ 时\n插入耗时 $= 1 + 2 + \u0026hellip; + 10 ^ 6 = 500000500000$，\n查询耗时 $= 10 ^ 9 * \\lg(10 ^ 6) = 19931568569$，\n比例为 $ 96.17 % ​$。\n"},{"id":367,"href":"/3-1-16/","title":"3.1.16","section":"帮助","content":"3.1.16 #  解答 #  官方实现：https://algs4.cs.princeton.edu/31elementary/BinarySearchST.java.html\n先通过二分查找获得下标，然后后面的元素依次向前移动一位。\npublic void Delete(TKey key) { if (key == null) throw new ArgumentNullException(\u0026#34;argument to Delete() is null\u0026#34;); if (IsEmpty()) return; int i = Rank(key); if (i == this.n \u0026amp;\u0026amp; this.keys[i].CompareTo(key) != 0) return; for (int j = i; j \u0026lt; this.n - 1; j++) { this.keys[j] = this.keys[j + 1]; this.values[j] = this.values[j + 1]; } this.n--; this.keys[this.n] = default(TKey); this.values[this.n] = default(TValue); if (this.n \u0026gt; 0 \u0026amp;\u0026amp; this.n == this.keys.Length / 4) Resize(this.n / 2); } 另请参阅 #  SymbolTable 库\n"},{"id":368,"href":"/3-1-17/","title":"3.1.17","section":"帮助","content":"3.1.17 #  解答 #  官方实现：https://algs4.cs.princeton.edu/31elementary/BinarySearchST.java.html\n先通过二分查找大于等于 key 的键下标 i，\n如果 keys[i] 和 key 相等则直接返回 keys[i]，\n否则返回 keys[i-1]。\npublic TKey Floor(TKey key) { if (key == null) throw new ArgumentNullException(\u0026#34;argument to Floor() is null\u0026#34;); int i = Rank(key); if (i \u0026lt; this.n \u0026amp;\u0026amp; this.keys[i].CompareTo(key) == 0) return this.keys[i]; if (i == 0) return default(TKey); else return this.keys[i - 1]; } 另请参阅 #  SymbolTable 库\n"},{"id":369,"href":"/3-1-18/","title":"3.1.18","section":"帮助","content":"3.1.18 #  解答 #  设 key 为目标键。\n算法初始时 lo = 0, hi = n - 1，数组已排序。\n当找到目标键时，返回的下标 mid 显然是正确的。\n（0\u0026hellip;a[mid - 1] 都小于 a[mid]，同时 a[mid] = key）\n接下来证明：当目标键不存在时，lo 可以代表小于 key 的键的个数。\n由算法内容，当循环退出时，一定有 lo 和 hi 交叉，即 lo \u0026gt; hi。\n考虑最后一次循环，必然执行了 lo = mid + 1 或者 hi = mid - 1。\n即最后一次循环之后 lo = mid + 1 \u0026gt; hi 或 hi = mid - 1 \u0026lt; lo。\n又由于 mid = (lo + hi) / 2，代入有：\n即(lo + hi) / 2 + 1 \u0026gt; hi 或(lo + hi) / 2 - 1 \u0026lt; lo\n(lo - hi) / 2 + 1 \u0026gt; 0 或(hi - lo) / 2 - 1 \u0026lt; 0\n(hi - lo) / 2 \u0026lt; 1\nhi - lo \u0026lt; 2\n由于 hi 和 lo 都是整数，故有 hi -lo \u0026lt;= 1\n由算法的内容可以得出，最后一次循环时，\n下标小于 lo 的元素都小于 key，下标大于 hi 的元素都大于 key\n且下标小于 lo 的元素正好有 lo 个 （0\u0026hellip;lo - 1)。\n当 lo = hi 时，mid = lo\n若 key \u0026gt; lo，则 lo = lo + 1，即 a[lo] 本身也小于 key。\n若 key\u0026lt;lo，lo 不变，即 a[lo] 就是大于 key 的第一个元素。\n当 lo = hi - 1 时，mid = lo\n若 key \u0026gt; lo，则 lo = lo + 1 = hi，变为上一种情况。\n若 key\u0026lt;lo，则 hi = lo - 1，a[lo] 是大于 key 的第一个元素。\n综上，Rank() 是正确的。\n"},{"id":370,"href":"/3-1-19/","title":"3.1.19","section":"帮助","content":"3.1.19 #  解答 #  将频率和当前最大频率相同的单词都放到一个队列里即可。\nstring max = \u0026#34;\u0026#34;; Queue\u0026lt;string\u0026gt; queue = new Queue\u0026lt;string\u0026gt;(); st.Put(max, 0); foreach (string s in st.Keys()) { if (st.Get(s) \u0026gt; st.Get(max)) { max = s; queue.Clear(); queue.Enqueue(s); } else if (st.Get(s) == st.Get(max)) { queue.Enqueue(s); } } 另请参阅 #  SymbolTable 库\n"},{"id":371,"href":"/3-1-20/","title":"3.1.20","section":"帮助","content":"3.1.20 #  解答 #  国内的书中关于命题 B 的证明有错误，新版的证明结论已经改为：\n$$\nC(n)=C(2^k-1) \\le k = \\lg (n+1) \\le \\lg n +1\n$$\n其中 $n=2^k - 1 $ 。\n先证单调性，利用数学归纳法：\n已知对于 $N=0$，满足 $C(0) \\le C(1)$。\n假设对于 $N=n$，满足 $C(n) \\le C(n+1)$。\n根据递归式，有：\n$$\n\\begin{eqnarray*}\n\u0026amp; C(n) \u0026amp; \\le C(\\lfloor n/2 \\rfloor) + 1 \\\n\\\n\u0026amp; C(n+1) \u0026amp; \\le\n\\begin{cases}\nC(\\lfloor n/2 \\rfloor) +1 \u0026amp; \\text{$n$ 是偶数} \\\nC(\\lfloor n/2 \\rfloor + 1) + 1 \u0026amp; \\text{$n$ 是奇数}\n\\end{cases}\\\n\\\n\u0026amp; C(n+2) \u0026amp; \\le C(\\lfloor n/2 \\rfloor + 1) + 1\n\\end{eqnarray*}\n$$\n又 $ C(n) \\le C(n+1) ​$ ，推出 $ C(\\lfloor n/2 \\rfloor) + 1 \\le C(\\lfloor n/2 \\rfloor + 1) + 1 ​$。\n故 $ C(n+1) \\le C(n+2) ​$，由数学归纳法，$ C(n) \\le C(n+1) ​$ 成立。\n已知当 $N = 2^k - 1$ 时，有 $ C(N) \\le k = \\lg(N+1) \\le \\lg N + 1$。\n接下来证明在 $(2^k - 1, 2^{k + 1} -1) $ 范围内上式仍然成立。\n不妨设 $0 \u0026lt; M \u0026lt; 2^k$ ，则有 $2^k - 1 \u0026lt; N + M \u0026lt; 2^{k + 1} -1 $。\n转变为证：$C(N+M) \\le \\lg (N+M) + 1$ 。\n由于 $C(N+M)$ 是一个整数，则 $\\lfloor \\lg(N+M) +1\\rfloor = k+1$。\n即求证： $C(N+M) \\le k+1$。\n由单调性可得 $ C(N+M) \\le C(2^{k+1} - 1) \\le k+1 ​$，得证。\n"},{"id":372,"href":"/3-1-21/","title":"3.1.21","section":"帮助","content":"3.1.21 #  解答 #  BinarySearchST\n包含一个键数组和一个值数组，以及一个 int 变量。\n数组长度变化范围为 N~4N ，故总大小：\n从 2 × (24 + 8N) +4 = 52 + 16N 字节 （100 %），\n到 2 × (24 + 32N) +4 = 52 + 64N 字节（25 %）之间变动。\nSequentialSearchST\n包含 N 个结点以及一个 int 变量\n(16 + 8 + 8 + 8)N + 4 = 4 + 40N 字节\n"},{"id":373,"href":"/3-1-22/","title":"3.1.22","section":"帮助","content":"3.1.22 #  解答 #  对 Get() 做修改，得到 MoveToFrontArrayST。\npublic TValue Get(TKey key) { int i; for (i = 0; i \u0026lt; this.n; i++) if (this.keys[i].Equals(key)) break; if (i == this.n) return default(TValue); TKey toFrontKey = this.keys[i]; TValue toFrontValue = this.values[i]; for (int j = i; j \u0026gt; 0; j--) this.keys[j] = this.keys[j - 1]; for (int j = i; j \u0026gt; 0; j--) this.values[j] = this.values[j - 1]; this.keys[0] = toFrontKey; this.values[0] = toFrontValue; return this.values[0]; } 另请参阅 #  SymbolTable 库\n"},{"id":374,"href":"/3-1-23/","title":"3.1.23","section":"帮助","content":"3.1.23 #  解答 #  这里的右移操作可以理解为 「小数点前移一位」\n即数字依次向右退一位，个位上的数字被舍弃。\n对于十进制，小数点前移一位会使 $n$ 变为 $\\lfloor n / 10 \\rfloor$。\n同样对于二进制就会使 $n$ 变为 $\\lfloor n / 2 \\rfloor$。\n当需要除以 $2$ 的 $k$ 次幂的时候，可以用右移 $k$ 位代替并减少时间开销。\n同理可以用左移 $k$ 位来代替乘以 $2$ 的 $k$ 次幂。\n注：\n这样会降低程序可读性，\n并且某些语言（C / C++）的编译器已经可以自动执行这项优化了。\n请充分考虑你的代码受众之后再决定是否采用这种写法。\n二分查找的最大查找次数 = $ \\lg N + 1$ （见 3.1.20 的证明 {% post_link 3-1-20 %}）\n一个数最多被左移的次数也正好等于 $\\lfloor \\lg N \\rfloor + 1$\n（任意正整数都能被表示为 $2 ^ k + m$ 的形式，即 $k +1$ 位二进制数）\n因此一次二分查找所需的最大比较次数正好是 $N$ 的二进制表示的位数。\n"},{"id":375,"href":"/3-1-24/","title":"3.1.24","section":"帮助","content":"3.1.24 #  解答 #  FrequencyCounter 的官方实现：https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html\n二分查找总是与中间值进行比较，现在改为与数组中第 x% 位置上的元素比较。\n具体而言，$\\frac{k_x-k_{lo}}{k_{hi}-k_{lo}}$ 代表数组在均匀情况下目标值 $k_x$ 的相对位置（一个比率，在数组第 x% 的位置上）。\n那么相对应的下标就等于 $lo+\\frac{k_x-k_{lo}}{k_{hi}-k_{lo}} \\times (hi - lo)$。\n用这个式子代替原来的 $mid=lo + (hi-lo)/2$ 即可。\n不难看出这种方法对于分布相对均匀的数组比较有利，相对于二分查找而言迭代次数会少很多。\n但如果数组分布不够均匀，也可能表现出不如二分查找的性能。\n实验结果也证实了这一判断，就随机数组而言，插值查找相对于二分查找只有 1% 左右的性能提升。\n代码 #  SearchCompare 在书中没有出现，但可以简单的实现为调用 FrequencyCounter 并计时的方法：\npublic static long Time\u0026lt;TKey\u0026gt;(IST\u0026lt;TKey, int\u0026gt; st, TKey[] keys) { Stopwatch sw = new Stopwatch(); sw.Start(); FrequencyCounter.MostFrequentlyKey(st, keys); sw.Stop(); return sw.ElapsedMilliseconds; } 由于这里需要使用数字而非字符串作为键值，需要对官方给出的 FrequencyCounter 做一些修改：\npublic static TKey MostFrequentlyKey\u0026lt;TKey\u0026gt; (IST\u0026lt;TKey, int\u0026gt; st, TKey[] keys) { foreach (TKey s in keys) { if (st.Contains(s)) st.Put(s, st.Get(s) + 1); else st.Put(s, 1); } TKey max = keys[0]; foreach (TKey s in st.Keys()) if (st.Get(s) \u0026gt; st.Get(max)) max = s; return max; } 另请参阅 #  SymbolTable 库\n"},{"id":376,"href":"/3-1-25/","title":"3.1.25","section":"帮助","content":"3.1.25 #  解答 #  英文原文指的是 most recently accessed key，因此指的是最近访问的键。\n实现比较简单，先在类中定义一个新的成员 cache 作为缓存，\n然后修改 Get 方法，在实际查找之前先检查缓存，如果缓存未命中则在查找之后更新它。\n要注意的是缓存指向内容的有效性，在数组中指的是下标是否有效，在链表中指的是结点是否为空。\n利用《双城记》测试的结果：\n代码 #  BinarySearchST #  cache 是一个 int 类型的变量，代表下标。\n在二分查找前先检查缓存，要注意cache超出数组大小的情况。\n如果缓存未命中，则进行二分查找，并在返回结果前更新缓存。\npublic TValue Get(TKey key) { if (key == null) throw new ArgumentNullException(\u0026#34;argument to Get() is null\u0026#34;); if (IsEmpty()) return default(TValue); if (this.cache \u0026lt; this.n \u0026amp;\u0026amp; this.keys[this.cache].Equals(key)) // 缓存检查  return this.values[this.cache]; int rank = Rank(key); if (rank \u0026lt; this.n \u0026amp;\u0026amp; this.keys[rank].Equals(key)) { this.cache = rank; // 更新缓存  return this.values[rank]; } return default(TValue); } SequentialSearchST #  cache 是一个结点类型的变量，代表一个键值对。\n类似的，在顺序查找前先检查缓存，如果缓存未命中则更新缓存。\n要注意的是如果缓存的结点被删除，需要将缓存置为 null。\nGet() 方法\npublic TValue Get(TKey key) { if (key == null) throw new ArgumentNullException(\u0026#34;key can\u0026#39;t be null\u0026#34;); if (this.cache != null \u0026amp;\u0026amp; this.cache.Key.Equals(key)) // 检查缓存  return this.cache.Value; for (Node pointer = this.first; pointer != null; pointer = pointer.Next) { if (pointer.Key.Equals(key)) { this.cache = pointer; // 更新缓存  return pointer.Value; } } return default(TValue); } Delete() 方法\npublic void Delete(TKey key) { if (key == null) throw new ArgumentNullException(\u0026#34;key can\u0026#39;t be null\u0026#34;); Node before = null, target = this.first; while (target != null \u0026amp;\u0026amp; !target.Key.Equals(key)) { before = target; target = target.Next; } if (target == this.cache) // 删除缓存  this.cache = null; if (target != null) Delete(before, target); } 另请参阅 #  SymbolTable 库\n"},{"id":377,"href":"/3-1-26/","title":"3.1.26","section":"帮助","content":"3.1.26 #  解答 #  字典文件：https://introcs.cs.princeton.edu/java/data/web2.txt\n《双城记》：https://introcs.cs.princeton.edu/java/data/tale.txt\n浏览器可能会直接打开 txt，此时右键链接-目标另存为即可下载。\nFrequencyCounter 的官方实现：https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html\n我们利用 BinarySearchST 会自动对键排序的性质来实现字典序排序。\n首先将字典存到一个符号表中，按照 “单词-序号” 的形式保存。\n然后读入文件，如果读入的单词存在于字典中，\n则将其以 “序号-单词” 的形式存到 BinarySearchST 中去。\n读入完毕后，遍历 BinarySearchST 即可获得字典序的单词列表。\n对于按频率排序，我们基于已有的实现修改。\n在每次取得最大值之后，输出并删除最大值，如此循环即可获得频率排序的单词序列。\n也可以将单词-频率序列全部读出来存放到数组之中，然后用第二章的排序算法排序。\n测试结果，取 minLength = 13，只截取了部分。\n代码 #  public static void LookUpDictionary(string filename, string dictionaryFile, int minLength) { // 初始化字典  StreamReader sr = new StreamReader(File.OpenRead(dictionaryFile)); string[] words = sr.ReadToEnd().Split(new char[] { \u0026#39; \u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\n\u0026#39; }, StringSplitOptions.RemoveEmptyEntries); BinarySearchST\u0026lt;string, int\u0026gt; dictionary = new BinarySearchST\u0026lt;string, int\u0026gt;(); for (int i = 0; i \u0026lt; words.Length; i++) { if (words[i].Length \u0026gt; minLength) dictionary.Put(words[i], i); } sr.Close(); // 读入单词  StreamReader srFile = new StreamReader(File.OpenRead(filename)); string[] inputs = srFile.ReadToEnd().Split(new char[] { \u0026#39; \u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\n\u0026#39; }, StringSplitOptions.RemoveEmptyEntries); srFile.Close(); BinarySearchST\u0026lt;int, string\u0026gt; stDictionary = new BinarySearchST\u0026lt;int, string\u0026gt;(); BinarySearchST\u0026lt;string, int\u0026gt; stFrequency = new BinarySearchST\u0026lt;string, int\u0026gt;(); foreach (string s in inputs) { if (stFrequency.Contains(s)) stFrequency.Put(s, stFrequency.Get(s) + 1); else if (dictionary.Contains(s)) { stFrequency.Put(s, 1); stDictionary.Put(dictionary.Get(s), s); } } // 输出字典序  Console.WriteLine(\u0026#34;Alphabet\u0026#34;); foreach (int i in stDictionary.Keys()) { string s = stDictionary.Get(i); Console.WriteLine(s + \u0026#34;\\t\u0026#34; + stFrequency.Get(s)); } // 频率序  Console.WriteLine(\u0026#34;Frequency\u0026#34;); int n = stFrequency.Size(); for (int i = 0; i \u0026lt; n; i++) { string max = \u0026#34;\u0026#34;; stFrequency.Put(max, 0); foreach (string s in stFrequency.Keys()) if (stFrequency.Get(s) \u0026gt; stFrequency.Get(max)) max = s; Console.WriteLine(max + \u0026#34;\\t\u0026#34; + stFrequency.Get(max)); stFrequency.Delete(max); } } 另请参阅 #  SymbolTable 库\n"},{"id":378,"href":"/3-1-27/","title":"3.1.27","section":"帮助","content":"3.1.27 #  解答 #  事实上就是说，先构造一个包含 N 个不重复键的符号表，然后进行 S 次查找。\n给出 S 的增长数量级，使得构造符号表的成本和查找的成本相同。\n这里假设一次数组交换和一次比较的成本是相同的。\n先考虑构造符号表的成本，一次 Put() 需要调用一次 Rank() 和一次插入操作。\n2.1 节插入排序的命题 B 给出了每次插入平均需要移动一半的数组元素的结论。\n于是构造符号表所需的成本约为：$n\\lg n + \\frac{1}{2}\\sum_{k=1}^{n} k=n\\lg n + \\frac{n(n-1)}{4} $ 。\n这里查找的成本是这么计算的：$\\lg0+\\lg1+\\cdots+\\lg n \u0026lt; n\\lg n$\n查找所需的成本比较简单，一次二分查找的比较次数约为 $\\lg n$，总成本就是 $S\\lg n$ 。\n令两边相等，解方程即可得到 $S=n+\\frac{n(n-1)}{4\\lg n}$ 。\n如果用大 O 记法，也可以记为 $O(n^2 / \\lg n)$，如果要选择一个比较常用的上界则可以选择 $O(n^2)$。\n实验结果，两边的成本是很接近的：\n另请参阅 #  SymbolTable 库\n"},{"id":379,"href":"/3-1-28/","title":"3.1.28","section":"帮助","content":"3.1.28 #  解答 #  将重新分配数组空间的代码提前，然后添加判断语句即可。\nBinarySearchSTOrderedInsertion：\n/* 省略 */ if (this.n == this.keys.Length) Resize(this.n * 2); // 如果插入的键比所有键都大则直接插入末尾。 if (this.n == 0 || this.keys[this.n - 1].CompareTo(key) \u0026lt; 0) { this.keys[this.n] = key; this.values[this.n] = value; this.n++; return; } int i = Rank(key); /* 省略 */ 另请参阅 #  SymbolTable 库\n"},{"id":380,"href":"/3-1-29/","title":"3.1.29","section":"帮助","content":"3.1.29 #  解答 #  官方实现：https://algs4.cs.princeton.edu/31elementary/TestBinarySearchST.java.html\n官方实现中有几处错误，需要做一些修改。\n/* 省略 */ Console.WriteLine(\u0026#34;Testing Select()\u0026#34;); Console.WriteLine(\u0026#34;-----------------------------------\u0026#34;); for (int i = 0; i \u0026lt; st.Size(); i++) // 循环条件不能有 \u0026#39;=\u0026#39;  Console.WriteLine(i + \u0026#34; \u0026#34; + st.Select(i)); Console.WriteLine(); /* 省略 */ while (!st.IsEmpty()) st.Delete(st.Select(st.Size() / 2)); Console.WriteLine(\u0026#34;After deleting the remaining keys\u0026#34;); Console.WriteLine(\u0026#34;-----------------------------------\u0026#34;); // 异常处理 try { foreach (string s in st.Keys()) Console.WriteLine(s + \u0026#34; \u0026#34; + st.Get(s)); } catch (Exception ex) { Console.WriteLine(\u0026#34;Exception: \u0026#34; + ex.Message); } Console.WriteLine(); /* 省略 */ 结果如下：\nsize = 10 min = A max = X Testing Keys() ----------------------------------- A 8 C 4 E 12 H 5 L 11 M 9 P 10 R 3 S 0 X 7 Testing Select() ----------------------------------- 0 A 1 C 2 E 3 H 4 L 5 M 6 P 7 R 8 S 9 X key Rank Floor Ceil ----------------------------------- A 0 A A B 1 A C C 1 C C D 2 C E E 2 E E F 3 E H G 3 E H H 3 H H I 4 H L J 4 H L K 4 H L L 4 L L M 5 M M N 6 M P O 6 M P P 6 P P Q 7 P R R 7 R R S 8 S S T 9 S X U 9 S X V 9 S X W 9 S X X 9 X X Y 10 X Z 10 X After deleting the smallest 3 keys ----------------------------------- H 5 L 11 M 9 P 10 R 3 S 0 X 7 After deleting the remaining keys ----------------------------------- Exception: called Min() with empty table After adding back N keys ----------------------------------- A 8 C 4 E 12 H 5 L 11 M 9 P 10 R 3 S 0 X 7 另请参阅 #  SymbolTable 库\n"},{"id":381,"href":"/3-1-30/","title":"3.1.30","section":"帮助","content":"3.1.30 #  解答 #  官方实现：https://algs4.cs.princeton.edu/31elementary/BinarySearchST.java.html。\n首先在 BinarySearchST  中添加如下方法。\n/// \u0026lt;summary\u0026gt; 检查符号表结构是否有效。 \u0026lt;/summary\u0026gt; private bool Check() =\u0026gt; IsSorted() \u0026amp;\u0026amp; RankCheck(); /// \u0026lt;summary\u0026gt; 检查 \u0026lt;see cref=\u0026#34;keys\u0026#34;/\u0026gt; 数组是否有序。 \u0026lt;/summary\u0026gt; private bool IsSorted() { for (int i = 1; i \u0026lt; Size(); i++) if (this.keys[i].CompareTo(this.keys[i - 1]) \u0026lt; 0) return false; return true; } /// \u0026lt;summary\u0026gt; 检查 Rank(Select(i)) = i 是否成立。 \u0026lt;/summary\u0026gt; private bool RankCheck() { for (int i = 0; i \u0026lt; Size(); i++) if (i != Rank(Select(i))) return false; for (int i = 0; i \u0026lt; Size(); i++) if (keys[i].CompareTo(Select(Rank(this.keys[i]))) != 0) return false; return true; } 然后在 Put() 和 Delete() 方法的末尾添加：Debug.Assert(Check()); 即可。\n另请参阅 #  SymbolTable 库\n"},{"id":382,"href":"/3-1-31/","title":"3.1.31","section":"帮助","content":"3.1.31 #  解答 #  性能测试方法构造如下：\n先编写一个随机字符串方法，生成一个长度大于 50 的字符串（作为未命中访问）。\n然后随机生成符合要求的字符串数组，将它们全部放入符号表中。\n然后遍历 10 次生成的字符串数组，对于数组中的每个元素都进行一次命中查询。\n同时在每次命中查询的同时都进行一次未命中查询即可。\n测试结果：\n代码 #  按照要求编写代码，在 SearchCompare 类里添加一个 Random random 成员，并添加如下方法：\n随机字符串发生器：\npublic static string GetRandomString(int minLength, int maxLength) { int length = random.Next(minLength, maxLength); StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; length; i++) { double choice = random.NextDouble(); if (choice \u0026lt; 0.333) sb.Append((char)random.Next(\u0026#39;A\u0026#39;, \u0026#39;Z\u0026#39;)); else if (choice \u0026lt; 0.666) sb.Append((char)random.Next(\u0026#39;a\u0026#39;, \u0026#39;z\u0026#39;)); else sb.Append((char)random.Next(\u0026#39;0\u0026#39;, \u0026#39;9\u0026#39;)); } return sb.ToString(); } 生成随机字符串数组：\npublic static string[] GetRandomArrayString(int n, int minLength, int maxLength) { string[] result = new string[n]; for (int i = 0; i \u0026lt; n; i++) { result[i] = GetRandomString(minLength, maxLength); } return result; } 测试方法：\npublic static long Performance(IST\u0026lt;string, int\u0026gt; st, int n, int averageHit) { string[] keys = GetRandomArrayString(n, 2, 50); string keyNotExist = GetRandomString(51, 52); Stopwatch sw = Stopwatch.StartNew(); // 构建  for (int i = 0; i \u0026lt; n; i++) st.Put(keys[i], i); // 查询  for (int i = 0; i \u0026lt; averageHit; i++) { for (int j = 0; j \u0026lt; n; j++) { st.Get(keys[j]); st.Get(keyNotExist); } } sw.Stop(); return sw.ElapsedMilliseconds; } 另请参阅 #  SymbolTable 库\n"},{"id":383,"href":"/3-1-32/","title":"3.1.32","section":"帮助","content":"3.1.32 #  解答 #  编码实现即可，实验结果如下：\n对于保持键有序的 BinarySearchST 来说，逆序输入是最坏情况，顺序输入则是最好情况。\n而对于键无序的 SequentialSearchST 来说，输入顺序对于性能的影响不大。\n只有一种键的时候，每次 Put 都只需要比较一次，值一直在被替换。\n只有两种值对性能的影响不大，性能主要由输入的键决定。\n代码 #  测试方法，IST 代表一个符号表。\nstatic void Test(IST\u0026lt;string, int\u0026gt;[] sts, int n) { Stopwatch sw = new Stopwatch(); string[] data = SearchCompare.GetRandomArrayString(n, 3, 10); string item1 = \u0026#34;item1\u0026#34;; Array.Sort(data); // 有序的数组  Console.Write(\u0026#34;Sorted Array: \u0026#34;); sw.Start(); for (int i = 0; i \u0026lt; n; i++) { sts[0].Put(data[i], i); } sw.Stop(); Console.WriteLine(sw.ElapsedMilliseconds); // 逆序的数组  Console.Write(\u0026#34;Sorted Array Reversed: \u0026#34;); sw.Restart(); for (int i = n - 1; i \u0026gt;= 0; i--) { sts[1].Put(data[i], i); } sw.Stop(); Console.WriteLine(sw.ElapsedMilliseconds); // 只有一种键  Console.Write(\u0026#34;One Distinct Key: \u0026#34;); sw.Restart(); for (int i = 0; i \u0026lt; n; i++) { sts[2].Put(item1, i); } sw.Stop(); Console.WriteLine(sw.ElapsedMilliseconds); // 只有两种值  Console.Write(\u0026#34;Two Distinct Values: \u0026#34;); sw.Restart(); for (int i = 0; i \u0026lt; n; i++) { sts[3].Put(data[i], i % 2); } sw.Stop(); Console.WriteLine(sw.ElapsedMilliseconds); } 另请参阅 #  SymbolTable 库\n"},{"id":384,"href":"/3-1-33/","title":"3.1.33","section":"帮助","content":"3.1.33 #  解答 #  概率分布的实现方式：\n假设存有键的数组为 keys，对 keys 排序。\n然后再建立一个长度为 10N 的数组 querys，\n前 1/2 置为 keys[0]，1/2 到 3/4 置为 keys[1]，以此类推，直到数组填满。\n然后遍历 query 数组，对符号表进行 Get() 操作。\n实验结果如下：\n代码 #  static void Main(string[] args) { int n = 1000; int multiplyBy10 = 3; for (int i = 0; i \u0026lt; multiplyBy10; i++) { Console.WriteLine(\u0026#34;n=\u0026#34; + n); // 构造表  BinarySearchST\u0026lt;string, int\u0026gt; bst = new BinarySearchST\u0026lt;string, int\u0026gt;(n); MoveToFrontArrayST\u0026lt;string, int\u0026gt; mst = new MoveToFrontArrayST\u0026lt;string, int\u0026gt;(n); string[] keys = SearchCompare.GetRandomArrayString(n, 3, 20); for (int j = 0; j \u0026lt; n; j++) { bst.Put(keys[j], j); mst.Put(keys[j], j); } // 构造查询  Array.Sort(keys); string[] querys = new string[10 * n]; int queryIndex = 0, keyIndex = 0; while (queryIndex \u0026lt; querys.Length) { int searchTimes = (int)Math.Ceiling((Math.Pow(0.5, keyIndex + 1) * querys.Length)); for (int j = 0; j \u0026lt; searchTimes \u0026amp;\u0026amp; queryIndex \u0026lt; querys.Length; j++) { querys[queryIndex++] = keys[keyIndex]; } keyIndex++; } Shuffle(querys); Stopwatch sw = new Stopwatch(); // 测试 MoveToFrontArrayST  sw.Start(); for (int j = 0; j \u0026lt; querys.Length; j++) { mst.Get(querys[j]); } sw.Stop(); Console.WriteLine(\u0026#34;MoveToFrontArrayST: \u0026#34; + sw.ElapsedMilliseconds); // 测试 BinarySearchST  sw.Restart(); for (int j = 0; j \u0026lt; querys.Length; j++) { bst.Get(querys[j]); } sw.Stop(); Console.WriteLine(\u0026#34;BinarySearchST: \u0026#34; + sw.ElapsedMilliseconds); n *= 10; } } static void Shuffle\u0026lt;T\u0026gt;(T[] data) { for (int i = 0; i \u0026lt; data.Length; i++) { int r = i + random.Next(data.Length - i); T temp = data[r]; data[r] = data[i]; data[i] = temp; } } 另请参阅 #  SymbolTable 库\n"},{"id":385,"href":"/3-1-34/","title":"3.1.34","section":"帮助","content":"3.1.34 #  解答 #  在上一题的基础上进行修改即可，链接：{% post_link 3.1.33 %}。\n调和级数 $H_n = 1+\\frac{1}{2}+\\frac{1}{3} + \\cdots+\\frac{1}{n}$ 。\n查询数组变为前 1/2 为 key[0]，随后的 1/3 为 key[1]，以此类推。\n和上一题中的序列进行比较即可，注意删除最后的打乱步骤。\n实验结果如下：\n代码 #  首先建立一个数组计算调和级数，就像这样：\n// 调和级数 double[] harmonicNumber = new double[1000 * (int)Math.Pow(10, 4)]; harmonicNumber[0] = 1; for (int i = 1; i \u0026lt; harmonicNumber.Length; i++) { harmonicNumber[i] = harmonicNumber[i - 1] + 1 / (i + 1); } 然后修改构造查询的代码：\n// 构造查询 Array.Sort(keys); string[] queryZipf = new string[10 * n]; int queryIndex = 0, keyIndex = 0; while (queryIndex \u0026lt; queryZipf.Length) { int searchTimes = (int)Math.Ceiling(queryZipf.Length / (harmonicNumber[keyIndex + 1] * (i + 1))); for (int j = 0; j \u0026lt; searchTimes \u0026amp;\u0026amp; queryIndex \u0026lt; queryZipf.Length; j++) { queryZipf[queryIndex++] = keys[keyIndex]; } keyIndex++; } 另请参阅 #  SymbolTable 库\n"},{"id":386,"href":"/3-1-35/","title":"3.1.35","section":"帮助","content":"3.1.35 #  解答 #  实验结果：\n由于包含重复单词，因此结果会比 4 略低一些。\n需要对 FrequencyCounter 做一些修改，令其只取前 n 个单词。\n代码 #  static void Main(string[] args) { int n = 8000; int multiplyBy2 = 5; int repeatTimes = 5; double lastTime = -1; Console.WriteLine(\u0026#34;n\\ttime\\tratio\u0026#34;); for (int i = 0; i \u0026lt; multiplyBy2; i++) { Console.Write(n + \u0026#34;\\t\u0026#34;); long timeSum = 0; for (int j = 0; j \u0026lt; repeatTimes; j++) { SequentialSearchST\u0026lt;string, int\u0026gt; st = new SequentialSearchST\u0026lt;string, int\u0026gt;(); Stopwatch sw = Stopwatch.StartNew(); FrequencyCounter.MostFrequentlyWord(\u0026#34;tale.txt\u0026#34;, n, 0, st); sw.Stop(); timeSum += sw.ElapsedMilliseconds; } timeSum /= repeatTimes; Console.Write(timeSum + \u0026#34;\\t\u0026#34;); if (lastTime \u0026lt; 0) Console.WriteLine(\u0026#34;--\u0026#34;); else Console.WriteLine(timeSum / lastTime); lastTime = timeSum; n *= 2; } } 另请参阅 #  SymbolTable 库\n"},{"id":387,"href":"/3-1-36/","title":"3.1.36","section":"帮助","content":"3.1.36 #  解答 #  实验结果如下，增长级为 O(N) ，但速度很快。\n其实只要列出《双城记》不同长度的单词数目，原因就一目了然了。\n大部分单词都集中在中间长度，因此大部分访问也集中在数组中部。\n二分查找在访问数组中部的元素时速度很快，因此结果好于预期。\n代码 #  static void Main(string[] args) { int n = 8000; int multiplyBy2 = 5; int repeatTimes = 5; double lastTime = -1; Console.WriteLine(\u0026#34;n\\ttime\\tratio\u0026#34;); for (int i = 0; i \u0026lt; multiplyBy2; i++) { Console.Write(n + \u0026#34;\\t\u0026#34;); long timeSum = 0; for (int j = 0; j \u0026lt; repeatTimes; j++) { BinarySearchST\u0026lt;string, int\u0026gt; st = new BinarySearchST\u0026lt;string, int\u0026gt;(); Stopwatch sw = Stopwatch.StartNew(); FrequencyCounter.MostFrequentlyWord(\u0026#34;tale.txt\u0026#34;, n, 0, st); sw.Stop(); timeSum += sw.ElapsedMilliseconds; } timeSum /= repeatTimes; Console.Write(timeSum + \u0026#34;\\t\u0026#34;); if (lastTime \u0026lt; 0) Console.WriteLine(\u0026#34;--\u0026#34;); else Console.WriteLine(timeSum / lastTime); lastTime = timeSum; n *= 2; } } 另请参阅 #  SymbolTable 库\n"},{"id":388,"href":"/3-1-37/","title":"3.1.37","section":"帮助","content":"3.1.37 #  解答 #  实验结果如下：\nM=10 的时候随机的数字集中在 1024 到 2048 之间，重复值较多，因此 Put 耗时较少。\n随着重复值的减少 Put 的耗时会大幅度提高，和实验结果显示的一样。\nM=20 的时候数字在 1048576~2097152 之间随机，基本上没有重复值了。\nM=30 的时候和 M=20 的情况类似，都是重复值几乎没有的情况。\n随机数可以通过如下的方式产生：\nresult[i] = min + (long)(random.NextDouble() * (max - min)); 代码 #  这里构造了 BinarySearchSTAnalysis 类，在类中声明了两个 Stopwatch 对象，\n一个在 Put 方法的开始和结束部分进行计时，\n另一个在 Get 方法的开始和结束部分进行计时。\nstatic void Main(string[] args) { int n = 1000000; int m = 10; int addBy10 = 3; for (int i = 0; i \u0026lt; addBy10; i++) { BinarySearchSTAnalysis\u0026lt;long, int\u0026gt; bst = new BinarySearchSTAnalysis\u0026lt;long, int\u0026gt;(n); long[] data = SearchCompare.GetRandomArrayLong(n, (long)Math.Pow(2, m), (long)Math.Pow(2, m + 1)); FrequencyCounter.MostFrequentlyKey(bst, data); Console.WriteLine(\u0026#34;m=\u0026#34; + m + \u0026#34;\\t\u0026#34; + bst.GetTimer.ElapsedMilliseconds + \u0026#34;\\t\u0026#34; + bst.PutTimer.ElapsedMilliseconds + \u0026#34;\\t\u0026#34; + bst.PutTimer.ElapsedMilliseconds / (double)bst.GetTimer.ElapsedMilliseconds); m += 10; } BinarySearchSTAnalysis\u0026lt;string, int\u0026gt; st = new BinarySearchSTAnalysis\u0026lt;string, int\u0026gt;(); FrequencyCounter.MostFrequentlyWord(\u0026#34;tale.txt\u0026#34;, 0, st); Console.WriteLine(\u0026#34;tales\\t\u0026#34; + st.GetTimer.ElapsedMilliseconds + \u0026#34;\\t\u0026#34; + st.PutTimer.ElapsedMilliseconds + \u0026#34;\\t\u0026#34; + st.PutTimer.ElapsedMilliseconds / (double)st.GetTimer.ElapsedMilliseconds); Console.ReadLine(); } 另请参阅 #  SymbolTable 库\n"},{"id":389,"href":"/3-1-38/","title":"3.1.38","section":"帮助","content":"3.1.38 #  解答 #  实验结果如下：\nBinarySearchST\nSequentialSearchST\n对于 BinarySearchST ，每次比较之后以及移动元素时令 Cost 增加。\n对于 SequentialSearchST，统计每次的查找次数即可。\n然后绘制成散点图即可。\n代码 #  有关绘图的函数，传入的参数为第 i 次 Put() 的开销。\npublic void Draw(int[] data) { Graphics panel = this.CreateGraphics(); float unitX = (float)this.ClientRectangle.Width / data.Length; float unitY = (float)this.ClientRectangle.Height / data.Max(); int accumulation = 0; for (int i = 0; i \u0026lt; data.Length; i++) { // Gray  panel.FillEllipse(Brushes.Gray, (i + 1) * unitX, this.ClientRectangle.Bottom - data[i] * unitY, 2, 2); // Red  panel.FillEllipse(Brushes.Red, (i + 1) * unitX, this.ClientRectangle.Bottom - accumulation / (i + 1) * unitY, 2, 2); accumulation += data[i]; } } 另请参阅 #  SymbolTable 库\n"},{"id":390,"href":"/3-1-39/","title":"3.1.39","section":"帮助","content":"3.1.39 #  解答 #  实验结果如下：\nBinarySearchST\nSequentialSearchST\n图像分为两段，分别代表不断向符号表中加入单词和寻找频率最大的单词两个部分。\n第一段两个图像的形状类似（注意它们的 y 轴比例不同）。\n第二段中 BinarySearchST 的表现要比 SequentialSearchST 稳定的多。\n代码 #  绘图部分代码：\npublic void Draw(int[] x, long[] y) { Graphics panel = this.CreateGraphics(); float unitX = (float)this.ClientRectangle.Width / x.Max(); float unitY = (float)this.ClientRectangle.Height / y.Max(); for (int i = 0; i \u0026lt; x.Length; i++) { panel.FillEllipse( Brushes.Black, x[i] * unitX, this.ClientRectangle.Height - y[i] * unitY, 2, 2); } } 另请参阅 #  SymbolTable 库\n"},{"id":391,"href":"/3-1-40/","title":"3.1.40","section":"帮助","content":"3.1.40 #  解答 #  顺序查找平均需要进行 $N/2$ 次比较，二分查找则是 $\\lg N$ 次。\n列出方程可以解出 N 的大小\n$$\n\\begin {eqnarray*}\n1000 \\log_2 N \u0026amp;=\u0026amp; N / 2 \\\n\\log_2 N \u0026amp;=\u0026amp; N / 2000\\\n\\frac{\\ln N}{\\ln 2} \u0026amp;=\u0026amp; N/2000 \\\nN \u0026amp;=\u0026amp; e^{\\frac{\\ln 2}{2000}N}\\\n1 \u0026amp;=\u0026amp; Ne^{-\\frac{\\ln 2}{2000}N}\\\nN_1 = e^{-W(-\\frac{\\ln 2}{2000})}=1 \u0026amp;\\ \u0026amp; N_2= e^{-W_{-1}(-\\frac{\\ln 2}{2000})}=29718\\ \\\n\\end {eqnarray*}\n$$\n这个方程是一个超越方程，最后的结果中出现了朗伯 W 函数。\n同理可以求得 10000 倍的 N=369939。\n实验结果如下：\n由于存在缓存优化，每次比较的耗时并不相同。\n因此实际耗时并未达到预期，但比较次数是符合预期的。\n另请参阅 #  朗伯 W 函数-维基百科\n"},{"id":392,"href":"/3-1-41/","title":"3.1.41","section":"帮助","content":"3.1.41 #  解答 #  英文版描述为 1, 2, and 10 times faster。\n即一样快，快一倍和快十倍（一个例子）。\n和上题类似，也是解超越方程。\n插值查找的平均查找次数为 $\\lg(\\lg(N))$。\n可以解得 N = 1, 4, 58。\n实验结果如下：\n由于 N 太小，可以看到插值查找的运行时间几乎没有变化。\n"},{"id":393,"href":"/3-2-1/","title":"3.2.1","section":"帮助","content":"3.2.1 #  解答 #  构造出的树如下图所示：\n总比较次数：0 + 1 + 1 + 2 + 2 + 3 + 1 + 2 + 4 + 3 + 4 + 5 = 28 次\n另请参阅 #  BinarySearchTree 库\n"},{"id":394,"href":"/3-2-2/","title":"3.2.2","section":"帮助","content":"3.2.2 #  解答 #  用这样的序列就可以构造出最坏情况：\n\u0026quot;A X C S E R H\u0026quot;, \u0026quot;X A S C R E H\u0026quot;, \u0026quot;A C E H R S X\u0026quot;, \u0026quot;X S R H E C A\u0026quot;, \u0026quot;X A S R H E C\u0026quot;, \u0026quot;A X S R H E C\u0026quot; 构造出来的树看起来像这样：\n"},{"id":395,"href":"/3-2-3/","title":"3.2.3","section":"帮助","content":"3.2.3 #  解答 #  官方答案：第一个插入的是 H，且 C 在 A 和 E 之前插入，S 在 R 和 X 之前插入的树。\n对序列排序，得到 A C E H R S X 。\n最优情况需要树两侧平衡，因此 H 为根结点，C 和 S 分别为 H 的子结点。\n同理，A 和 E 为 C 的子结点，R 和 X 为 S 的子结点。\n"},{"id":396,"href":"/3-2-4/","title":"3.2.4","section":"帮助","content":"3.2.4 #  解答 #  d 是错误的。\n要点是追踪序列中的左右顺序，\n如果向右查找，那么后面的树一定都比它大，反之都比它小。\n例如 d 选项，2-\u0026gt;7 向右查找，但后面的 8 比 7 大，应该挂在 7 的右子树上，不可能在 7 的左子树里。\n"},{"id":397,"href":"/3-2-5/","title":"3.2.5","section":"帮助","content":"3.2.5 #  解答 #  事实上，这个问题可以归结为，如何根据频率来构造一棵最优的BST？\n如果知道树的形状，逆推插入顺序也就不难了（先序遍历）。\n首先我们定义某个结点的查找开销为该结点的深度加一乘以频率，\n（注意根结点的深度为 0，树的高度等于整棵树中最大的深度值）\n所有结点的查找开销加起来就是一整棵树的查找开销了。\n$$\ncost(n)=\\sum_{i=0}^{n} (depth(i)+1) \\times frequency(i)\n$$\n对于固定的一组键值和频率，$cost$ 最小的树即为我们要找的树。\n这样的树被称为最优化二叉树，或者 Optimal BST。\n根据二叉树的性质，我们可以将 $cost$ 的表达式变为：\n$$\ncost(n)=cost(left)+cost(right)+\\sum_{i=1}^{n} frequency(i)\n$$\n即左子树的开销和右子树的开销相加，再加上所有结点的频率之和。\n（左子树和右子树开销计算时每个结点的深度都少了1，因此要加上频率和）\n不难得到结论，Optimal BST 的所有子树也都是 Optimal BST。\n我们可以利用一种类似于构造哈夫曼树的方法构造 Optimal BST，\n哈夫曼树中比较的是频率，而构造 Optimal BST 时比较的则是开销。\n由于二叉查找树是有序的，因此我们先对序列排序。\n然后计算所有大小为 1 的子树开销，显然就等于各个节点的频率。\n再计算大小为 2 的子树，注意这里只能按顺序取结点，不能跳着取（例如取第一个和第三个结点），\n每种结点取法都对应有两种根结点选择，计算出最小的开销并记录。\n以此类推，直到计算到大小为 n 的树，此时整棵 BST 就被构造出来了。\n举个例子，例如给出键值和频率如下表所示：\n$$\n\\begin{array}{l|lllll}\nkey \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \\ \\hline\np \u0026amp; 0.4 \u0026amp; 0.1 \u0026amp; 0.2 \u0026amp; 0.1 \u0026amp; 0.2\n\\end{array}\n$$\n当 $s=1$ 时，各子树的开销如下表（根结点不唯一）：\n$$\n\\begin{array}{l|lllll}\nsubtree \u0026amp; [1,1] \u0026amp; [2,2] \u0026amp; [3,3] \u0026amp; [4,4] \u0026amp; [5,5] \\ \\hline\ncost \u0026amp; 0.4 \u0026amp; 0.1 \u0026amp; 0.2 \u0026amp; 0.1 \u0026amp; 0.2 \\\nroot \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5\n\\end{array}\n$$\n当 $s=2$ 时，各个子树的开销如下（根结点不唯一）：\n$$\n\\begin{array}{l|cccc}\nsubtree \u0026amp; [1,2] \u0026amp; [2,3] \u0026amp; [3,4] \u0026amp; [4,5] \\ \\hline\ncost \u0026amp; \\min \\begin{cases} 0+[2,2]+0.5, \\\\ [1,1]+0+0.5 \\end{cases} =0.6 \u0026amp; \\min \\begin{cases} 0+[3,3]+0.3, \\ [2,2]+0+0.3 \\end{cases} =0.4 \u0026amp; \\min \\begin{cases} 0+[4,4]+0.3, \\ [3,3]+0+0.3 \\end{cases} =0.4 \u0026amp; \\min \\begin{cases} 0 +[5,5]+0.3, \\ [4,4]+0+0.3 \\end{cases} =0.4 \\\nroot \u0026amp; 1 \u0026amp; 3 \u0026amp; 3 \u0026amp; 5\n\\end{array}\n$$\n当 $s=3$ 时，各个子树的开销如下表（根结点不唯一）：\n$$\n\\begin{array}{l|ccc}\nsubtree \u0026amp; [1,3] \u0026amp; [2,4] \u0026amp; [3,5] \\ \\hline\ncost \u0026amp; \\min \\begin{cases} 0+[2,3]+0.7, \\ [1,1]+[3,3]+0.7, \\ [1,2]+0+0.7 \\end{cases} =1.1 \u0026amp; \\min \\begin{cases} 0+[3,4]+0.4, \\ [2,2]+[4,4]+0.4, \\ [2,3]+0+0.4 \\end{cases} =0.6 \u0026amp; \\min \\begin{cases} 0+[4,5]+0.5, \\ [3,3]+[5,5]+0.5, \\ [3,4]+0+0.5 \\end{cases} =0.9 \\\nroot \u0026amp; 1 \u0026amp; 3 \u0026amp; 3\n\\end{array}\n$$\n当 $s=4$ 时，各个子树的开销如下表（根结点不唯一）：\n$$\n\\begin{array}{l|ll}\nsubtree \u0026amp; [1,1] \u0026amp; [2,2] \\ \\hline\ncost \u0026amp; \\min \\begin{cases} 0+[2,4]+0.8, \\ [1,1]+[3,4]+0.8, \\ [1,2]+[4,4]+0.8, \\ [1,3]+0+0.8 \\end{cases} = 1.4 \u0026amp; \\min \\begin{cases} 0+[3,5]+0.5, \\ [2,2]+[4,5]+0.5, \\ [2,3]+[5,5]+0.5, \\ [2,4]+0+0.5 \\end{cases} = 1.0 \\\nroot \u0026amp; 1 \u0026amp; 3\n\\end{array}\n$$\n当 $s=5$ 时，各个子树的开销如下表（根结点不唯一）：\n$$\n\\begin{array}{l|l}\nsubtree \u0026amp; [1,5] \\ \\hline\ncost \u0026amp; \\min \\begin{cases} 0+[2,5]+1.0, \\ [1,1]+[3,5]+1.0, \\ [1,2]+[4,5]+1.0, \\ [1,3]+[5,5]+1.0, \\ [1,4]+0+1.0 \\end{cases} = 2.0 \\\nroot \u0026amp; 1\n\\end{array}\n$$\n于是最优二叉树为（不唯一）：\n另请参阅 #  Optimal Binary Search Tree - Wikipedia\n"},{"id":398,"href":"/3-2-6/","title":"3.2.6","section":"帮助","content":"3.2.6 #  解答 #  官方 BST 实现见：https://algs4.cs.princeton.edu/32bst/BST.java.html\n二叉树的高度=左右子树最大高度+1，叶结点的高度为 0。\n于是我们可以构造如下递归方法：\nprivate int Height(Node x) { return x == null ? -1 : 1 + Math.Max(Height(x.Left), Height(x.Right)); } 当 x 等于 null 时，说明它是叶子结点的左/右子树，应该返回 0-1=-1。\n也可以在结点中添加一个 Height 属性，记录当前结点的高度，当插入新结点时重新计算高度。\n在 Put 方法中添加计算高度的代码：\nprivate Node Put(Node x, TKey key, TValue value) { if (x == null) return new Node(key, value, 1, 0); int cmp = key.CompareTo(x.Key); if (cmp \u0026lt; 0) x.Left = Put(x.Left, key, value); else if (cmp \u0026gt; 0) x.Right = Put(x.Right, key, value); else x.Value = value; x.Size = 1 + Size(x.Left) + Size(x.Right); x.Height = 1 + Math.Max(Height(x.Left), Height(x.Right)); return x; } 由于叶结点的高度为零，因此新插入的结点高度应该初始化为 0。\n"},{"id":399,"href":"/3-2-7/","title":"3.2.7","section":"帮助","content":"3.2.7 #  解答 #  平均查找次数 = 树所有结点的深度之和 / 结点个数 + 1。\n只要能够获得深度和，就能构造出如下用于计算平均查找次数的方法：\npublic int AverageCompares() { return DepthSum(root) / Size() + 1; } 二叉树的深度之和 = 左子树的深度和 + 右子树的深度和 + 左子树的结点个数 + 右子树的结点个数\n（加上根结点会使左右子树所有结点的深度+1）\n于是我们可以获得如下递归方法，用于计算一棵树的深度和：\nprivate int DepthSum(Node x) { if (x == null) return 0; return DepthSum(x.Left) + DepthSum(x.Right) + x.Size - 1; } 也可以在结点中直接添加一个 DepthSum 属性，用于记录当前结点的深度和。\n需要在每次插入新结点时重新计算查找路径上所有结点的 DepthSum。\nprivate Node Put(Node x, TKey key, TValue value, int depth) { if (x == null) return new Node(key, value, 1, depth); var cmp = key.CompareTo(x.Key); if (cmp \u0026lt; 0) x.Left = Put(x.Left, key, value, depth + 1); else if (cmp \u0026gt; 0) x.Right = Put(x.Right, key, value, depth + 1); else x.Value = value; x.Size = 1 + Size(x.Left) + Size(x.Right); x.DepthSum = depth; if (x.Left != null) x.DepthSum += x.Left.DepthSum; if (x.Right != null) x.DepthSum += x.Right.DepthSum; return x; } 在插入结点时需要传入一个参数以记录当前深度，新插入结点的默认深度和就是当前深度。\n"},{"id":400,"href":"/3-2-8/","title":"3.2.8","section":"帮助","content":"3.2.8 #  解答 #  假设输入的完全二叉树结点数目为 $n$。\n完全二叉树总是可以分成两部分，一个满二叉树，以及多余的结点。\n于是完全二叉树中满二叉树的部分层数为 $l = \\lfloor \\log_2 (n+1) \\rfloor$。（根结点位于第一层）\n满二叉树占的结点数量为 $n_1 = 2^l -1$，多余结点数量为 $n_2=n-n_1$。\n又因为深度等于层数 - 1，多余结点正好在满二叉树的下一层，因此多余结点的深度即为 $l$。\n于是多余结点的深度和 $d_2 = l \\times n_2$。\n接下来计算满二叉树的深度和。\n一个层数为 $l$ 的满二叉树，最后一层正好有 $2^{l-1}$ 个结点。\n于是深度和为 $d_1 = 0 \\times 1 + 1 \\times 2+2 \\times 4+\\cdots+(l-1)2^{l-1} =\\sum_{i=1}^{l-1} i2^i$。\n用错位相减法，有：\n$$\n\\begin{eqnarray*}\nd_1\u0026amp;=\u0026amp;1\\times 2^1 + \u0026amp;2 \\times 2^2 + \\cdots + (l-1)2^{l-1} \\\n2d_1\u0026amp;=\u0026amp; \u0026amp;1\\times 2^2 + \\cdots+(l-2)2^{l-1} +(l-1)2^{l} \\\nd_1-2d_1\u0026amp;=\u0026amp; 1 \\times2^1+ \u0026amp;1 \\times2^2+\\cdots+1\\times2^{l-1}-(l-1)2^l \\\nd_1 \u0026amp;=\u0026amp;(l-1)2^l \u0026amp;-2^l+2 \\\n\u0026amp;=\u0026amp;(l-2)2^l \u0026amp;+2\n\\end{eqnarray*}\n$$\n于是可得总深度和： $d=d_1+d_2=l\\times n_2+ (l-2)2^l+2$。\n平均查找次数即为：$avgCompare=d / n + 1$ 。\n代码 #  private static int OptCompares(int n) { // 完全二叉树 = 满二叉树 + 多余结点  // 满二叉树的层数。  var l = (int)Math.Log(n + 1, 2); // 多余结点的个数。  var extraNodes = n + 1 - (int)Math.Pow(2, l); var depthSum = extraNodes * l + (l - 2) * (int) Math.Pow(2, l) + 2; return depthSum / n + 1; } "},{"id":401,"href":"/3-2-9/","title":"3.2.9","section":"帮助","content":"3.2.9 #  解答 #  比较简单，可以按照如下步骤解决：\n 生成 n 个数。 生成这 n 个数的全排列。 生成 n! 棵二叉搜索树，取其中结构不同的部分。  全排列可以通过递归方式生成，方法类似于 DFS。\n开始 pool 中存有所有的数，遍历 pool ，每次取一个数放入 path 中，然后递归选择下一个。\nstatic void Permutation(List\u0026lt;int\u0026gt; pool, List\u0026lt;int\u0026gt; path, List\u0026lt;int[]\u0026gt; result) { if (pool.Count == 0) { result.Add(path.ToArray()); return; } for (var i = 0; i \u0026lt; pool.Count; i++) { var item = pool[i]; path.Add(item); pool.RemoveAt(i); Permutation(pool, path, result); pool.Insert(i, item); path.Remove(item); } } 有了 n! 棵二叉树之后，我们需要过滤掉结构相同的树。\n我们可以把二叉树转换成数组表示（层序遍历即可），然后遍历数组进行比较。\nvar treeA = a.ToArray(); var treeB = b.ToArray(); if (treeA.Length != treeB.Length) return false; for (var i = 0; i \u0026lt; treeA.Length; i++) { if (treeA[i] == null \u0026amp;\u0026amp; treeB[i] == null) continue; if (treeA[i] != null \u0026amp;\u0026amp; treeB[i] != null) continue; return false; } return true; 结果如下：\nn=2\nn=3\nn=4\nn=5\nn=6\n另请参阅 #  BinarySearchTree 库\n"},{"id":402,"href":"/3-2-10/","title":"3.2.10","section":"帮助","content":"3.2.10 #  解答 #  官方实现：https://algs4.cs.princeton.edu/32bst/TestBST.java.html\n测试结果：\nsize = 10 min = A max = X Testing keys() --------------------------- A 8 C 4 E 12 H 5 L 11 M 9 P 10 R 3 S 0 X 7 Testing select --------------------------- 0 A 1 C 2 E 3 H 4 L 5 M 6 P 7 R 8 S 9 X key rank floor ceil --------------------------- A 0 A A B 1 A C C 1 C C D 2 C E E 2 E E F 3 E H G 3 E H H 3 H H I 4 H L J 4 H L K 4 H L L 4 L L M 5 M M N 6 M P O 6 M P P 6 P P Q 7 P R R 7 R R S 8 S S T 9 S X U 9 S X V 9 S X W 9 S X X 9 X X Y 10 X Z 10 X range search --------------------------- A-Z (11)A C E H L M P R S X Z-A (0) X-X (1)X 0-Z (11)A C E H L M P R S X B-G (3)C E C-L (4)C E H L After deleting the smallest 3 keys --------------------------- H 5 L 11 M 9 P 10 R 3 S 0 X 7 After deleting the remaining keys --------------------------- After adding back the keys --------------------------- A 8 C 4 E 12 H 5 L 11 M 9 P 10 R 3 S 0 X 7 "},{"id":403,"href":"/3-2-11/","title":"3.2.11","section":"帮助","content":"3.2.11 #  解答 #  树的高度为树中深度最大的点的深度。\n因此 N 个结点最多只能构造出高度为 N-1 的树来，并不能构成高度为 N 的树。\n如果将题目变为用 N 个结点构造高度为 N-1 的二叉搜索树。\n这样的树即为二叉搜索树的最坏情况，除唯一的叶子结点之外，每个结点有且只有一个子树。\n于是除根结点外，每个结点都有两种选择，要么在左，要么在右。\n因此共有 $2 ^ {n - 1}$ 种形状。\n接下来证明，对于某一种确定的最坏情况，在 N 个元素各不相同的情况下，输入顺序是唯一的。\n证明：\n就 1 2 3 这三个元素而言，构造这样一棵树：\n 2 1 3 可以有 2 1 3 和 2 3 1 两种序列，因为在插入 2 之后可以选择的位置有两个\n但最坏情况下的二叉搜索树不存在具有两个子结点的结点，因此输入顺序是唯一的。\n反证：\n也可以这样考虑，假设序列 A 可以构造出一棵最坏情况下的二叉树，插入顺序为 $x_1 \\dots x_n$\n假设存在与 A 顺序不同的序列 B，它构造出的二叉树与 A 的相同。\n由于 A 和 B 的元素相同，因此 A 必然可以通过有限次元素交换得到 B。\n根据最坏情况下的二叉搜索树的性质，A 中的元素 $x_n$ 必然满足 $x_1 \\dots x_{n - 1}$ 的所有关系。\n例如，假设 $x_1 \u0026gt; x_2$， 则 $x_3$ 也必然满足 $x_1 \u0026gt; x_3$，即后面的元素必然满足前面元素的关系。\n于是 A 存在关系序列 $r_1 \\dots r_{n - 1}$，只有满足这样序列的输入才能构造出对应的二叉树。\n（可以将 $r$ 理解为大于号或者小于号，由于元素各不相同，因此不存在等号）\n显然 A 中的任意两个元素交换会导致至少一个 $r$ 倒置，除非进行逆向交换，否则这种倒置不可能消除。\n（大于号和小于号是不满足交换律的）\n因此 A 和 B 必定相同，得证。\n于是每一种最坏情况下的形状都唯一对应一种输入序列，共有 $2 ^ {n - 1}$ 种构造方式。\n"},{"id":404,"href":"/3-2-12/","title":"3.2.12","section":"帮助","content":"3.2.12 #  解答 #  二叉树的大小=左子树的大小+右子树的大小+1\n根据上述表达式可以构造出一个递归的 Size() 方法，并删除结点中的 Size 。\nRank() 和 Select() 仍然可以正常工作，但最坏情况下的耗时可能会达到 $O(n)$ 和 $O(n^2 )$。\n"},{"id":405,"href":"/3-2-13/","title":"3.2.13","section":"帮助","content":"3.2.13 #  解答 #  官方实现：https://algs4.cs.princeton.edu/32bst/NonrecursiveBST.java.html\nGet 方法可以很方便的改成非递归形式。\nwhile (cur != null) { var cmp = key.CompareTo(cur.Key); if (cmp \u0026lt; 0) cur = cur.Left; else if (cmp \u0026gt; 0) cur = cur.Right; else return cur.Value; } Put 方法结构类似，但需要注意更新路径上各个结点的 Size 属性。\nvar path = new Stack\u0026lt;Node\u0026gt;(); var cur = x; while (cur != null) { path.Push(cur); var cmp = key.CompareTo(cur.Key); if (cmp \u0026lt; 0) cur = cur.Left; else if (cmp \u0026gt; 0) cur = cur.Right; else { cur.Value = value; return x; } } var parent = path.Peek(); var node = new Node(key, value, 1); if (parent.Key.CompareTo(key) \u0026gt; 0) parent.Left = node; else parent.Right = node; while (path.Count \u0026gt; 0) path.Pop().Size++; Keys 方法中，可以用新建一个栈来代替递归栈记录路径。\nwhile (x != null || stack.Count \u0026gt; 0) { if (x != null) { stack.Push(x); x = x.Left; } else { x = stack.Pop(); queue.Enqueue(x.Key); x = x.Right; } } 另请参阅 #  BinarySearchTree 库\n"},{"id":406,"href":"/3-2-14/","title":"3.2.14","section":"帮助","content":"3.2.14 #  解答 #  就 min，max 和 select 而言，它们是尾递归的，可以直接转换成迭代形式。\n（简单的说，尾递归就是所有递归操作都出现在 return 语句上，且返回值不需要参与其他运算）\n例如 min，递归形式为：\nif (x.Left == null) return x; return Min(x.Left); 递归调用获得的值直接返回，不再参与运算，可以直接转换为递推：\nwhile (true) { if (x.Left == null) return x; x = x.Left; } ceiling 和 floor 会略微复杂一些，具体见代码。\n代码 #  min 和 max 比较简单，用一个 while 循环就可以转换为递推形式，例如 min。\nwhile (x != null) { if (x.Left == null) return x; x = x.Left; } return x; floor 和 ceiling 则要稍微复杂一点，需要记录当前找到的最小/最大值，例如 floor。\nNode floor = null; while (x != null) { var cmp = key.CompareTo(x.Key); if (cmp == 0) { return x; } if (cmp \u0026lt; 0) { x = x.Left; } else { floor = x; x = x.Right; } } return floor; rank 和它们类似，需要用一个变量记录当前排名。\nvar rank = 0; while (x != null) { var cmp = key.CompareTo(x.Key); if (cmp \u0026lt; 0) { x = x.Left; } else if (cmp \u0026gt; 0) { rank += 1 + Size(x.Left); x = x.Right; } else { rank += Size(x.Left); return rank; } } return rank; select 比较简单，不需要维护变量。\nwhile (x != null) { var t = Size(x.Left); if (t \u0026gt; k) { x = x.Left; } else if (t \u0026lt; k) { x = x.Right; k = k - t - 1; } else { return x; } } return null; 另请参阅 #  尾递归-维基百科\nBinarySearchTree 库\n"},{"id":407,"href":"/3-2-15/","title":"3.2.15","section":"帮助","content":"3.2.15 #  解答 #  比较简单，这里比较/取值都算一次访问，因此 keys 的访问序列会出现重复元素。\n   函数 路径     floor(Q) E Q   select(5) E Q   ceiling(Q) E Q   rank(J) E Q J   size(D, T) E Q T E D   keys(D, T) E D E Q J J M Q T S S T    "},{"id":408,"href":"/3-2-16/","title":"3.2.16","section":"帮助","content":"3.2.16 #  解答 #  在高德纳的《计算机程序设计艺术》第一卷里出现了这个公式，编号为 $2.3.4.5(3)$。\n书中的证明简单直接：\n考虑二叉树中的某个叶子结点 $V$，设根结点到它的路径长度为 $k$，现在将 $V$ 删去。\n对于二叉树的内部路径长度 $I$ 和外部路径长度 $E$ ：\n由于 $V$ 被删去，$E$ 将会减少 $2(k+1)$，$I$ 将会减少 $k$，但此时 $V$ 变成了一个外部结点，$E$ 又会加上 $k$。\n因此最后 $E$ 减少了 $k+2$，$I$ 减少了 $k$，重复 $N$ 次操作之后就可以得到 $E = I + 2N$。\n另请参阅 #  《计算机程序设计艺术：第一卷 基本算法》（第三版）P400\n"},{"id":409,"href":"/3-2-17/","title":"3.2.17","section":"帮助","content":"3.2.17 #  解答 #  像这样，有一些字母是重复的，因此删除后树形状不变：\n|-------------------------------E-------------------------------| A |---------------S---------------| |-------Q |-------Y I---| |---U |-O T N |---------------I---------------| A |-------S-------| |---Q |---Y |-O |-U N T I---------------| |-------S-------| |---Q |---Y |-O |-U N T I---------------| |-------T-------| |---Q |---Y |-O U N I---------------| |-------T-------| |---Q U |-O N I-------| |---T---| |-O U N I-------| |---T |-O N I-------| |---T |-O N I-------| |---T |-O N I---| |-O N |-O N N "},{"id":410,"href":"/3-2-18/","title":"3.2.18","section":"帮助","content":"3.2.18 #  解答 #  和上一题类似，只是删除顺序不同：\n|-------------------------------E-------------------------------| A |---------------S---------------| |-------Q |-------Y I---| |---U |-O T N E-------------------------------| |---------------S---------------| |-------Q |-------Y I---| |---U |-O T N |---------------S---------------| |-------Q |-------Y I---| |---U |-O T N |---------------S---------------| |-------Q |-------Y I---| |---U |-O T N |-------S-------| |---Q |---Y |-O |-U N T |-------S-------| |---Q |---Y O |-U T |-------S-------| Q |---Y |-U T S-------| |---Y |-U T |---Y |-U T |---Y |-U T |-Y U Y "},{"id":411,"href":"/3-2-19/","title":"3.2.19","section":"帮助","content":"3.2.19 #  解答 #  类似于这样的序列：\n|-------------------------------E-------------------------------| A |---------------S---------------| |-------Q |-------Y I---| |---U |-O T N |---------------I---------------| A |-------S-------| |---Q |---Y |-O |-U N T |---------------N---------------| A |-------S-------| |---Q |---Y O |-U T |---------------O---------------| A |-------S-------| Q |---Y |-U T |---------------Q---------------| A S-------| |---Y |-U T |-------S-------| A |---Y |-U T |---T---| A |-Y U |-U-| A Y |-Y A A "},{"id":412,"href":"/3-2-20/","title":"3.2.20","section":"帮助","content":"3.2.20 #  解答 #  勘误：英文版为 keys() 方法（而非 Size() 方法）。\n先来观察一下 keys() 方法的实现：\npublic IEnumerable\u0026lt;TKey\u0026gt; Keys(TKey lo, TKey hi) { var queue = new Queue\u0026lt;TKey\u0026gt;(); Keys(root, queue, lo, hi); return queue; } private void Keys(Node x, Queue\u0026lt;TKey\u0026gt; queue, TKey lo, TKey hi) { var cmplo = lo.CompareTo(x.Key); var cmphi = hi.CompareTo(x.Key); if (cmplo \u0026lt; 0) Keys(x.Left, queue, lo, hi); if (cmplo \u0026lt;= 0 \u0026amp;\u0026amp; cmphi \u0026gt;= 0) queue.Enqueue(x.Key); if (cmphi \u0026gt; 0) Keys(x.Right, queue, lo, hi); } 简单地说，就是从根结点同时向两侧查找，同时把中间的键加入到队列中（树高的倍数+范围内键的数量）。\n于是 Keys() 的耗时可以分成两部分：\n寻找小于 lo 的最大键值和大于 hi 的最小键值在最坏情况下需要的访问结点数——即树高。\n（例如当 lo 小于树中的最小键或者 hi 大于树中最大键时）\n以及访问 lo 和 hi 之间所有结点。\n"},{"id":413,"href":"/3-2-21/","title":"3.2.21","section":"帮助","content":"3.2.21 #  解答 #  要注意保持每个键的出现概率相等，可以先随机一个排名，然后从树中将对应排名的键取出来。\nprivate static readonly Random Random = new Random(); public TKey RandomKey() { var rank = Random.Next(1, Size() + 1); return GetKeyWithRank(root, rank); } private TKey GetKeyWithRank(Node x, int rank) { var left = (x.Left == null ? 0 : x.Left.Size) + 1; if (left \u0026gt; rank) { return GetKeyWithRank(x.Left, rank); } else if (left == rank) { return x.Key; } else { return GetKeyWithRank(x.Right, rank - left); } } 可以观察到每个键的出现概率都是差不多的。\n另请参阅 #  BinarySearchTree 库\n"},{"id":414,"href":"/3-2-22/","title":"3.2.22","section":"帮助","content":"3.2.22 #  解答 #  这里的前驱和后继指的是二叉树中序遍历序列里结点的前驱和后继。\n由于二叉搜索树的性质，它的中序遍历序列是递增有序的。\n因此一个结点如果有左子树，要么前驱就是左子树中最大的结点（最右侧）；\n同理结点如果有右子树，要么后继就是右子树中最小的结点（最左侧）。\n于是结点的前驱不会有右子节点，后继不会有左子节点，得证。\n"},{"id":415,"href":"/3-2-23/","title":"3.2.23","section":"帮助","content":"3.2.23 #  解答 #  不满足，反例如下：\n |-------10 |---5---| 3 |-8-| 6 9 Delete 5 then delete 3 |-------10 6---| 8-| 9 Delete 3 then delete 5 |---10 |-8-| 6 9 这里先删除 3 会使 5 的左子树为空，导致删除 5 的时候采取的策略被改变（尽管 5 的右子树没有任何变化）。\n另请参阅 #  Deletion procedure for a Binary Search Tree-Stackoverflow\n"},{"id":416,"href":"/3-2-24/","title":"3.2.24","section":"帮助","content":"3.2.24 #  解答 #  根据命题 D （英文版 P404，中文版 P255），一次插入所需的比较次数平均为 $ 1.39\\lg N$。\n(我们这里要求和，因此可以直接使用平均值进行计算）\n于是构造一棵二叉查找树所需的比较次数为：\n$$\n1.39C= 1.39\\sum_{i=0}^N \\lg i=1.39 \\times(\\lg 1 + \\lg2+\\cdots+\\lg N)\n$$\n根据对数恒等式，有：\n$$\nC=\\lg 1 + \\lg2+\\cdots+\\lg N=\\lg(1\\times2\\times3\\times\\cdots\\times N)=\\lg(N!)\n$$\n于是有 $ 1.39C=1.39\\lg(N!) \u0026gt; \\lg(N!)$ ，得证。\n"},{"id":417,"href":"/3-2-25/","title":"3.2.25","section":"帮助","content":"3.2.25 #  解答 #  官方实现：https://algs4.cs.princeton.edu/32bst/PerfectBalance.java.html\n先排序，然后视其为中序序列，每次取中间的键作为根结点，左半数组是左子树，右半数组是右子树，递归构造。\nprivate Node BuildTree(KeyValuePair\u0026lt;TKey, TValue\u0026gt;[] init, int lo, int hi)// init is sorted { if (lo \u0026gt; hi) { return null; } var mid = (hi - lo) / 2 + lo; var current = new Node(init[mid].Key, init[mid].Value, 1); current.Left = BuildTree(init, lo, mid - 1); current.Right = BuildTree(init, mid + 1, hi); if (current.Left != null) { current.Size += current.Left.Size; } if (current.Right != null) { current.Size += current.Right.Size; } return current; } 另请参阅 #  BinarySearchTree 库\n"},{"id":418,"href":"/3-2-26/","title":"3.2.26","section":"帮助","content":"3.2.26 #  解答 #  在 {% post_link 3-2-9 3.2.9 %} 的代码基础上进行修改，统计每种形状的出现次数，以此获得准确的概率。\n概率如下，基本呈现一个对称的图形。\n原始数据：\nn=2 50% 50% n=3 16.666666% 16.666666% 33.333332% 16.666666% 16.666666% n=4 8.333333% 16.666666% 37.5% 12.5% 8.333333% 16.666666% n=5 0.8333333% 0.8333333% 1.6666666% 0.8333333% 0.8333333% 2.5% 2.5% 2.5% 2.5% 0.8333333% 0.8333333% 1.6666666% 0.8333333% 0.8333333% 3.3333333% 3.3333333% 6.6666665% 3.3333333% 3.3333333% 5% 5% 5% 5% 3.3333333% 3.3333333% 6.6666665% 3.3333333% 3.3333333% 0.8333333% 0.8333333% 1.6666666% 0.8333333% 0.8333333% 2.5% 2.5% 2.5% 2.5% 0.8333333% 0.8333333% 1.6666666% 0.8333333% 0.8333333% n=6 0.2777778% 0.5555556% 1.25% 0.41666666% 0.2777778% 0.5555556% 1.1111112% 2.2222223% 1.9444444% 0.8333333% 1.9444444% 0.8333333% 1.1111112% 0.2777778% 0.5555556% 1.25% 0.41666666% 0.2777778% 0.5555556% 1.3888888% 2.7777777% 6.25% 2.0833333% 1.3888888% 2.7777777% 4.1666665% 2.7777777% 4.1666665% 4.1666665% 2.7777777% 4.1666665% 1.3888888% 1.3888888% 2.7777777% 2.7777777% 1.3888888% 1.3888888% 1.3888888% 2.7777777% 6.25% 2.0833333% 1.3888888% 2.7777777% 0.2777778% 0.5555556% 1.25% 0.41666666% 0.2777778% 0.5555556% 1.1111112% 2.2222223% 1.9444444% 0.8333333% 1.9444444% 0.8333333% 1.1111112% 0.2777778% 0.5555556% 1.25% 0.41666666% 0.2777778% 0.5555556% "},{"id":419,"href":"/3-2-27/","title":"3.2.27","section":"帮助","content":"3.2.27 #  解答 #  二叉查找树的内存开销=对象开销+根结点引用+N个结点\n=对象开销+根结点引用+N×(对象开销+父类型引用+左/右子树引用+键/值引用+结点数)\n=16+8+N×(16+8+16+16+4+4)=24+64N 字节\nBinarySearchST：对象开销+键/值数组引用+键/值数组+计数器（一个 int）。\n=16+16+(16+4+4+8N)×2+4+4=88+16N 字节。\nSequentialSearchST：对象开销+头结点引用+N个结点+计数器\n=对象开销+头结点引用+N×(对象开销+父类型引用+next引用+键/值引用)+计数器\n=16+8+N×(16+8+8+16)+4+4=32+48N 字节\n示意图如下：\n其中，对象开销 16 字节，其他均为引用，各占 8 字节。\n《双城记》中不重复的单词有 26436 个（不包括最后的版权声明），全部是原文的子字符串，每个占 40 字节。\n一个 Integer 占 24 字节，于是估计的内存消耗为：24+(64+40+24)×26436=3383832 字节。\n"},{"id":420,"href":"/3-2-28/","title":"3.2.28","section":"帮助","content":"3.2.28 #  解答 #  修改一下 Put 和 Get 方法，在实际操作之前先检查缓存是否符合要求，然后在操作之后更新缓存。\n代码 #  private Node _cache; public override TValue Get(TKey key) { if (_cache != null \u0026amp;\u0026amp; _cache.Key.CompareTo(key) == 0) { return _cache.Value; } return Get(root, key).Value; } protected override Node Get(Node x, TKey key) { if (key == null) { throw new ArgumentNullException(\u0026#34;calls get() with a null key\u0026#34;); } if (x == null) { return null; } var cmp = key.CompareTo(x.Key); if (cmp \u0026lt; 0) { return Get(x.Left, key); } else if (cmp \u0026gt; 0) { return Get(x.Right, key); } else { _cache = x; return x; } } public override void Put(TKey key, TValue value) { if (key == null) { throw new ArgumentNullException(\u0026#34;calls Put() with a null key\u0026#34;); } if (value == null) { Delete(key); return; } if (_cache != null \u0026amp;\u0026amp; _cache.Key.CompareTo(key) == 0) { _cache.Value = value; return; } root = Put(root, key, value); } protected override Node Put(Node x, TKey key, TValue value) { if (x == null) { _cache = new Node(key, value, 1); return _cache; } var cmp = key.CompareTo(x.Key); if (cmp \u0026lt; 0) x.Left = Put(x.Left, key, value); else if (cmp \u0026gt; 0) x.Right = Put(x.Right, key, value); else x.Value = value; x.Size = 1 + Size(x.Left) + Size(x.Right); return x; } 另请参阅 #  BinarySearchTree 库\n"},{"id":421,"href":"/3-2-29/","title":"3.2.29","section":"帮助","content":"3.2.29 #  解答 #  本题在原书后续印刷中已修改，这里仍采用中文版的题目。\n部分解答：https://algs4.cs.princeton.edu/32bst/BST.java.html（isSizeConsistent()）\n如果根结点记录的结点数=左子树的结点数+右子树的结点数+1，就符合要求。\n按照这个题意编制递归方法即可。\n先写边界，当输入为 null 时，显然符合要求。\n然后计算左子树的 Size 和右子树的 Size 加起来是否等于根结点的 Size + 1，\n以及左子树和右子树是否符合同样的条件。\n代码 #  protected static bool IsBinaryTree(Node x) { if (x == null) { return true; // 空树显然符合二叉树条件。  } var size = 1; // 包括当前结点本身。  if (x.Left != null) { size += x.Left.Size; } if (x.Right != null) { size += x.Right.Size; } return IsBinaryTree(x.Left) \u0026amp;\u0026amp; IsBinaryTree(x.Right) \u0026amp;\u0026amp; x.Size == size; } 另请参阅 #  BinarySearchTree 库\n"},{"id":422,"href":"/3-2-30/","title":"3.2.30","section":"帮助","content":"3.2.30 #  解答 #  本题在原书后续印刷中已修改，这里仍然采用中文版的题目。\n与上一题非常类似，条件有：\n根结点必须在 min 和 max 范围内，\n且左右子树要么不存在，要么小于/大于根结点的键，\n左右子树同样满足上述条件。\n代码 #  protected static bool IsOrdered(Node x, TKey min, TKey max) { if (x == null) { return true; // 空树显然是满足要求的。  } return IsOrdered(x.Left, min, max) \u0026amp;\u0026amp; IsOrdered(x.Right, min, max) \u0026amp;\u0026amp; // 左右子树都满足要求。  x.Key.CompareTo(max) \u0026lt;= 0 \u0026amp;\u0026amp; x.Key.CompareTo(min) \u0026gt;= 0 \u0026amp;\u0026amp; // 当前结点位于范围内。  (x.Left == null || x.Left.Key.CompareTo(x.Key) \u0026lt; 0) \u0026amp;\u0026amp; (x.Right == null || x.Right.Key.CompareTo(x.Key) \u0026gt; 0); // 当前结点与子结点满足大小关系。 } 另请参阅 #  BinarySearchTree 库\n"},{"id":423,"href":"/3-2-31/","title":"3.2.31","section":"帮助","content":"3.2.31 #  解答 #  本题在原书后续印刷中已删除，这里仍然采用中文版的题目。\n注意这个题并没有递归的要求，直接广度优先搜索即可，随时记录和检查已找到的键。\n代码 #  protected static bool HasNoDuplicates(Node x) { var keys = new List\u0026lt;TKey\u0026gt;(); // 也可以用 HashSet 之类的数据结构提高效率。  var queue = new Queue\u0026lt;Node\u0026gt;(); queue.Enqueue(x); while (queue.Count \u0026gt; 0) { var node = queue.Dequeue(); if (node == null) { continue; } if (keys.Contains(node.Key)) { return false; } keys.Add(node.Key); queue.Enqueue(node.Left); queue.Enqueue(node.Right); } return true; } 另请参阅 #  BinarySearchTree 库\n"},{"id":424,"href":"/3-2-32/","title":"3.2.32","section":"帮助","content":"3.2.32 #  解答 #  本题在原书后续印刷中已修改，这里仍然采用中文版的题目。\n官网解答见：https://algs4.cs.princeton.edu/32bst/BST.java.html （isBST()）\n书中已经给出了答案，当然在 Java 和 C# 里，\u0026amp;\u0026amp; 总是从左向右计算的，而且遇到 false 会直接返回结果。\n如果数据结构中存在环，IsOrdered 有可能会陷入无限递归的情况，因此调用顺序比较重要。\n代码 #  public static bool IsBST(BST\u0026lt;TKey, TValue\u0026gt; bst) { return IsBinaryTree(bst) \u0026amp;\u0026amp; IsOrdered(bst) \u0026amp;\u0026amp; HasNoDuplicates(bst); } 另请参阅 #  Boolean logical operators (C# reference)\nEquality, Relational, and Conditional Operators\nBinarySearchTree 库\n"},{"id":425,"href":"/3-2-33/","title":"3.2.33","section":"帮助","content":"3.2.33 #  解答 #  官网解答见：https://algs4.cs.princeton.edu/32bst/BST.java.html （isRankConsistent()）\n按照题目要求实现即可，分为两步进行测试。\n代码 #  public static bool IsRankConsistent(BST\u0026lt;TKey, TValue\u0026gt; bst) { for (var i = 0; i \u0026lt; bst.Size(); i++) { if (i != bst.Rank(bst.Select(i))) { return false; } } foreach (var key in bst.Keys()) { if (key.CompareTo(bst.Select(bst.Rank(key))) != 0) { return false; } } return true; } 另请参阅 #  BinarySearchTree 库\n"},{"id":426,"href":"/3-2-34/","title":"3.2.34","section":"帮助","content":"3.2.34 #  解答 #  其实就是将所有的结点按照中序序列排成了一个双向链表，对树进行修改时要同时更新这个双向链表。\n当插入新结点时，插到左侧的结点会变为父结点的新前驱，同理右侧会变为新后继。\n注意要更新父结点原来的前驱和后继结点（如果有）。\n删除结点时较为简单，只要更新需要删除结点的前驱和后继结点即可。\n原本操作 left 和 right 的代码不需要更改，只需要加上对 prev 和 next 做操作的代码即可。\nPrev 方法实现如下（Next 类似），修改了内部的 Get 方法使之返回 Node 而非 TValue。\npublic TKey Prev(TKey key) { var node = Get(root, key); if (node == null || node.Prev == null) return null; return node.Prev.Key; } 代码 #  处理结点关系的几个方法。\nprivate void DeleteNode(Node x) { if (x.Prev != null) x.Prev.Next = x.Next; if (x.Next != null) x.Next.Prev = x.Prev; } private void InsertRight(Node parent, Node newNode) { parent.Right = newNode; InsertBetween(parent, newNode, parent.Next); } private void InsertLeft(Node parent, Node newNode) { parent.Left = newNode; InsertBetween(parent.Prev, newNode, parent); } private void InsertBetween(Node prev, Node newNode, Node next) { newNode.Prev = prev; newNode.Next = next; if (prev != null) prev.Next = newNode; if (next != null) next.Prev = newNode; } Put 方法\nprotected virtual Node Put(Node x, TKey key, TValue value) { if (x == null) { return new Node(key, value, 1); // 树是空的。  } var cmp = key.CompareTo(x.Key); if (cmp \u0026lt; 0) { if (x.Left == null) { var newNode = new Node(key, value, 1); InsertLeft(x, newNode); } else { x.Left = Put(x.Left, key, value); } } else if (cmp \u0026gt; 0) { if (x.Right == null) { var newNode = new Node(key, value, 1); InsertRight(x, newNode); } else { x.Right = Put(x.Right, key, value); } } else { x.Value = value; } x.Size = 1 + Size(x.Left) + Size(x.Right); return x; } Delete 方法\nprotected virtual Node Delete(Node x, TKey key) { if (x == null) return null; var cmp = key.CompareTo(x.Key); if (cmp \u0026lt; 0) x.Left = Delete(x.Left, key); else if (cmp \u0026gt; 0) x.Right = Delete(x.Right, key); else { DeleteNode(x); // 在中序链表中删除结点。  if (x.Right == null) return x.Left; if (x.Left == null) return x.Right; var t = x; x = Min(t.Right); x.Right = DeleteMin(t.Right); x.Left = t.Left; } x.Size = Size(x.Left) + Size(x.Right) + 1; return x; } DeleteMin 方法，DeleteMax 类似。\nprotected virtual Node DeleteMin(Node x) { if (x.Left == null) { DeleteNode(x); return x.Right; } x.Left = DeleteMin(x.Left); x.Size = Size(x.Left) + Size(x.Right) + 1; return x; } 另请参阅 #  BinarySearchTree 库\n"},{"id":427,"href":"/3-2-35/","title":"3.2.35","section":"帮助","content":"3.2.35 #  解答 #  根据书中已经给出的归纳关系式（中文版P255/英文版P403）：\n$$\nC_N=N-1+(C_0+C_{N-1})/N+(C_1+C_{N-2})/N+\\cdots+(C_{N-1}+C_0)/N\n$$\n整理得：\n$$\nC_N=N-1+(C_0+C_1+\\cdots+C_{N-1})/N+(C_{N-1}+\\cdots+C_1+C_0)/N\n$$\n这和快速排序的式子基本一致，只是 $N+1$ 变成了 $N-1$。\n遵循相同的推导过程，我们可以获得类似的结果，两边同乘以 $N$：\n$$\nNC_N=N(N-1)+2(C_0+C_1+\\cdots+C_{N-1})\n$$\n用 $N+1$ 时的等式减去该式得：\n$$\n(N+1)C_{N+1}-NC_N=2N+2C_N \\\n(N+1)C_{N+1}=2N+(N+2)C_N \\\n\\frac{C_{N+1}}{N+2}=\\frac{2N}{(N+1)(N+2)} + \\frac{C_N}{N+1}\n$$\n令 $T_N = \\frac{C_N}{N+1}$，得到：\n$$\nT_{N+1}=\\frac{2N}{(N+1)(N+2)} + T_N \\\nT_{N+1}-T_{N} = \\frac{2N}{(N+1)(N+2)}\n$$\n归纳得：\n$$\n\\begin{aligned}\nT_N \u0026amp;= 2 \\sum_{i=2}^{N} \\frac{i-1}{i(i+1)} \\\nC_N\u0026amp;=2(N+1)\\sum_{i=2}^{N} \\frac{i-1}{i(i+1)} \\\nC_N\u0026amp;=2(N+1)\\sum_{i=2}^{N}(i-1) (\\frac{1}{i}-\\frac{1}{i+1}) \\\nC_N\u0026amp;=-2(N-1)+ 2(N+1)\\sum_{i=2}^{N}\\frac{1}{i}\\\nC_N\u0026amp;=-2(N-1)+ 2(N+1)(-1+\\sum_{i=1}^{N}\\frac{1}{i})\\\nC_N\u0026amp;=-4N+2(N+1)(\\ln N+\\gamma)\n\\end{aligned}\n$$\n于是平均成本为：$1+C_N/N \\sim 2\\ln N+2\\gamma-3$ 。\n"},{"id":428,"href":"/3-2-36/","title":"3.2.36","section":"帮助","content":"3.2.36 #  解答 #  用一个栈来模拟递归即可，将路径上的结点记录到栈里。\n注意 Queue\u0026lt;TKey\u0026gt; 不算额外空间，因为它在keys执行完毕之后不会被回收。\n代码 #  private void Keys(Node x, Queue\u0026lt;TKey\u0026gt; queue, TKey lo, TKey hi) { var stack = new Stack\u0026lt;Node\u0026gt;(); while (x != null || stack.Count \u0026gt; 0) { if (x != null) { var cmpLo = lo.CompareTo(x.Key); var cmpHi = hi.CompareTo(x.Key); if (cmpHi \u0026gt;= 0) stack.Push(x); if (cmpLo \u0026lt; 0) x = x.Left; else x = null; } else { x = stack.Pop(); var cmpLo = lo.CompareTo(x.Key); var cmpHi = hi.CompareTo(x.Key); if (cmpLo \u0026lt;= 0 \u0026amp;\u0026amp; cmpHi \u0026gt;= 0) queue.Enqueue(x.Key); x = x.Right; } } } 另请参阅 #  BinarySearchTree 库\n"},{"id":429,"href":"/3-2-37/","title":"3.2.37","section":"帮助","content":"3.2.37 #  解答 #  二叉树层序遍历，出队一个结点，打印它，将结点的左右子树入队，循环即可。\n代码 #  private void PrintLevel(Node x) { var queue = new Queue\u0026lt;Node\u0026gt;(); queue.Enqueue(x); while (queue.Count \u0026gt; 0) { var node = queue.Dequeue(); if (node.Left != null) queue.Enqueue(node.Left); if (node.Right != null) queue.Enqueue(node.Right); Console.Write(node.Key + \u0026#34;, \u0026#34;); } } 另请参阅 #  BinarySearchTree 库\n"},{"id":430,"href":"/3-2-38/","title":"3.2.38","section":"帮助","content":"3.2.38 #  解答 #  通过层序遍历计算结点的坐标，然后绘制即可。\n先算出最大深度，确定每一层的高度 Y，\n再将每一层的宽度分成 $2^n-1$ 份，从左到右依次对结点赋值。\n效果如下：\n代码 #  计算坐标的函数。\npublic void DrawTree(Graphics pen, RectangleF panel) { var depth = Depth(root); // 确定最大深度。  var layerHeight = panel.Height / depth; var nowLayer = new Queue\u0026lt;Node\u0026gt;(); var nextLayer = new Queue\u0026lt;Node\u0026gt;(); nextLayer.Enqueue(root); for (var layer = 0; layer != depth; layer++) { var unitSizeX = (float)(panel.Width / Math.Pow(2, layer)); var temp = nowLayer; nowLayer = nextLayer; nextLayer = temp; var cursorX = 0.0f; var cursorY = layer * layerHeight; while (nowLayer.Count != 0) { var node = nowLayer.Dequeue(); if (node != null) { nextLayer.Enqueue(node.Left); nextLayer.Enqueue(node.Right); } else { nextLayer.Enqueue(null); nextLayer.Enqueue(null); } if (node != null) { node.X = cursorX + unitSizeX / 2.0f; node.Y = cursorY; } cursorX += unitSizeX; } } } "},{"id":431,"href":"/3-2-39/","title":"3.2.39","section":"帮助","content":"3.2.39 #  解答 #  测试结果：\n可以看到和公式给出的结果十分一致。\n测试时先生成 0~2n 顺序序列，奇数插入二叉树中，偶数用于测试查找失败的情况。\n代码 #  static void Main(string[] args) { var n = 10000; var trial = 100; for (var i = 0; i \u0026lt; 3; i++) { var odds = new int[n]; var evens = new int[n]; var bst = new BSTAnalysis\u0026lt;int, int\u0026gt;(); for (var j = 100; j \u0026lt; n; j++) { evens[j] = j; odds[j] = j + 1; } Shuffle(odds); foreach (var item in odds) { bst.Put(item, item); } Console.WriteLine(\u0026#34;n:\u0026#34; + n); // hit  Shuffle(odds); Test(bst, odds, trial, \u0026#34;hit\u0026#34;); // miss  Shuffle(evens); Test(bst, evens, trial, \u0026#34;miss\u0026#34;); n *= 10; } } static void Test(BSTAnalysis\u0026lt;int, int\u0026gt; bst, int[] testCases, int trials, string label) { var testRecords = new long[trials]; for (var j = 0; j \u0026lt; trials; j++) { bst.CompareTimes = 0; // reset  bst.Get(testCases[j]); // test  testRecords[j] = bst.CompareTimes; // record  } var testAverage = 0d; // \u0026#39;d\u0026#39; for double  foreach (var record in testRecords) { testAverage += record; } testAverage /= testRecords.Length; var testStandardDeviation = 0d; foreach (var record in testRecords) { testStandardDeviation += (record - testAverage) * (record - testAverage); } testStandardDeviation /= testRecords.Length; testStandardDeviation = Math.Sqrt(testStandardDeviation); // 2lnN + 2γ - 3  var expect = 2 * Math.Log(testCases.Length) + 2 * 0.5772156649 - 3; Console.WriteLine(label + \u0026#34;: ActualAverage: \u0026#34; + testAverage + \u0026#34;\\tExpectAverage: \u0026#34; + expect + \u0026#34;\\tStandardDevitation:\u0026#34; + testStandardDeviation); } static void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } 另请参阅 #  BinarySearchTree 库\n"},{"id":432,"href":"/3-2-40/","title":"3.2.40","section":"帮助","content":"3.2.40 #  解答 #  书中的结论是 1986 年 L. Devroye 给出的，原式为 $H_n \\rightarrow c\\log(n)$。\n其中 $c$ 是方程 $c\\log \\frac{2e}{c}=1$ 的最大解，约为 $4.31107$。\n2002 年 Michael Drmota 给出了一个跟精确的公式：$\\mathrm{E}(H_n)=c\\log n-\\frac{3c}{2(c-1)}\\log \\log n + O(1)$。\n测试结果如下，误差基本稳定在一个常数。\n代码 #  static void Main(string[] args) { var n = 10000; var trials = 100; for (var i = 0; i \u0026lt; 3; i++) { var items = new int[n]; for (var j = 0; j \u0026lt; n; j++) { items[j] = j; } var aveHeight = 0d; for (var j = 0; j \u0026lt; trials; j++) { var bst = new BST\u0026lt;int, int\u0026gt;(); Shuffle(items); foreach (var item in items) { bst.Put(item, item); } aveHeight += bst.Height(); } aveHeight /= trials; var c = 4.31107d; var expectHeightLuc = c * Math.Log(n); var expectHeightMichael = c * Math.Log(n) - (3 * c / (2 * (c - 1))) * Math.Log(Math.Log(n)); Console.WriteLine(\u0026#34;n:\u0026#34; + n); Console.WriteLine(\u0026#34;Actual Height:\u0026#34; + aveHeight); Console.WriteLine(\u0026#34;Devroye: \u0026#34; + expectHeightLuc + \u0026#34;\\tDiff: \u0026#34; + (float)(expectHeightLuc - aveHeight)); Console.WriteLine(\u0026#34;Michael: \u0026#34; + expectHeightMichael + \u0026#34;\\tDiff: \u0026#34; + (float)(expectHeightMichael - aveHeight)); n *= 10; } } static void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } 另请参阅 #  A note on the height of binary search tree\nNote The Variance of the height of binary search trees\nBinarySearchTree 库\n"},{"id":433,"href":"/3-2-41/","title":"3.2.41","section":"帮助","content":"3.2.41 #  解答 #  大体上和标准 BST 实现差不多，做如下变换即可：\nx.Key =\u0026gt; _nodes[x].Key; x.Value =\u0026gt; _nodes[x].Value; x.Left =\u0026gt; _left[x]; x.Right =\u0026gt; _right[x]; 由于使用了数组，在正常「删除」二叉树结点之后，还需要手工「垃圾回收」，如下图所示：\n性能比较：\n可见数组实现在删除节点时有巨大的性能差距。\n代码 #  private readonly Node[] _nodes; private readonly int[] _left; private readonly int[] _right; private int _size; private int _root; /// \u0026lt;summary\u0026gt; /// 二叉搜索树的结点。 /// \u0026lt;/summary\u0026gt; private class Node { public TKey Key { get; set; } public TValue Value { get; set; } } /// \u0026lt;summary\u0026gt; /// 建立一个以数组为基础的二叉搜索树。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;maxSize\u0026#34;\u0026gt;二叉搜索树中的结点数。\u0026lt;/param\u0026gt; public BSTArray(int maxSize) { _nodes = new Node[maxSize]; _left = new int[maxSize]; _right = new int[maxSize]; for (var i = 0; i \u0026lt; maxSize; i++) { _left[i] = -1; _right[i] = -1; } _size = 0; _root = 0; } /// \u0026lt;summary\u0026gt; /// 向符号表插入键值对。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;值。\u0026lt;/param\u0026gt; public void Put(TKey key, TValue value) { if (_size == _nodes.Length) { throw new InvalidOperationException(\u0026#34;BST is full\u0026#34;); } if (IsEmpty()) { _nodes[_size] = new Node{Key = key, Value = value}; _size++; return; } Put(key, value, null, _root); } /// \u0026lt;summary\u0026gt; /// 向二叉树插入键值对。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;值。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;treeSide\u0026#34;\u0026gt;子树数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parent\u0026#34;\u0026gt;父结点下标。\u0026lt;/param\u0026gt; private void Put(TKey key, TValue value, int[] treeSide, int parent) { int now; if (treeSide == null) // init  { now = parent; } else if (treeSide[parent] == -1) // finish  { _nodes[_size] = new Node { Key = key, Value = value }; treeSide[parent] = _size; _size++; return; } else { now = treeSide[parent]; } var cmp = _nodes[now].Key.CompareTo(key); if (cmp \u0026gt; 0) { Put(key, value, _left, now); } else if (cmp \u0026lt; 0) { Put(key, value, _right, now); } else { _nodes[now].Value = value; } } /// \u0026lt;summary\u0026gt; /// 获取键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 对应的值，不存在则返回 \u0026lt;c\u0026gt;default(Value)\u0026lt;/c\u0026gt;。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 对应的值，不存在则返回 \u0026lt;c\u0026gt;default(Value)\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public TValue Get(TKey key) { var indices = Get(key, _root); if (indices == -1) { return default; } return _nodes[indices].Value; } /// \u0026lt;summary\u0026gt; /// 获取 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 对应的下标，不存在则返回 -1。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;start\u0026#34;\u0026gt;起始搜索下标。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;找到则返回对应下标，否则返回 -1。\u0026lt;/returns\u0026gt; private int Get(TKey key, int start) { var now = start; while (now != -1) { var cmp = _nodes[now].Key.CompareTo(key); if (cmp \u0026gt; 0) { now = _left[now]; } else if (cmp \u0026lt; 0) { now = _right[now]; } else { return now; } } return -1; } /// \u0026lt;summary\u0026gt; /// 从表中删去键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 及其对应的值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要删除的键。\u0026lt;/param\u0026gt; public void Delete(TKey key) { var toDelete = Get(key, _root); if (toDelete == -1) { throw new InvalidOperationException(\u0026#34;No Such Key in BST\u0026#34;); } _root = Delete(key, _root); RemoveNode(toDelete); } /// \u0026lt;summary\u0026gt; /// 从根结点为 \u0026lt;paramref name=\u0026#34;root\u0026#34;/\u0026gt; 的二叉搜索树中删除键为 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的结点。 /// 返回删除结点后树的根结点下标。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要删除的键。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;root\u0026#34;\u0026gt;根结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;删除结点后树的根结点下标。\u0026lt;/returns\u0026gt; private int Delete(TKey key, int root) { if (root == -1 || _nodes[root] == null) { return -1; } var cmp = _nodes[root].Key.CompareTo(key); if (cmp \u0026gt; 0) { _left[root] = Delete(key, _left[root]); } else if (cmp \u0026lt; 0) { _right[root] = Delete(key, _right[root]); } else { if (_left[root] == -1) { return _right[root]; } if (_right[root] == -1) { return _left[root]; } var toReplace = Min(_right[root]); _right[toReplace] = DeleteMin(_right[root]); _left[toReplace] = _left[root]; root = toReplace; } return root; } /// \u0026lt;summary\u0026gt; /// 键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 在表中是否存在对应的值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果存在则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool Contains(TKey key) { return Get(key, _root) \u0026gt; -1; } /// \u0026lt;summary\u0026gt; /// 符号表是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;为空则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _size == 0; } /// \u0026lt;summary\u0026gt; /// 获得符号表中键值对的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;符号表中键值对的数量。\u0026lt;/returns\u0026gt; public int Size() { return _size; } /// \u0026lt;summary\u0026gt; /// [\u0026lt;paramref name=\u0026#34;lo\u0026#34;/\u0026gt;, \u0026lt;paramref name=\u0026#34;hi\u0026#34;/\u0026gt;] 之间键的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;[\u0026lt;paramref name=\u0026#34;lo\u0026#34;/\u0026gt;, \u0026lt;paramref name=\u0026#34;hi\u0026#34;/\u0026gt;] 之间键的数量。\u0026lt;/returns\u0026gt; public int Size(TKey lo, TKey hi) { return Keys(lo, hi).Count(); } /// \u0026lt;summary\u0026gt; /// 计算以 \u0026lt;paramref name=\u0026#34;root\u0026#34;/\u0026gt; 为根结点的二叉树的大小。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;root\u0026#34;\u0026gt;二叉树的根结点下标。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;二叉树中的结点个数。\u0026lt;/returns\u0026gt; private int Size(int root) { if (root == -1) { return 0; } return 1 + Size(_left[root]) + Size(_right[root]); } /// \u0026lt;summary\u0026gt; /// 获得符号表中所有键的集合。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;符号表中所有键的集合。\u0026lt;/returns\u0026gt; public IEnumerable\u0026lt;TKey\u0026gt; Keys() { if (IsEmpty()) { return new List\u0026lt;TKey\u0026gt;(); } return Keys(Min(), Max()); } /// \u0026lt;summary\u0026gt; /// 获得符号表中 [\u0026lt;paramref name=\u0026#34;lo\u0026#34;/\u0026gt;, \u0026lt;paramref name=\u0026#34;hi\u0026#34;/\u0026gt;] 之间的键。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;符号表中 [\u0026lt;paramref name=\u0026#34;lo\u0026#34;/\u0026gt;, \u0026lt;paramref name=\u0026#34;hi\u0026#34;/\u0026gt;] 之间的键。\u0026lt;/returns\u0026gt; public IEnumerable\u0026lt;TKey\u0026gt; Keys(TKey lo, TKey hi) { if (lo == null) throw new ArgumentNullException(\u0026#34;first argument to keys() is null\u0026#34;); if (hi == null) throw new ArgumentNullException(\u0026#34;second argument to keys() is null\u0026#34;); var queue = new Queue\u0026lt;TKey\u0026gt;(); Keys(_root, queue, lo, hi); return queue; } /// \u0026lt;summary\u0026gt; /// 获取二叉查找树中在 \u0026lt;paramref name=\u0026#34;lo\u0026#34;/\u0026gt; 和 \u0026lt;paramref name=\u0026#34;hi\u0026#34;/\u0026gt; 之间的所有键。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;二叉查找树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;queue\u0026#34;\u0026gt;要填充的队列。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;键的下限。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;键的上限。\u0026lt;/param\u0026gt; private void Keys(int x, Queue\u0026lt;TKey\u0026gt; queue, TKey lo, TKey hi) { if (x == -1) { return; } var cmplo = lo.CompareTo(_nodes[x].Key); var cmphi = hi.CompareTo(_nodes[x].Key); if (cmplo \u0026lt; 0) { Keys(_left[x], queue, lo, hi); } if (cmplo \u0026lt;= 0 \u0026amp;\u0026amp; cmphi \u0026gt;= 0) { queue.Enqueue(_nodes[x].Key); } if (cmphi \u0026gt; 0) { Keys(_right[x], queue, lo, hi); } } /// \u0026lt;summary\u0026gt; /// 最小的键。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最小的键。\u0026lt;/returns\u0026gt; public TKey Min() { if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;BST is Empty!\u0026#34;); } return _nodes[Min(_root)].Key; } /// \u0026lt;summary\u0026gt; /// 在二叉查找树中查找包含最小键的结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;二叉查找树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;包含最小键的结点。\u0026lt;/returns\u0026gt; private int Min(int x) { if (_left[x] == -1) { return x; } return Min(_left[x]); } /// \u0026lt;summary\u0026gt; /// 最大的键。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最大的键。\u0026lt;/returns\u0026gt; public TKey Max() { if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;BST is Empty!\u0026#34;); } return _nodes[Max(_root)].Key; } /// \u0026lt;summary\u0026gt; /// 在二叉查找树中查找包含最大键的结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;二叉查找树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;包含最大键的结点。\u0026lt;/returns\u0026gt; private int Max(int x) { if (_right[x] == -1) { return x; } return Max(_right[x]); } /// \u0026lt;summary\u0026gt; /// 小于等于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的最大值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;小于等于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的最大值。\u0026lt;/returns\u0026gt; public TKey Floor(TKey key) { if (key == null) { throw new ArgumentNullException(\u0026#34;argument to floor is null\u0026#34;); } if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;calls floor with empty symbol table\u0026#34;); } var x = Floor(_root, key); if (x == -1) { return default; } else { return _nodes[x].Key; } } /// \u0026lt;summary\u0026gt; /// 获得符号表中小于等于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的最大结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;二叉查找树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;小于等于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的最大结点。\u0026lt;/returns\u0026gt; private int Floor(int x, TKey key) { if (x == -1) { return -1; } var cmp = key.CompareTo(_nodes[x].Key); if (cmp == 0) { return x; } else if (cmp \u0026lt; 0) { return Floor(_left[x], key); } var t = Floor(_right[x], key); if (t != -1) { return t; } return x; } /// \u0026lt;summary\u0026gt; /// 大于等于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的最小值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;大于等于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的最小值。\u0026lt;/returns\u0026gt; public TKey Ceiling(TKey key) { if (key == null) { throw new ArgumentNullException(\u0026#34;argument to ceiling is null\u0026#34;); } if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;calls ceiling with empty symbol table\u0026#34;); } var x = Ceiling(_root, key); if (x == -1) { return default; } return _nodes[x].Key; } /// \u0026lt;summary\u0026gt; /// 获取符号表中大于等于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的最小结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;二叉查找树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;符号表中大于等于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的最小结点。\u0026lt;/returns\u0026gt; private int Ceiling(int x, TKey key) { if (x == -1) { return -1; } var cmp = key.CompareTo(_nodes[x].Key); if (cmp == 0) { return x; } if (cmp \u0026lt; 0) { var t = Ceiling(_left[x], key); if (t != -1) { return t; } return x; } return Ceiling(_right[x], key); } /// \u0026lt;summary\u0026gt; /// 小于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的键的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;小于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的键的数量。\u0026lt;/returns\u0026gt; public int Rank(TKey key) { if (key == null) { throw new ArgumentNullException(\u0026#34;argument to rank() is null\u0026#34;); } return Rank(_root, key); } /// \u0026lt;summary\u0026gt; /// 返回 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 在二叉查找树中的排名。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;二叉查找树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要查找排名的键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的排名。\u0026lt;/returns\u0026gt; private int Rank(int x, TKey key) { if (x == -1) { return 0; } var cmp = key.CompareTo(_nodes[x].Key); if (cmp \u0026lt; 0) { return Rank(_left[x], key); } else if (cmp \u0026gt; 0) { return 1 + Size(_left[x]) + Rank(_right[x], key); } else { return Size(_left[x]); } } /// \u0026lt;summary\u0026gt; /// 获得排名为 k 的键。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要获得的键的排名。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;排名为 k 的键。\u0026lt;/returns\u0026gt; public TKey Select(int k) { if (k \u0026lt; 0 || k \u0026gt;= Size()) { throw new ArgumentException(\u0026#34;argument to select() is invaild: \u0026#34; + k); } var x = Select(_root, k); return _nodes[x].Key; } /// \u0026lt;summary\u0026gt; /// 挑拣出排名为 \u0026lt;paramref name=\u0026#34;k\u0026#34;/\u0026gt; 的结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;要挑拣的排名。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;排名为 \u0026lt;paramref name=\u0026#34;k\u0026#34;/\u0026gt; 的结点。\u0026lt;/returns\u0026gt; private int Select(int x, int k) { if (x == -1) { return -1; } var t = Size(_left[x]); if (t \u0026gt; k) { return Select(_left[x], k); } else if (t \u0026lt; k) { return Select(_right[x], k - t - 1); } else { return x; } } /// \u0026lt;summary\u0026gt; /// 删除最小的键。 /// \u0026lt;/summary\u0026gt; public void DeleteMin() { if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;Symbol table underflow\u0026#34;); } var minIndex = Min(_root); _root = DeleteMin(_root); RemoveNode(minIndex); } /// \u0026lt;summary\u0026gt; /// 在以 \u0026lt;paramref name=\u0026#34;x\u0026#34;/\u0026gt; 为根结点的二叉查找树中删除最小结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;二叉查找树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;删除后的二叉查找树。\u0026lt;/returns\u0026gt; private int DeleteMin(int x) { if (_left[x] == -1) { return _right[x]; } _left[x] = DeleteMin(_left[x]); return x; } /// \u0026lt;summary\u0026gt; /// 删除最大的键。 /// \u0026lt;/summary\u0026gt; public void DeleteMax() { if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;Symbol table underflow\u0026#34;); } var maxIndex = Max(_root); _root = DeleteMax(_root); RemoveNode(maxIndex); } /// \u0026lt;summary\u0026gt; /// 从指定二叉查找树中删除最大结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;二叉查找树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;删除后的二叉查找树。\u0026lt;/returns\u0026gt; private int DeleteMax(int x) { if (_right[x] == -1) return _left[x]; _right[x] = DeleteMax(_right[x]); return x; } /// \u0026lt;summary\u0026gt; /// 删除下标为 \u0026lt;paramref name=\u0026#34;index\u0026#34;/\u0026gt; 的结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;要删除的结点下标。\u0026lt;/param\u0026gt; private void RemoveNode(int index) { _size--; // Remove Node  for (var i = index; i \u0026lt; _size; i++) { _nodes[i] = _nodes[i + 1]; _left[i] = _left[i + 1]; _right[i] = _right[i + 1]; } // Adjust Index  if (_root \u0026gt;= index) { _root--; } for (var i = 0; i \u0026lt; _size; i++) { if (_left[i] \u0026gt;= index) { _left[i]--; } if (_right[i] \u0026gt;= index) { _right[i]--; } } } 另请参阅 #  BinarySearchTree 库\n"},{"id":434,"href":"/3-2-42/","title":"3.2.42","section":"帮助","content":"3.2.42 #  解答 #  按照题意实现即可，关键点有两个：\n一是选择前驱的实现方式，只要选择左子树中的最大结点即可。\nif (_random.NextDouble() \u0026lt; 0.5) { x = Min(t.Right); x.Right = DeleteMin(t.Right); x.Left = t.Left; } else { x = Max(t.Left); x.Left = DeleteMax(t.Left); x.Right = t.Right; } 二是内部路径长度的计算方式，需要用层序遍历把所有结点的深度加起来。\nvar internalPath = 0; var nowLayer = new Queue\u0026lt;Node\u0026gt;(); var nextLayer = new Queue\u0026lt;Node\u0026gt;(); nextLayer.Enqueue(root); var depth = 0; while (nextLayer.Count \u0026gt; 0) { var temp = nowLayer; nowLayer = nextLayer; nextLayer = temp; while (nowLayer.Count \u0026gt; 0) { var node = nowLayer.Dequeue(); if (node.Left != null) { nextLayer.Enqueue(node.Left); } if (node.Right != null) { nextLayer.Enqueue(node.Right); } internalPath += depth; } depth++; } return internalPath; 结果如下：\n另请参阅 #  BinarySearchTree 库\n"},{"id":435,"href":"/3-2-43/","title":"3.2.43","section":"帮助","content":"3.2.43 #  解答 #  依照题意实现即可，put/get 大约 10 倍差距。\nMostFrequentlyKey 的实现：\npublic static TKey MostFrequentlyKey\u0026lt;TKey\u0026gt;(IST\u0026lt;TKey, int\u0026gt; st, TKey[] keys) { foreach (var s in keys) { if (st.Contains(s)) st.Put(s, st.Get(s) + 1); else st.Put(s, 1); } var max = keys[0]; foreach (var s in st.Keys()) if (st.Get(s) \u0026gt; st.Get(max)) max = s; return max; } 另请参阅 #  BinarySearchTree 库\n"},{"id":436,"href":"/3-2-44/","title":"3.2.44","section":"帮助","content":"3.2.44 #  解答 #  使用类似于 {% post_link 3-1-38 %} 的方法进行绘图，当 n=10000 时的结果如下：\n代码 #  绘图部分：\npublic void Draw(long[] data) { var panel = CreateGraphics(); var unitX = (float)ClientRectangle.Width / data.Length; var unitY = (float)ClientRectangle.Height / data.Max(); var accumulation = 0f; // f = float  for (var i = 0; i \u0026lt; data.Length; i++) { // Gray  panel.FillEllipse(Brushes.Gray, (i + 1) * unitX, ClientRectangle.Bottom - data[i] * unitY, 2, 2); // Red  panel.FillEllipse(Brushes.Red, (i + 1) * unitX, ClientRectangle.Bottom - accumulation / (i + 1) * unitY, 2, 2); accumulation += data[i]; } panel.DrawString($\u0026#34;n:{data.Length}\\nave:{accumulation / data.Length}\u0026#34;, SystemFonts.DefaultFont, Brushes.Red, 0, 0); } 测试部分：\nprivate long[] Test(int n) { var testCases = new long[n]; var testResult = new long[n]; for (var i = 0; i \u0026lt; n; i++) { testCases[i] = i; } Shuffle(testCases); var bst = new BSTAnalysis\u0026lt;long, int\u0026gt;(); for (var i = 0; i \u0026lt; n; i++) { bst.CompareTimes = 0; bst.Put(testCases[i], 1); testResult[i] = bst.CompareTimes; } return testResult; } static void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } 另请参阅 #  BinarySearchTree 库\n"},{"id":437,"href":"/3-2-45/","title":"3.2.45","section":"帮助","content":"3.2.45 #  解答 #  结果如下，可参考 {% post_link 3-1-39 %}。\nSequentialSearchST\nBinarySearchST\nBST\n可以看到 BST 的曲线更为平滑，插入和查找部分耗时十分接近。\n另请参阅 #  BinarySearchTree 库\n"},{"id":438,"href":"/3-2-46/","title":"3.2.46","section":"帮助","content":"3.2.46 #  解答 #  翻译有些问题，其实指的是用 N 个 double 构造一个 BST 和 BinarySearchST 的速度对比。\nGet 速度 BST 是不会比 BinarySearchST 快的。（$1.39\\lg N$\u0026gt;$\\lg N$）\n二叉搜索树一次查找平均需要 $1.39\\lg N$ 次比较，二分查找则是 $N/2$，于是可以求得开销：\n二叉查找树：$1.39 \\sum_{i=1}^{N-1} \\lg i=1.39 \\lg (N-1)!=1.39(N-1)\\lg(N-1)$。\n二分查找实现的符号表：$1/2+2/2+ \\cdots+(N-1)/2=N(N-1)/4$ 。\n令两式相等，可以求得快 10 倍，100 倍，1000 倍的 $N$ 值。\n例如快 10 倍的方程：\n$$\n13.9(N-1)\\lg(N-1)=N(N-1)/4 \\\n13.9\\lg (N-1)=N/4\n$$\n这是一个超越方程，可以简单用程序穷举出一个数值解。\nfor (var i = 0d; i \u0026lt; int.MaxValue; i++) { if (13.9 * Math.Log2(i - 1) \u0026lt; i / 4) { Console.WriteLine(i); return; } } 解得的三个 N 值分别为 499，7115，91651。\n除了基本的新元素赋值外，二叉树在插入时只需要进行比较即可。\n但二分查找实现的符号表还需要维持数组有序，需要额外的赋值操作。\n因此二分查找实现的符号表和二叉搜索树的开销如下：\n其中 Array 包含了比较和额外的赋值次数，Tree 只有比较次数。\n一般我们认为比较（Compare）和赋值（=）开销是一样的，但实际上比较会慢 6 倍左右（.net core 3.1），因此如果直接进行计时测试，可能得不出快 10 倍/100 倍/1000 倍的结果。\n另请参阅 #  BinarySearchTree 库\n"},{"id":439,"href":"/3-2-47/","title":"3.2.47","section":"帮助","content":"3.2.47 #  解答 #  如下图所示，内部路径平均长度是比较符合规律的：\n方差：\n代码 #  一次测试：\nprivate int Test(int n) { var data = GetRandomInt(n); var bst = new BST\u0026lt;int, int\u0026gt;(); foreach (var d in data) { bst.Put(d, d); } return bst.AverageInternalPathLength(); } 求解内部路径长度：\npublic int AverageInternalPathLength() =\u0026gt; InternalPath() / Size() + 1; private int InternalPath() { var internalPath = 0; var nowLayer = new Queue\u0026lt;Node\u0026gt;(); var nextLayer = new Queue\u0026lt;Node\u0026gt;(); nextLayer.Enqueue(root); var depth = 0; while (nextLayer.Count \u0026gt; 0) { var temp = nowLayer; nowLayer = nextLayer; nextLayer = temp; while (nowLayer.Count \u0026gt; 0) { var node = nowLayer.Dequeue(); if (node.Left != null) { nextLayer.Enqueue(node.Left); } if (node.Right != null) { nextLayer.Enqueue(node.Right); } internalPath += depth; } depth++; } return internalPath; } 另请参阅 #  BinarySearchTree 库\n"},{"id":440,"href":"/3-3-1/","title":"3.3.1","section":"帮助","content":"3.3.1 #  解答 #  结果如下：\nE AE |--E--| A S |--E--| A SY |--ES--| A Q Y |--ES--| A Q UY |--------S--------| |--E--| |--U--| A Q T Y |--------S--------| |--E--| |--U--| A IQ T Y |--------S--------| |--EO--| |--U--| A I Q T Y |--------S--------| |--EO--| |--U--| A IN Q T Y 代码 #  2-3 树的实现\nusing System; using System.Collections.Generic; using System.Linq; using System.Text; // ReSharper disable CognitiveComplexity  namespace BalancedSearchTree { /// \u0026lt;summary\u0026gt;  /// 2-3 树。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;TKey\u0026#34;\u0026gt;键。\u0026lt;/typeparam\u0026gt;  /// \u0026lt;typeparam name=\u0026#34;TValue\u0026#34;\u0026gt;值。\u0026lt;/typeparam\u0026gt;  public class TwoThreeBst\u0026lt;TKey, TValue\u0026gt; : IOrderedSt\u0026lt;TKey, TValue\u0026gt; where TKey : IComparable\u0026lt;TKey\u0026gt; { private int _count; private Node _root; /// \u0026lt;inheritdoc /\u0026gt;  public void Put(TKey key, TValue value) { if (_root == null) { _root = new Node(null); _root.AddPair(key, value); return; } var (ends, current, _) = Get(null, _root, key); if (current != null) throw new InvalidOperationException($\u0026#34;The Key {key} has already been added\u0026#34;); ends.AddPair(key, value); _root = BalanceBottomUp(ends); _count++; } /// \u0026lt;inheritdoc /\u0026gt;  public TValue Get(TKey key) { if (_root == null) return default; var (_, node, index) = Get(null, _root, key); if (node == null) return default; return node.Contents[index].Value; } /// \u0026lt;inheritdoc /\u0026gt;  public void Delete(TKey key) { var (parent, node, index) = Get(null, _root, key); if (node == null) { throw new InvalidOperationException(\u0026#34;trying to delete a key not exists\u0026#34;); } var pairToRemove = node.Contents[index]; if (node.IsLeaf()) { if (parent == null) { // root node  node.Contents.Remove(pairToRemove); if (node.Contents.Count == 0) { _root = null; } _count--; return; } if (node.Degree == 2) { // node is 2-node, make it 3 or 4  // find sibling  Node sibling; if (node == parent.Left) { sibling = parent.Children[1]; } else if (node == parent.Right) { sibling = parent.Children[^2]; } else { sibling = parent.Left.Degree \u0026gt; parent.Right.Degree ? parent.Left : parent.Right; } if (sibling.Degree == 2) { node = Merge(node, sibling); } else { node = Redistribution(node, sibling); } } // now node is not 2-node, direct remove  node.Contents.Remove(pairToRemove); // all children is null, just delete last one  node.Children.RemoveAt(node.Degree - 1); _count--; return; } var min = Min(node.Right); var t = node.Contents[index]; node.Contents[index] = min.Contents[0]; min.Contents[0] = t; node.Right = DeleteMin(node.Right); _count--; } /// \u0026lt;inheritdoc /\u0026gt;  public bool Contains(TKey key) { return Get(null, _root, key).Node != null; } /// \u0026lt;inheritdoc /\u0026gt;  public bool IsEmpty() { return _root == null; } /// \u0026lt;inheritdoc /\u0026gt;  public int Size() { return _count; } private int Size(Node x) { if (x == null) { return 0; } if (x.Degree == 2) { return 1 + Size(x.Left) + Size(x.Right); } return 2 + Size(x.Left) + Size(x.Middle) + Size(x.Right); } /// \u0026lt;inheritdoc /\u0026gt;  public IEnumerable\u0026lt;TKey\u0026gt; Keys() { if (IsEmpty()) { return new List\u0026lt;TKey\u0026gt;(); } return Keys(Min(), Max()); } /// \u0026lt;inheritdoc /\u0026gt;  public int Size(TKey lo, TKey hi) { if (lo == null) { throw new ArgumentNullException(nameof(lo), \u0026#34;first argument to Size() is null\u0026#34;); } if (hi == null) { throw new ArgumentNullException(nameof(hi), \u0026#34;second argument to Size() is null\u0026#34;); } if (lo.CompareTo(hi) \u0026gt; 0) { return 0; } if (Contains(hi)) { return Rank(hi) - Rank(lo) + 1; } return Rank(hi) - Rank(lo); } /// \u0026lt;inheritdoc /\u0026gt;  public IEnumerable\u0026lt;TKey\u0026gt; Keys(TKey lo, TKey hi) { if (lo == null) { throw new ArgumentNullException(nameof(lo), \u0026#34;first argument to Keys() is null\u0026#34;); } if (hi == null) { throw new ArgumentNullException(nameof(hi), \u0026#34;second argument to Keys() is null\u0026#34;); } var queue = new Queue\u0026lt;TKey\u0026gt;(); Keys(_root, queue, lo, hi); return queue; } private void Keys(Node x, Queue\u0026lt;TKey\u0026gt; queue, TKey lo, TKey hi) { if (x == null) { return; } var cmpLo = lo.CompareTo(x.Contents[0].Key); var cmpHi = hi.CompareTo(x.Contents[0].Key); if (cmpLo \u0026lt; 0) { Keys(x.Left, queue, lo, hi); } if (cmpLo \u0026lt;= 0 \u0026amp;\u0026amp; cmpHi \u0026gt;= 0) { queue.Enqueue(x.Contents[0].Key); } if (cmpHi \u0026gt; 0) { Keys(x.Children[1], queue, lo, hi); } // 3-node extra  if (x.Children.Count == 3) { cmpLo = lo.CompareTo(x.Contents[1].Key); cmpHi = hi.CompareTo(x.Contents[1].Key); if (cmpLo \u0026lt; 0) { Keys(x.Middle, queue, lo, hi); } if (cmpLo \u0026lt;= 0 \u0026amp;\u0026amp; cmpHi \u0026gt;= 0) { queue.Enqueue(x.Contents[1].Key); } if (cmpHi \u0026gt; 0) { Keys(x.Right, queue, lo, hi); } } } /// \u0026lt;inheritdoc /\u0026gt;  public TKey Min() { if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;BST is empty\u0026#34;); } return Min(_root).Contents[0].Key; } private Node Min(Node h) { if (h.Left == null) { return h; } return Min(h.Left); } /// \u0026lt;inheritdoc /\u0026gt;  public TKey Max() { if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;BST is empty\u0026#34;); } return Max(_root).Contents[^1].Key; } private Node Max(Node h) { if (h.Right == null) { return h; } return Max(h.Right); } /// \u0026lt;inheritdoc /\u0026gt;  public TKey Floor(TKey key) { if (key == null) { throw new ArgumentNullException(nameof(key), \u0026#34;argument to Floor() is null\u0026#34;); } if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;calls Floor() with empty symbol table\u0026#34;); } var x = Floor(_root, key); if (x == null) { throw new InvalidOperationException(\u0026#34;argument to Floor() is too small\u0026#34;); } return x.Contents[0].Key; } private Node Floor(Node x, TKey key) { if (x == null) { return null; } var cmp = key.CompareTo(x.Contents[0].Key); if (cmp == 0) { return x; } if (cmp \u0026lt; 0) { return Floor(x.Left, key); } if (x.Degree == 3) { cmp = key.CompareTo(x.Contents[1].Key); if (cmp == 0) { return x; } if (cmp \u0026lt; 0) { return Floor(x.Middle, key); } } var t = Floor(x.Right, key); if (t != null) { return t; } return x; } /// \u0026lt;inheritdoc /\u0026gt;  public TKey Ceiling(TKey key) { if (key == null) { throw new ArgumentNullException(nameof(key), \u0026#34;argument to Ceiling() is null\u0026#34;); } if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;calls Ceiling with empty symbol table\u0026#34;); } var x = Ceiling(_root, key); if (x == null) { throw new InvalidOperationException(\u0026#34;argument to Ceiling is too small\u0026#34;); } return x.Contents[^1].Key; } private Node Ceiling(Node x, TKey key) { if (x == null) { return null; } var cmp = key.CompareTo(x.Contents[0].Key); if (cmp == 0) { return x; } if (cmp \u0026gt; 0) { return Ceiling(x.Right, key); } if (x.Degree == 3) { cmp = key.CompareTo(x.Contents[1].Key); if (cmp == 0) { return x; } if (cmp \u0026gt; 0) { return Ceiling(x.Right, key); } } var t = Ceiling(x.Left, key); if (t != null) { return t; } return x; } /// \u0026lt;inheritdoc /\u0026gt;  public int Rank(TKey key) { if (key == null) { throw new ArgumentNullException(nameof(key), \u0026#34;argument to Rank() is null\u0026#34;); } return Rank(_root, key); } private int Rank(Node x, TKey key) { if (x == null) { return 0; } var cmp = key.CompareTo(x.Contents[0].Key); if (cmp \u0026lt; 0) { return Rank(x.Left, key); } if (cmp \u0026gt; 0) { if (x.Degree == 2) { return 1 + Size(x.Left) + Rank(x.Right, key); } cmp = key.CompareTo(x.Contents[1].Key); if (cmp \u0026lt; 0) { return 1 + Size(x.Left) + Rank(x.Right, key); } if (cmp \u0026gt; 0) { return 1 + Size(x.Left) + Size(x.Middle) + Rank(x.Right, key); } return Size(x.Left) + Size(x.Middle); } return Size(x.Left); } /// \u0026lt;inheritdoc /\u0026gt;  public TKey Select(int k) { if (k \u0026lt; 0 || k \u0026gt;= Size()) { throw new ArgumentOutOfRangeException(nameof(k), \u0026#34;argument to Select() is invalid \u0026#34; + k); } return Select(_root, k); } private TKey Select(Node x, int rank) { if (x == null) { return default; } var leftSize = Size(x.Left); if (leftSize \u0026gt; rank) { return Select(x.Left, rank); } if (leftSize \u0026lt; rank) { if (x.Degree == 3) { leftSize += Size(x.Middle); if (leftSize \u0026gt; rank) { return Select(x.Middle, rank - leftSize - 1); } if (leftSize == rank) { return x.Contents[1].Key; } } return Select(x.Right, rank - leftSize - 1); } return x.Contents[0].Key; } /// \u0026lt;inheritdoc /\u0026gt;  public void DeleteMin() { if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;BST underflow\u0026#34;); } _root = DeleteMin(_root); } private Node DeleteMin(Node x) { if (x.Left == null) { // remove left key  x.Contents.RemoveAt(0); x.Children.RemoveAt(0); return BalanceBottomUp(x); } if (x.Left.Degree != 2) { // left child is not 2-node, do nothing and turn left  return DeleteMin(x.Left); } if (x.Children[1].Degree \u0026gt; 2) { // sibling is not 2-node, borrow one key into left  // get key from parent  x.Left.AddPair(x.Contents[0]); // parent get key from sibling  x.Contents.RemoveAt(0); x.Contents.Insert(0, x.Children[1].Contents[0]); // sibling delete min key  x.Children[1].Contents.RemoveAt(0); // move sibling\u0026#39;s child to left\u0026#39;s child  x.Left.Children.Add(x.Children[1].Left); x.Children[1].Children.RemoveAt(0); return DeleteMin(x.Left); } // sibling is 2-node, merge them into 3-node  if (x.Degree == 2) { // current node and its children are all 2-node  x.AddPair(x.Left.Contents[0]); x.AddPair(x.Right.Contents[0]); x.Left.Children.ForEach(c =\u0026gt; c.Parent = x); x.Right.Children.ForEach(c =\u0026gt; c.Parent = x); var t = x.Left; x.Left = t.Left; x.MiddleLeft = t.Right; t = x.Right; x.MiddleRight = t.Left; x.Right = t.Right; return DeleteMin(x); } x.Left.AddPair(x.Contents[0]); x.Contents.RemoveAt(0); x.Left.AddPair(x.Children[1].Contents[0]); x.Left.MiddleRight = x.Children[1].Left; x.Left.Right = x.Children[1].Right; x.Children.RemoveAt(1); return DeleteMin(x.Left); } /// \u0026lt;inheritdoc /\u0026gt;  public void DeleteMax() { if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;BST is empty\u0026#34;); } _root = DeleteMax(_root); } private Node DeleteMax(Node x) { if (x.Right == null) { // remove right key  x.Contents.RemoveAt(x.Contents.Count - 1); x.Children.RemoveAt(x.Degree - 1); return BalanceBottomUp(x); } if (x.Right.Degree != 2) { // left child is not 2-node, do nothing and turn left  return DeleteMax(x.Right); } if (x.Children[^2].Degree \u0026gt; 2) { // sibling is not 2-node, borrow one key into left  // get key from parent  x.Right.AddPair(x.Contents[^1]); // parent get key from sibling  x.Contents.RemoveAt(x.Contents.Count - 1); x.Contents.Insert(x.Contents.Count - 1, x.Children[^2].Contents[^1]); // sibling delete max key  x.Children[^2].Contents.RemoveAt(x.Children[^2].Contents.Count - 1); // move sibling\u0026#39;s child to right\u0026#39;s child  x.Right.Children.Add(x.Children[^2].Right); x.Children[^2].Children.RemoveAt(x.Children[^2].Degree - 1); return DeleteMax(x.Right); } // sibling is 2-node, merge them into 3-node  if (x.Degree == 2) { // current node and its children are all 2-node  x.AddPair(x.Left.Contents[0]); x.AddPair(x.Right.Contents[0]); x.Left.Children.ForEach(c =\u0026gt; c.Parent = x); x.Right.Children.ForEach(c =\u0026gt; c.Parent = x); var t = x.Left; x.Left = t.Left; x.MiddleLeft = t.Right; t = x.Right; x.MiddleRight = t.Left; x.Right = t.Right; return DeleteMax(x); } x.Right.AddPair(x.Contents[^1]); x.Contents.RemoveAt(x.Contents.Count - 1); x.Right.AddPair(x.Children[^2].Contents[^1]); x.Left.MiddleRight = x.Children[^2].Left; x.Left.Right = x.Children[^2].Right; x.Children.RemoveAt(x.Degree - 2); return DeleteMax(x.Right); } public override string ToString() { if (IsEmpty()) { return string.Empty; } var maxDepth = Depth(_root); var layer = 0; var bottomLine = (int)Math.Pow(3, maxDepth) * 2; // BFS  var lines = new List\u0026lt;string\u0026gt;(); var nowLayer = new Queue\u0026lt;Node\u0026gt;(); var nextLayer = new Queue\u0026lt;Node\u0026gt;(); nextLayer.Enqueue(_root); while (layer != maxDepth) { var sb = new StringBuilder(); var unitSize = bottomLine / (int)Math.Pow(3, layer); var temp = nowLayer; nowLayer = nextLayer; nextLayer = temp; while (nowLayer.Count != 0) { var x = nowLayer.Dequeue(); if (x != null) { nextLayer.Enqueue(x.Left); if (x.Degree == 3) nextLayer.Enqueue(x.Middle); else nextLayer.Enqueue(null); nextLayer.Enqueue(x.Right); } else { nextLayer.Enqueue(null); nextLayer.Enqueue(null); nextLayer.Enqueue(null); } if (x != null \u0026amp;\u0026amp; x.Left != null) { for (var i = 0; i \u0026lt; unitSize / 6; i++) sb.Append(\u0026#34; \u0026#34;); sb.Append(\u0026#34;|\u0026#34;); for (var i = 1; i \u0026lt; unitSize / 6; i++) sb.Append(\u0026#34;-\u0026#34;); } else { for (var i = 0; i \u0026lt; unitSize / 3; i++) sb.Append(\u0026#34; \u0026#34;); } if (x == null) sb.Append(\u0026#34; \u0026#34;); else sb.Append(x.Contents.Aggregate(string.Empty, (s, n) =\u0026gt; s + n.Key)); if (x != null \u0026amp;\u0026amp; x.Right != null) { for (var i = 1; i \u0026lt; unitSize / 6; i++) sb.Append(\u0026#34;-\u0026#34;); sb.Append(\u0026#34;|\u0026#34;); for (var i = 1; i \u0026lt; unitSize / 6; i++) sb.Append(\u0026#34; \u0026#34;); } else { for (var i = 1; i \u0026lt; unitSize / 3; i++) sb.Append(\u0026#34; \u0026#34;); } } lines.Add(sb.ToString()); layer++; } // Trim  var margin = int.MaxValue; foreach (var line in lines) { var firstNonWhite = 0; for (var i = 0; i \u0026lt; line.Length; i++) { if (line[i] == \u0026#39; \u0026#39;) continue; firstNonWhite = i; break; } margin = Math.Min(margin, firstNonWhite); } for (var i = 0; i \u0026lt; lines.Count; i++) { lines[i] = lines[i].Substring(margin); } var result = new StringBuilder(); foreach (var line in lines) { result.AppendLine(line); } return result.ToString(); } /// \u0026lt;summary\u0026gt;  /// 获取 2-3 树的最大深度。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;二叉树的根结点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;二叉树的最大深度。\u0026lt;/returns\u0026gt;  private int Depth(Node x) { if (x == null) return 0; if (x.Degree == 2) return 1 + Math.Max(Depth(x.Left), Depth(x.Right)); return 1 + Math.Max(Depth(x.Left), Math.Max(Depth(x.Middle), Depth(x.Right))); } /// \u0026lt;summary\u0026gt;  /// 自底向上对 2-3 树进行平衡。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;node\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  private static Node BalanceBottomUp(Node node) { if (node.Degree != 4) { // not 4-node  return node.Parent == null ? node : BalanceBottomUp(node.Parent); } // break 4-node into 2 2-node  var left = new Node(node.Parent); left.AddPair(node.Contents[0]); left.Left = node.Left; left.Right = node.MiddleLeft; var right = new Node(node.Parent); right.AddPair(node.Contents[2]); right.Left = node.MiddleRight; right.Right = node.Right; if (node.Parent == null) { // root is 4-node  var root = new Node(null); root.AddPair(node.Contents[1]); root.Left = left; root.Right = right; left.Parent = root; right.Parent = root; return root; } node.Parent.AddPair(node.Contents[1]); if (node.Parent.Degree == 3) { // parent was 2-node  if (node == node.Parent.Children[0]) { // 4-node is 2-node\u0026#39;s left child  node.Parent.Left = left; node.Parent.Middle = right; } else { // 4-node is 2-node\u0026#39;s right child  node.Parent.Middle = left; node.Parent.Right = right; } return BalanceBottomUp(node.Parent); } // parent was 3-node  if (node == node.Parent.Children[0]) { // 4-node is 3-node\u0026#39;s left child  node.Parent.Left = left; node.Parent.MiddleLeft = right; } else if (node == node.Parent.Children[1]) { // 4-node is 3-node\u0026#39;s middle child  node.Parent.MiddleLeft = left; node.Parent.MiddleRight = right; } else { // 4-node is 3-node\u0026#39;s right child  node.Parent.MiddleRight = left; node.Parent.Right = right; } return BalanceBottomUp(node.Parent); } /// \u0026lt;summary\u0026gt;  /// 在 2-3 树中搜索 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt;。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;parent\u0026#34;\u0026gt;父结点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;current\u0026#34;\u0026gt;当前结点\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要搜索的键。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;父结点、当前结点和键的下标。\u0026lt;/returns\u0026gt;  private static (Node Parent, Node Node, int Index) Get(Node parent, Node current, TKey key) { if (current == null) return (parent, null, -1); for (var i = 0; i \u0026lt; current.Contents.Count; i++) { var pair = current.Contents[i]; var cmp = key.CompareTo(pair.Key); if (cmp == 0) return (parent, current, i); if (cmp \u0026lt; 0) return Get(current, current.Children[i], key); } // larger to all keys, turn right  return Get(current, current.Children[^1], key); } /// \u0026lt;summary\u0026gt;  /// 将两个结点合并。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;y\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  /// \u0026lt;exception cref=\u0026#34;InvalidOperationException\u0026#34;\u0026gt;\u0026lt;/exception\u0026gt;  private static Node Merge(Node x, Node y) { if (x.Degree != 2 || y.Degree != 2) { throw new InvalidOperationException(\u0026#34;x and y must all be 2-node to merge\u0026#34;); } if (x.Parent != y.Parent) { throw new InvalidOperationException(\u0026#34;two nodes must be siblings to perform merge\u0026#34;); } var parent = x.Parent; if (parent.Degree == 2) { parent.AddPair(x.Contents[0]); parent.AddPair(y.Contents[0]); parent.Left = x.Left; parent.MiddleLeft = x.Right; parent.MiddleRight = y.Left; parent.Right = y.Right; return parent; } if (x == parent.Left || y == parent.Left) { // merge middle to left  x = parent.Left; y = parent.Middle; x.AddPair(parent.Contents[0]); x.AddPair(y.Contents[0]); x.MiddleRight = y.Left; x.Right = y.Right; parent.Contents.RemoveAt(0); parent.Children.Remove(y); return parent; } // merge middle to right  x = parent.Middle; y = parent.Right; y.AddPair(parent.Contents[^1]); y.AddPair(x.Contents[0]); y.Left = x.Left; y.MiddleLeft = x.Right; parent.Contents.RemoveAt(parent.Contents.Count - 1); parent.Children.Remove(x); return parent; } /// \u0026lt;summary\u0026gt;  /// 合并兄弟结点。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;node\u0026#34;\u0026gt;结点。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;sibling\u0026#34;\u0026gt;\u0026lt;paramref name=\u0026#34;node\u0026#34;/\u0026gt; 的兄弟结点。\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  /// \u0026lt;exception cref=\u0026#34;InvalidOperationException\u0026#34;\u0026gt;\u0026lt;/exception\u0026gt;  private static Node Redistribution(Node node, Node sibling) { if (node.Degree != 2 || sibling.Degree == 2) { throw new InvalidOperationException(\u0026#34;node must be 2-node and sibling must not be 2-node\u0026#34;); } if (node.Parent != sibling.Parent) { throw new InvalidOperationException(\u0026#34;two nodes must be siblings to perform merge\u0026#34;); } var parent = node.Parent; if (node == parent.Left) { // flow to left  node.AddPair(parent.Contents[0]); node.Right = sibling.Left; parent.Contents[0] = sibling.Contents[0]; sibling.Contents.RemoveAt(0); sibling.Children.RemoveAt(0); } else if (node == parent.Right) { // flow to right  node.AddPair(parent.Contents[^1]); node.Left = sibling.Right; parent.Contents[^1] = sibling.Contents[^1]; sibling.Contents.RemoveAt(sibling.Contents.Count - 1); sibling.Children.RemoveAt(sibling.Children.Count - 1); } else { // flow to middle  if (sibling == parent.Left) { node.AddPair(parent.Contents[0]); parent.Contents[0] = sibling.Contents[^1]; node.Children[0] = sibling.Right; sibling.Contents.RemoveAt(sibling.Contents.Count - 1); sibling.Children.RemoveAt(sibling.Children.Count - 1); } else { node.AddPair(parent.Contents[^1]); parent.Contents[^1] = sibling.Contents[0]; node.Children[^1] = sibling.Left; sibling.Contents.RemoveAt(0); sibling.Children.RemoveAt(0); } } return node; } /// \u0026lt;summary\u0026gt;  /// 2-3 树结点。  /// \u0026lt;/summary\u0026gt;  private class Node { /// \u0026lt;summary\u0026gt;  /// 构造一个空的 2-3 树结点，并设置父结点。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;parent\u0026#34;\u0026gt;父结点。\u0026lt;/param\u0026gt;  public Node(Node parent) { Parent = parent; } /// \u0026lt;summary\u0026gt;  /// 父结点。  /// \u0026lt;/summary\u0026gt;  public Node Parent { get; set; } /// \u0026lt;summary\u0026gt;  /// 结点保存的键值对。  /// \u0026lt;/summary\u0026gt;  public List\u0026lt;Pair\u0026gt; Contents { get; } = new(); /// \u0026lt;summary\u0026gt;  /// 结点的子结点。  /// \u0026lt;/summary\u0026gt;  public List\u0026lt;Node\u0026gt; Children { get; } = new() { null }; /// \u0026lt;summary\u0026gt;  /// 结点的度，例如 2-结点返回的就是 2。  /// \u0026lt;/summary\u0026gt;  public int Degree =\u0026gt; Children.Count; /// \u0026lt;summary\u0026gt;  /// 左子结点。  /// \u0026lt;/summary\u0026gt;  public Node Left { get =\u0026gt; Children[0]; set { if (value != null) value.Parent = this; Children[0] = value; } } /// \u0026lt;summary\u0026gt;  /// 第二个子结点，只有当 \u0026lt;see cref=\u0026#34;Degree\u0026#34;/\u0026gt; 是 4 时才可以访问这个属性。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;exception cref=\u0026#34;InvalidOperationException\u0026#34;\u0026gt;\u0026lt;see cref=\u0026#34;Degree\u0026#34;/\u0026gt; 不为 4。\u0026lt;/exception\u0026gt;  public Node MiddleLeft { get =\u0026gt; Degree == 4 ? Children[1] : throw new InvalidOperationException(\u0026#34;only 4-node has middle left\u0026#34;); set { if (value != null) value.Parent = this; Children[1] = value; } } /// \u0026lt;summary\u0026gt;  /// 位于中间的子结点，只有当 \u0026lt;see cref=\u0026#34;Degree\u0026#34;/\u0026gt; 为 3 时才可以访问这个属性。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;exception cref=\u0026#34;InvalidOperationException\u0026#34;\u0026gt;\u0026lt;see cref=\u0026#34;Degree\u0026#34;/\u0026gt; 不为 3。\u0026lt;/exception\u0026gt;  public Node Middle { get =\u0026gt; Degree == 3 ? Children[1] : throw new InvalidOperationException(\u0026#34;only 3-node has middle\u0026#34;); set { if (value != null) value.Parent = this; Children[1] = value; } } /// \u0026lt;summary\u0026gt;  /// 第三个子结点，只有当 \u0026lt;see cref=\u0026#34;Degree\u0026#34;/\u0026gt; 是 4 时才可以访问这个属性。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;exception cref=\u0026#34;InvalidOperationException\u0026#34;\u0026gt;\u0026lt;see cref=\u0026#34;Degree\u0026#34;/\u0026gt; 不为 4。\u0026lt;/exception\u0026gt;  public Node MiddleRight { get =\u0026gt; Degree == 4 ? Children[2] : throw new InvalidOperationException(\u0026#34;only 4-node has middle right\u0026#34;); set { if (value != null) value.Parent = this; Children[2] = value; } } /// \u0026lt;summary\u0026gt;  /// 右子结点。  /// \u0026lt;/summary\u0026gt;  public Node Right { // ^1 即最后一个，与 Children.Count - 1 等同。  get =\u0026gt; Children[^1]; set { if (value != null) value.Parent = this; Children[^1] = value; } } /// \u0026lt;summary\u0026gt;  /// 向结点添加一个键值对。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;值。\u0026lt;/param\u0026gt;  public void AddPair(TKey key, TValue value) { var pair = new Pair(key, value); AddPair(pair); } /// \u0026lt;summary\u0026gt;  /// 向结点添加一个键值对。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;pair\u0026#34;\u0026gt;键值对。\u0026lt;/param\u0026gt;  public void AddPair(Pair pair) { for (var i = 0; i \u0026lt; Contents.Count; i++) { var cmp = pair.Key.CompareTo(Contents[i].Key); if (cmp \u0026lt; 0) { Contents.Insert(i, pair); Children.Insert(i + 1, null); return; } } Contents.Add(pair); Children.Add(null); } /// \u0026lt;summary\u0026gt;  /// 结点是否为叶结点（没有子结点）。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsLeaf() { return Children.All(c =\u0026gt; c == null); } /// \u0026lt;summary\u0026gt;  /// 拼接并输出结点的键。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public override string ToString() { return Contents.Aggregate(string.Empty, (s, k) =\u0026gt; s + k.Key); } } /// \u0026lt;summary\u0026gt;  /// 键值对。  /// \u0026lt;/summary\u0026gt;  private class Pair { /// \u0026lt;summary\u0026gt;  /// 新建一个键值对。  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;值。\u0026lt;/param\u0026gt;  public Pair(TKey key, TValue value) { Key = key; Value = value; } /// \u0026lt;summary\u0026gt;  /// 键。  /// \u0026lt;/summary\u0026gt;  public TKey Key { get; } /// \u0026lt;summary\u0026gt;  /// 值。  /// \u0026lt;/summary\u0026gt;  public TValue Value { get; } } } } 另请参阅 #  [BalancedSearchTree ](https://github.com/ikesnowy/Algorithms-4th-Edition-in-Csharp/tree/master/3 Searching/3.3/BalancedSearchTree)\n"},{"id":441,"href":"/3-3-2/","title":"3.3.2","section":"帮助","content":"3.3.2 #  解答 #  和 {% post_link 3-3-1 %} 类似，结果如下：\nY LY |--P--| L Y |--P--| LM Y |--P--| LM XY |--LP--| H M XY |--LP--| CH M XY |--------P--------| |--L--| |--X--| CH M R Y |--------P--------| |--CL--| |--X--| A H M R Y |--------P--------| |--CL--| |--X--| A EH M R Y |--------P--------| |--CL--| |--X--| A EH M RS Y 另请参阅 #  BalancedSearchTree 库\n"},{"id":442,"href":"/3-3-3/","title":"3.3.3","section":"帮助","content":"3.3.3 #  解答 #  题目给出的序列就可以，如下（只有根结点的 2-3 树的高度是 0，以此类推）：\nS ES |--E--| A S |--E--| AC S |--E--| AC HS |--ES--| AC H X |--ES--| AC HM X SEACHXM 排序后是 ACEHMSX，符合条件的一种情况即为 AC 为左子结点，HM 为中间结点，X 为右侧结点，ES 为根节点。\n也可以是其他的模式，总共有 2880 种符合条件的组合（result.txt），共三种模式，结果如下：\n864 |--CM--| A EH SX 1152 |--EM--| AC H SX 864 |--ES--| AC HM X 可以观察到树的形状是没有变化的，只是键在各结点中的分布有些变化。\n代码 #  using System; using System.IO; using BalancedSearchTree; var input = \u0026#34;ACEHMSX\u0026#34;; var output = File.CreateText(\u0026#34;result.txt\u0026#34;); var count = 0; Dig(input, string.Empty); Console.WriteLine(count); void Dig(string source, string testCase) { if (source.Length == 0) { var tree = new TwoThreeBst\u0026lt;char, int\u0026gt;(); foreach (var c in testCase) { tree.Put(c, 1); } if (tree.Height() == 1) { count++; output.WriteLine(testCase); output.WriteLine(tree.ToString()); output.WriteLine(); } } for (var i = 0; i \u0026lt; source.Length; i++) { Dig(source.Remove(i, 1), testCase + source[i]); } } 另请参阅 #  BalancedSearchTree 库\n"},{"id":443,"href":"/3-3-4/","title":"3.3.4","section":"帮助","content":"3.3.4 #  解答 #  一棵高度为 $h$ 的完美二叉树有：$1 + 2 + 2^2 + \u0026hellip; + 2^{h}= 2^{h+1} - 1$ 个结点，反向得到 $N$ 个结点的完美二叉树高度为 $\\log_2{(N+1)} -1$。\n一棵高度为 $h$ 的完美三叉树有：$1+3+3^2+\u0026hellip;+3^h= \\frac{3^{h+1} - 1}{2}$ 个结点，反向得到 $N$ 个结点的完美三叉树高度为 $\\log_3{(2N+1) - 1}$。\n由于 2-3 树本身介于完美二叉树和完美三叉树之间，$N$ 个结点的 2-3 树高度就会介于 $N$ 个结点的完美二叉树和完美三叉树之间，即：$\\sim\\lfloor log_3N \\rfloor \\le h \\le \\sim\\lfloor log_2{N} \\rfloor$。\n另请参阅 #  完美二叉树, 完全二叉树和完满二叉树 - veli - 博客园 (cnblogs.com)\n"},{"id":444,"href":"/3-3-5/","title":"3.3.5","section":"帮助","content":"3.3.5 #  解答 #   注：英文版原文使用的是 “ignore the order of the subtrees”，也就是忽略子树的顺序。\n 我们将 N=6 时的树形简记为 [{3}, {2, 2, 3}]，代表根结点是一个 3-结点，第二层有两个 2-结点和一个 3-结点。\n一个 N=6 的示例：\n// 'D', 'G', 'K', 'O', 'S', 'Y' |--GO--| D K SY 考虑插入元素的两种效用，一种是使 2-结点变成 3-结点（当前结点或者它的父结点）；另一种是使树高增加，被插入元素的 3-结点（及其父 3-结点）变回 2-结点。这两种操作的顺序不影响最后的树形。\n于是 N=7 时，我们有两种树形。\n[{3}, {2, 3, 3}]（插入到某个 2-结点）。\n// 'D', 'G', 'K', 'O', 'S', 'Y', 'L' // before |--GO--| D K SY // after |--GO--| D KL SY [{2}, {2, 2}, {2, 2, 2, 2}]（插入到 3-结点，变成满二叉树）。\n // 'D', 'G', 'K', 'O', 'S', 'Y', 'Q' // before |--GO--| D K SY // after |--------O--------| |--G--| |--S--| D K Q Y N=8，对于 N=7 时的第一种树形，如果向 3-结点插入，会触发树高增加，结果相当于向第二种满二叉树底层 2-结点中的某一个插入元素后的树形。向第一种树形的 2-结点插入则会变成一个全部由 3-结点构成的 2-3 树。\n 注：可以把这里插入到 2-结点的操作看作是插入到 3-结点的一种“拖延”，它只是延后了树高增加的变换，但对最后的树形没有影响。\n [{3}, {3, 3, 3}]（插入到唯一的 2-结点）\n// 'D', 'G', 'K', 'O', 'S', 'Y', 'L', 'A' // before |--GO--| D KL SY // after |--GO--| AD KL SY [{2}, {2, 2}, {2, 2, 2, 3}]（插入到满二叉树底部任意一个 2-结点）\n// 'D', 'G', 'K', 'O', 'S', 'Y', 'Q', 'Z' // before |--------O--------| |--G--| |--S--| D K Q Y // after |--------O--------| |--G--| |--S--| D K Q YZ N=9，和 N=8 时类似，对于 N=8 时的第一种树形，插入底层任意一个 3-结点都会触发平衡，等同于满二叉树底部两个 2-结点各插入一个元素的树形。考虑第二种树形最底层各结点插入元素后的树形即可。\n[{2}, {2, 2}, {2, 2, 3, 3}]（插入到 3-结点同侧 2-结点）\n// 'D', 'G', 'K', 'O', 'S', 'Y', 'L', 'A', 'C' // before |--GO--| AD KL SY // after |--------G--------| |--C--| |--O--| A D KL SY [{2}, {2, 2}, {2, 3, 2, 3}] （插入到 3-结点对侧 2-结点）\n// 'D', 'G', 'K', 'O', 'S', 'Y', 'L', 'A', 'J' // before |--GO--| AD KL SY // after |--------K--------| |--G--| |--O--| AD J L SY [{2}, {2, 3}, {2, 2, 2, 2, 2}]（插入到 3-结点）\n// 'D', 'G', 'K', 'O', 'S', 'Y', 'Q', 'Z', 'X' // before |--------O--------| |--G--| |--S--| D K Q YZ // after |--------O--------| |--G--| |--SY--| D K Q X Z N=10\n[{2}, {2, 2}, {2, 3, 3, 3}] （插入到 2-结点）\n// 'D', 'G', 'K', 'O', 'S', 'Y', 'L', 'A', 'C', 'B' // before |--------G--------| |--C--| |--O--| A D KL SY // after |--------G--------| |--C--| |--O--| AB D KL SY [{2}, {2, 3}, {2, 2, 2, 2, 3}]（插入到 3-结点下的 2-结点）\n// 'D', 'G', 'K', 'O', 'S', 'Y', 'Q', 'Z', 'X', 'P' // before |--------O--------| |--G--| |--SY--| D K Q X Z // after |--------O--------| |--G--| |--SY--| D K PQ X Z [{2}, {2, 3}, {2, 3, 2, 2, 2}]（插入到 2-结点下的 2-结点）\n// 'D', 'G', 'K', 'O', 'S', 'Y', 'Q', 'Z', 'X', 'J' // before |--------O--------| |--G--| |--SY--| D K Q X Z // after |--------O--------| |--G--| |--SY--| D JK Q X Z "},{"id":445,"href":"/thanks/","title":"特别感谢","section":"帮助","content":"代码避免不了 bug，题解也避免不了错误，感谢你们对于题解中问题的指出！\n（排名不分先后）\n@杨晗 ，1.3.49 等 。⬅ 他写了一份 Java 版的题解，做的比我多，点此进入\n第一章 #  @ljdhhp ，1.3.31 #539\n@ShuXin ，1.4.15 #321\n@雨碎江南 ，1.4.8，1.4.18 #437\n@张越 ，1.4.19\n@5ME，1.1.1 #592\n@Hao Liu, 公式渲染问题 #596, #594\n第二章 #  @雨碎江南 ，2.2.12 #532\n@cx666 , 2.2.12 #588\n@TianDao ，2.3.20 #587\n@wssb ，2.2.16，2.4.13\n@miyuexingchen ，2.4.6 #521\n@玉垒浮云 ，2.4.35 #590\n第三章 #  @雨碎江南 ，3.1.24 #538\n"},{"id":446,"href":"/run-solution-code/","title":"如何：运行题解代码","section":"帮助","content":"本文将介绍如何下载题解项目并运行代码。\n在开始之前，请确保你的电脑上已经安装了 Visual Studio 2015（及以上版本）并启用了 .NET Framework 4.7。\n下载 Visual Studio：https://visualstudio.microsoft.com/zh-hans/downloads/\n下载全部代码 #   点击这个链接，下载 GitHub Extension 并安装。 点击本页底部的 GitHub 图标，进入题解源代码页。 点击右上角的「Clone or Download」，选择「Open in Visual Studio」。\n 随后 Visual Studio 会自动打开（如果提示是否允许切换应用，请选择允许）。\n确保「以递归方式克隆子模块」被选中，点击「克隆」。\n 耐心等待克隆完毕，视网络情况，可能需要几分钟到十几分钟不等。 在解决方案资源管理器中，双击解决方案「Algorithms 4th Edition.sln」。\n 右键需要运行的项目，选择「设为启动项目」。\n 按快捷键「Ctrl」+「F5」运行代码。  下载部分代码 #  控制台应用程序 #   打开 Visual Studio，选择「文件」-「新建」-「项目」，或按「Ctrl」+「Shift」+「N」打开「新建项目」对话框。 在模板中选择「Visual C#」-「Windows 桌面」-「控制台应用」，输入项目名称和位置，点击「确定」。\n 这里以题 1.3.26 为例，点击本页底部的 GitHub 图标，进入题解源代码页。 依次选择文件夹「1-Fundamental」-「1.3」-「1.3.26」，找到所有后缀为 .cs 的文件。\n 点击「Program.cs」，随后右键点击「Raw」，选择「目标另存为」，下载代码文件。\n 依次对所有其他的 .cs 文件做相同操作，下载全部的代码文件。 在解决方案资源管理器中，右键点击项目名称（一般位于解决方案名称的下方），选择「在文件资源管理器中打开文件夹」。\n 将所有的代码文件复制到该目录下，如果存在重复则直接覆盖。 这时 Visual Studio 可能会提示文件被更改，选择「重新加载」即可。 再次右击项目名称，选择「添加」-「现有项」，或按快捷键「Shift」+「Alt」+「A」，在弹出的窗口中选择刚才复制的所有 .cs 文件。\n 此时，一些不需要依赖库的题目已经可运行，按快捷键「Ctrl」+「F5」即可运行代码，如果 Visual Studio 提示缺少指令集引用，请通过下面的步骤添加类库。 定位到开头的 using 指令部分，缺失的库文件会被红线标出。\n 右击解决方案资源管理器中的解决方案名称（一般在最上方），选择「添加」-「新建项目」。\n 在弹出的「新建项目」对话框中选择「Visual C#」-「Windows 桌面」-「类库」模板，项目名称与缺失的库名称相同。\n 接下来回到第 3 步中打开的网站，找到缺失的库，在本例中，依次点击「1-Fundamental」-「1.3」-「Generics」，利用第 5 步中的方法下载所有 .cs 文件。\n 回到 Visual Studio 中，在解决方案资源管理器中右键点击刚才新建的库名称（这里是 Generics），用第 10 步中的方法添加刚才下载的所有 .cs 文件。 右键点击题目项目中的「引用」，选择「添加引用」。\n 在弹出的「引用管理器」对话框中，勾选刚才新建的库项目，点击「确定」。\n 现在题目应该可运行，右键题目项目，选择「设为启动项目」，然后按快捷键「Ctrl」+「F5」运行。  Windows 窗体应用程序 #   打开 Visual Studio，选择「文件」-「新建」-「项目」，或按「Ctrl」+「Shift」+「N」打开「新建项目」对话框。 在模板中选择「Visual C#」-「Windows 桌面」-「Windows 窗体应用（.NET Framework）」，输入项目名称和位置，点击「确定」。\n 这里以题 1.1.31 为例，点击本页底部的 GitHub 图标，进入题解源代码页。 依次选择文件夹「1-Fundamental」-「1.1」-「1.1.31」，找到所有后缀为 .cs 和 .resx 的文件。\n 点击「Program.cs」，随后右键点击「Raw」，选择「目标另存为」，下载代码文件。\n 依次对所有其他的 .cs 以及 .resx 文件做相同操作，下载全部的代码文件。 在解决方案资源管理器中，右键点击项目名称（一般位于解决方案名称的下方），选择「在文件资源管理器中打开文件夹」。\n 将所有的代码文件复制到该目录下，如果存在重复则直接覆盖。 这时 Visual Studio 可能会提示文件被更改，选择「重新加载」即可。 再次右击项目名称，选择「添加」-「现有项」，或按快捷键「Shift」+「Alt」+「A」，在弹出的窗口中选择刚才复制的所有 .cs 文件（不用选择 .resx 文件，Visual Studio 会自动扫描添加）。\n 此时，一些不需要依赖库的题目已经可运行，按快捷键「Ctrl」+「F5」即可运行代码，如果 Visual Studio 提示缺少指令集引用，请参阅「控制台应用程序」中的第 12 步至第 19 步。  "}]