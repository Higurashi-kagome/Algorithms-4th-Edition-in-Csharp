<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Fundamental on 《算法（第四版）》C# 题解</title><link>https://alg4.ikesnowy.com/tags/fundamental/</link><description>Recent content in Fundamental on 《算法（第四版）》C# 题解</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 28 Jun 2018 13:50:42 +0000</lastBuildDate><atom:link href="https://alg4.ikesnowy.com/tags/fundamental/index.xml" rel="self" type="application/rss+xml"/><item><title>1.1.1</title><link>https://alg4.ikesnowy.com/1-1-1/</link><pubDate>Mon, 14 May 2018 19:01:25 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-1/</guid><description>1.1.1 # 解答 # a.7
b.200.0000002
c.True
代码 # static void Main(string[] args) { int a = (0 + 15) / 2; double b = 2.0e-6 * 100000000.1; bool c = true &amp;amp;&amp;amp; false || true &amp;amp;&amp;amp; true; Console.WriteLine($&amp;#34;a.{a}&amp;#34;); Console.WriteLine($&amp;#34;b.{b}&amp;#34;); Console.WriteLine($&amp;#34;c.{c}&amp;#34;); }</description></item><item><title>1.1.2</title><link>https://alg4.ikesnowy.com/1-1-2/</link><pubDate>Mon, 14 May 2018 19:21:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-2/</guid><description>1.1.2 # 解答 # Name Type Value a System.Double 1.618 b System.Double 10 c System.Boolean True d System.String 33 代码 # static void Main(string[] args) { //var 变量名 = 初始值 根据初始值自动判断变量类型 var a = (1 + 2.236) / 2; var b = 1 + 2 + 3 + 4.</description></item><item><title>1.1.3</title><link>https://alg4.ikesnowy.com/1-1-3/</link><pubDate>Mon, 14 May 2018 19:33:26 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-3/</guid><description>1.1.3 # 解答 # 简单的 if 判断即可。
代码 # static void Main(string[] args) { //Console.ReadLine() 从控制台读入一整行（返回int） //string.Split(char) 根据提供的分隔符将字符串分割，返回字符串数组 //Int32.Parse(string) 将字符串转换为相应的整型数据 string input = Console.ReadLine(); int a = Int32.Parse(input.Split(&amp;#39; &amp;#39;)[0]); int b = Int32.Parse(input.Split(&amp;#39; &amp;#39;)[1]); int c = Int32.Parse(input.Split(&amp;#39; &amp;#39;)[2]); //Console.WriteLine() 向控制台输出一行 if (a == b &amp;amp;&amp;amp; b == c) { Console.WriteLine(&amp;#34;equal&amp;#34;); } else { Console.</description></item><item><title>1.1.4</title><link>https://alg4.ikesnowy.com/1-1-4/</link><pubDate>Mon, 14 May 2018 19:35:43 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-4/</guid><description>1.1.4 # 解答 # a. if 后跟 then 的语法不能在 C# 中使用。
b. if 后的判断语句需要在括号内。
c. 正确，只有一条语句时大括号可以省略。
d. c = 0 后缺少分号。
代码 # static void Main(string[] args) { int a = 1; int b = 2; int c = 0; //if (a &amp;gt; b) then c = 0; //if 后不能跟 then //if a &amp;gt; b { c = 0; } //if后必须跟括号 if (a &amp;gt; b) c = 0; //正确 //if (a &amp;gt; b) c = 0 else b = 0; //c = 0后缺少分号 }</description></item><item><title>1.1.5</title><link>https://alg4.ikesnowy.com/1-1-5/</link><pubDate>Mon, 14 May 2018 19:37:40 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-5/</guid><description>1.1.5 # 解答 # 比较简单，直接判断即可。
代码 # static void Main(string[] args) { //修改这两个值进行测试 double x = 0.05; double y = 0.01; if (x &amp;gt; 0 &amp;amp;&amp;amp; x &amp;lt; 1 &amp;amp;&amp;amp; y &amp;gt; 0 &amp;amp;&amp;amp; y &amp;lt; 1) { Console.WriteLine(&amp;#34;true&amp;#34;); } else { Console.WriteLine(&amp;#34;false&amp;#34;); } }</description></item><item><title>1.1.6</title><link>https://alg4.ikesnowy.com/1-1-6/</link><pubDate>Mon, 14 May 2018 19:39:16 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-6/</guid><description>1.1.6 # 解答 # 输出斐波那契数列。
将书中的代码直接实现即可。
代码 # //输出斐波那契数列 static void Main(string[] args) { int f = 0; int g = 1; for (int i = 0; i &amp;lt;= 15; i++) { //Console.WriteLine与StdOut.println功能相同 //实现向控制台输出一行 Console.WriteLine(f); f = f + g; g = f - g; } }</description></item><item><title>1.1.7</title><link>https://alg4.ikesnowy.com/1-1-7/</link><pubDate>Mon, 14 May 2018 19:46:19 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-7/</guid><description>1.1.7 # 解答 # 同上题，直接实现即可。
a
3.00009
double计算存在误差，并不精确。
b
499500
1000 + 999 + 998……
c
10000
1000 * 10，外层循环的结束条件为 $2^i &amp;gt;1000$
代码 # private static void a() { Console.WriteLine(&amp;#34;a&amp;#34;); double t = 9.0; while (Math.Abs(t - 9.0 / t) &amp;gt; .001) { t = (9.0 / t + t) / 2.0; } Console.Write($&amp;#34;{t:N5}\n&amp;#34;);//:N5代表保留5位小数，同理可使用N1、N2…… } private static void b() { Console.</description></item><item><title>1.1.8</title><link>https://alg4.ikesnowy.com/1-1-8/</link><pubDate>Mon, 14 May 2018 20:00:25 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-8/</guid><description>1.1.8 # 解答 # b
197
e
代码 # static void Main(string[] args) { Console.WriteLine(&amp;#39;b&amp;#39;); Console.WriteLine(&amp;#39;b&amp;#39; + &amp;#39;c&amp;#39;); //char 被隐式转为为 int 类型，取 ascii 码 Console.WriteLine((char)(&amp;#39;a&amp;#39; + 4)); //强制转换后，ascii 码被转换为相应的字符 }</description></item><item><title>1.1.9</title><link>https://alg4.ikesnowy.com/1-1-9/</link><pubDate>Mon, 14 May 2018 20:03:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-9/</guid><description>1.1.9 # 解答 # 有两种方法，要么直接调用库函数，要么用书中给出的代码转换。
代码 # static void Main(string[] args) { int N = 4; //1.直接转换 Convert.ToString(int, int) 第一个为要转换的数，第二个为要转换的进制 Console.WriteLine($&amp;#34;{Convert.ToString(N, 2)}&amp;#34;); //2.转换为二进制数 string s = &amp;#34;&amp;#34;; for (int n = N; n &amp;gt; 0; n /= 2) { s = (n % 2) + s; } Console.WriteLine(s); }</description></item><item><title>1.1.10</title><link>https://alg4.ikesnowy.com/1-1-10/</link><pubDate>Mon, 14 May 2018 20:05:03 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-10/</guid><description>1.1.10 # 解答 # 变量使用前需要先赋值。
代码 # static void Main(string[] args) { int[] a; for (int i = 0; i &amp;lt; 10; i++) { a[i] = i * i; //不允许使用未赋值的局部变量 } }</description></item><item><title>1.1.11</title><link>https://alg4.ikesnowy.com/1-1-11/</link><pubDate>Mon, 14 May 2018 20:31:26 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-11/</guid><description>1.1.11 # 解答 # 注意，二维数组 bool[M, N] 代表 M 行 N 列的布尔数组。
使用二重循环即可实现。
输出使用制表符 ’\t’ 作为分隔。
代码 # static void PrintArray2D(bool[,] array) { int rows = array.GetLength(0);//获取行数 int columns = array.GetLength(1);//获取列数 //输出列号 for (int i = 0; i &amp;lt; columns; i++) { Console.Write($&amp;#34;\t{i + 1}&amp;#34;); } Console.Write(&amp;#34;\n&amp;#34;); for (int i = 0; i &amp;lt; rows; i++) { //输出行号 Console.</description></item><item><title>1.1.12</title><link>https://alg4.ikesnowy.com/1-1-12/</link><pubDate>Mon, 14 May 2018 20:55:30 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-12/</guid><description>1.1.12 # 解答 # 第一个循环初始化数组 {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
第二个循环用相应位置的值作为下标取值，例如：a[0] = a[a[0]] = a[9] = 0
最后结果为：0,1,2,3,4,4,3,2,1,0
代码 # static void Main(string[] args) { int[] a = new int[10]; for (int i = 0; i &amp;lt; 10; i++) { a[i] = 9 - i; } //a[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0} for (int i = 0; i &amp;lt; 10; i++) { a[i] = a[a[i]]; } //a[0] = a[9] = 0; a[1] = a[8] = 1; a[2] = a[7] = 2;.</description></item><item><title>1.1.13</title><link>https://alg4.ikesnowy.com/1-1-13/</link><pubDate>Mon, 14 May 2018 21:00:06 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-13/</guid><description>1.1.13 # 解答 # 转置输出只需要在二重循环的时候将行、列输出顺序取反即可。
代码 # static void Main(string[] args) { int M = 2; int N = 3; int[,] array = new int[M, N]; //新建一个二维数组 for (int i = 0; i &amp;lt; M; i++) { for (int j = 0; j &amp;lt; N; j++) { array[i, j] = i + j; } } Console.</description></item><item><title>1.1.14</title><link>https://alg4.ikesnowy.com/1-1-14/</link><pubDate>Mon, 14 May 2018 21:01:40 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-14/</guid><description>1.1.14 # 解答 # 简单使用 log 的定义逼近即可。
代码 # static void Main(string[] args) { int N = 9; Console.WriteLine($&amp;#34;{ lg(N)}&amp;#34;); } //利用循环逼近 N，得到 log2(N) 的值 static int lg(int N) { int baseNumber = 2; int pow = 1; int sum = 2; for (pow = 1; sum &amp;lt; N; ++pow) { sum *= baseNumber; } return pow - 1; }</description></item><item><title>1.1.15</title><link>https://alg4.ikesnowy.com/1-1-15/</link><pubDate>Mon, 14 May 2018 21:03:18 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-15/</guid><description>1.1.15 # 解答 # 利用二重循环，查找每个值在数组中出现的次数。
代码 # static void Main(string[] args) { int[] a = new int[10]; int M = 10; for (int i = 0; i &amp;lt; 10; ++i) { a[i] = i; } int[] result = Histogram(a, M); Console.WriteLine($&amp;#34;a.length: {a.Length}&amp;#34;); Console.WriteLine($&amp;#34;sum of result array: {result.Sum()}&amp;#34;); } static int[] Histogram(int[] a, int M) { int[] result = new int[M]; for (int i = 0; i &amp;lt; M; ++i) { //初始化 result[i] = 0; //遍历数组，计算数组中值为 i 的元素个数 for (int j = 0; j &amp;lt; a.</description></item><item><title>1.1.16</title><link>https://alg4.ikesnowy.com/1-1-16/</link><pubDate>Mon, 14 May 2018 21:23:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-16/</guid><description>1.1.16 # 解答 # 填入代码测试即可。
用字符串拼接的方式展示递归。
类似于这个：
代码 # static void Main(string[] args) { int[] a = new int[10]; int M = 10; for (int i = 0; i &amp;lt; 10; ++i) { a[i] = i; } int[] result = Histogram(a, M); Console.WriteLine($&amp;#34;a.length: {a.Length}&amp;#34;); Console.WriteLine($&amp;#34;sum of result array: {result.Sum()}&amp;#34;); } static int[] Histogram(int[] a, int M) { int[] result = new int[M]; for (int i = 0; i &amp;lt; M; ++i) { //初始化 result[i] = 0; //遍历数组，计算数组中值为 i 的元素个数 for (int j = 0; j &amp;lt; a.</description></item><item><title>1.1.17</title><link>https://alg4.ikesnowy.com/1-1-17/</link><pubDate>Mon, 14 May 2018 21:57:55 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-17/</guid><description>1.1.17 # 解答 # 书中已经给出了解释。
递归时结束条件必须放在递归语句的前面，否则会不断展开而无法结束。
代码 # static void Main(string[] args) { Console.WriteLine($&amp;#34;{exR2(6)}&amp;#34;);//抛出 StackOverflow Exception } public static string exR2(int n) { string s = exR2(n - 3) + n + exR2(n - 2) + n;//运行到 exR2 即展开，不会再运行下一句 if (n &amp;lt;= 0) return &amp;#34;&amp;#34;; return s; }</description></item><item><title>1.1.18</title><link>https://alg4.ikesnowy.com/1-1-18/</link><pubDate>Mon, 14 May 2018 21:59:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-18/</guid><description>1.1.18 # 解答 # 其实就是一种快速乘法的实现，换成乘号之后就变成了快速乘幂。
例如对于乘法 $2 \times 4$ ，可以用 $2 + 2 + 2 + 2$ 做四次加法计算；也可以变为 $(2 + 2) \times 2 = (2 + 2) + (2 + 2)$ 的形式，用两次加法就可以完成（先计算 $2 + 2$ 的值，再计算 $4 + 4$ 的值）。
同理对于乘幂 $2^8$ ，既可以用 $2\times 2 \times 2 \times 2 \times 2 \times 2 \times 2 \times 2$ 做 8 次乘法，也可以只用三次乘法就计算出来：
$$ 2^2 = 2 \times 2 \newline 2^4 = 2^2 \times 2^2\newline 2^8 = 2^4 \times 2^4 $$</description></item><item><title>1.1.19</title><link>https://alg4.ikesnowy.com/1-1-19/</link><pubDate>Mon, 14 May 2018 22:09:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-19/</guid><description>1.1.19 # 解答 # 普通的递归算法效率很低，原因是越到后面重复运算的数目越多。
比如：
F(2) = F(1) + F(0)
F(3) = F(2) + F(1) = F(1) + F(1) + F(0)
可以看到 F(1) 被重复计算了两次。
改进的方式是将每次运算的结果保存在数组中，之后计算过的数据直接从数组中提取。
代码 # class Fibnacci { //long 类型不够大，换成 UINT64 类型 //用于保存计算结果的数组，UInt64? 代表可以赋值为普通 UInt64 类型的值以及 null 值 private static UInt64?[] fibnacciResults = new UInt64?[100]; static void Main(string[] args) { /* * 测试环境 * * Surface Pro3 i7 * i7 4650U + 8G * */ Stopwatch timer = Stopwatch.</description></item><item><title>1.1.20</title><link>https://alg4.ikesnowy.com/1-1-20/</link><pubDate>Tue, 15 May 2018 11:46:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-20/</guid><description>1.1.20 # 解答 # 根据对数的性质可以得到：
$$ \ln(N!) = \ln(N) + \ln(N – 1) + \ln(N – 2)… $$
代码 # static void Main(string[] args) { int N = 4; Console.WriteLine($&amp;#34;{factorialLn(N)}&amp;#34;); } //ln(N!) = //ln(N * (N - 1) * ... * 1) = //ln(N) + ln((N - 1)!) public static double factorialLn(int N) { if (N == 1) { return 0; } return Math.</description></item><item><title>1.1.21</title><link>https://alg4.ikesnowy.com/1-1-21/</link><pubDate>Tue, 15 May 2018 11:48:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-21/</guid><description>1.1.21 # 解答 # 实现上没什么难度，打印表格的部分可以参考之前打印二位布尔数组的方法。
注意整型数据之间相除得到的仍然是整型，小数部分会直接舍去，例如 2 / 3 的结果会是 0。
代码 # static void Main(string[] args) { int columns = 2; int rows = int.Parse(Console.ReadLine()); //行号 string[] names = new string[rows]; //姓名 int[,] array = new int[rows, columns]; //输入的两个整数 double[] results = new double[rows]; //计算结果 for (int i = 0; i &amp;lt; rows; ++i) { string temp = Console.</description></item><item><title>1.1.22</title><link>https://alg4.ikesnowy.com/1-1-22/</link><pubDate>Tue, 15 May 2018 11:54:48 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-22/</guid><description>1.1.22 # 解答 # 按照书中的提示增加一个保存深度的参数。
代码 # class BinarySearch { static void Main(string[] args) { int[] array = new int[10] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; rank(9, array); } //重载方法，用于启动二分查找 public static int rank(int key, int[] a) { return rank(key, a, 0, a.Length - 1, 1); } //二分查找 public static int rank(int key, int[] a, int lo, int hi, int number) { for (int i = 0; i &amp;lt; number; ++i) { Console.</description></item><item><title>1.1.23</title><link>https://alg4.ikesnowy.com/1-1-23/</link><pubDate>Tue, 15 May 2018 11:55:52 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-23/</guid><description>1.1.23 # 解答 # 在主函数里做一下判断就可以了，加号则输出所有找不到的值，减号则相反。
代码 # static void Main(string[] args) { //从largeW.txt中读取数据 string[] whiteList = File.ReadAllLines(&amp;#34;largeW.txt&amp;#34;); int[] WhiteList = new int[whiteList.Length]; for (int i = 0; i &amp;lt; whiteList.Length; ++i) { WhiteList[i] = int.Parse(whiteList[i]); } Array.Sort&amp;lt;int&amp;gt;(WhiteList); Console.WriteLine(&amp;#34;Type the numbers you want to query: &amp;#34;); //输入样例：5 824524 478510 387221 string input = Console.ReadLine(); int[] Query = new int[input.</description></item><item><title>1.1.24</title><link>https://alg4.ikesnowy.com/1-1-24/</link><pubDate>Tue, 15 May 2018 12:09:38 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-24/</guid><description>1.1.24 # 解答 # 在书本中 GCD 的基础上，在函数开始时增加一条输出语句即可。
代码 # static void Main(string[] args) { GCD(105, 24); Console.WriteLine(); GCD(111111, 1234567); } public static int GCD(int a, int b) { Console.WriteLine($&amp;#34;{a} {b}&amp;#34;); if (b == 0) { return a; } return GCD(b, a % b); }</description></item><item><title>1.1.25</title><link>https://alg4.ikesnowy.com/1-1-25/</link><pubDate>Tue, 15 May 2018 12:11:10 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-25/</guid><description>1.1.25 # 解答 # 已知：$a,b$ 皆为正整数，且 $a&amp;gt;b$。$g$ 是 $ a,b$ 的最大公约数.
设 $\ r_0=a\bmod b$ ，$r_k = r_{k-2} \bmod\ r_{k-1}$ 。
那么有 $gcd(a,b)=gcd(b,r_0)=gcd(r_0,r_1)&amp;hellip;=gcd(r_{n-1},r_n)$ 。 且 $r_n=0$ （此时算法终止）。
由于 $r_{n-2}=q_n\times r_{n-1} + r_n=q_n\times r_{n-1} \ (q_n=\lfloor r_{n-2}/r_{n-1}\rfloor)$ 。
可得 $r_{n-2}$ 能被 $r_{n-1}$ 整除。
则有
$r_{n-3}\newline =q_{n-1} \times r_{n-2} + r_{n-1}\newline =q_{n-1}\times (q_n \times r_{n-1})+r_{n-1}\newline =q_{n-1}\times q_n \times r_{n-1} + r_{n-1} \newline =(q_{n-1} \times q_n +1)\times r_{n-1}$
可得 $r_{n-3}$ 也能被 $r_{n-1}$ 整除</description></item><item><title>1.1.26</title><link>https://alg4.ikesnowy.com/1-1-26/</link><pubDate>Tue, 15 May 2018 19:28:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-26/</guid><description>1.1.26 # 解答 # 见代码部分。
代码 # static void Main(string[] args) { int a = 3; int b = 2; int c = 1; int t = 0; if (a &amp;gt; b) { t = a; a = b; b = t; } //如果 a &amp;gt; b，那么 a, b 交换，保证b &amp;gt;= a if (a &amp;gt; c) { t = a; a = c; c = t; } //如果 b &amp;gt;= a &amp;gt; c，那么 a, c 交换，保证 c &amp;gt;= a if (b &amp;gt; c) { t = b; b = c; c = t; } //如果 b &amp;gt; c &amp;gt;= a，那么 b, c 交换，保证 c &amp;gt;= b Console.</description></item><item><title>1.1.27</title><link>https://alg4.ikesnowy.com/1-1-27/</link><pubDate>Tue, 15 May 2018 19:34:52 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-27/</guid><description>1.1.27 # 解答 # 与之前的斐波那契数列类似，都是重复计算的问题。
答案是 7751 次。
代码 # class Program { static int BinomialCalled = 0; //计算递归调用次数 static double?[,] BinomialCache; //保存计算结果的数组 static void Main(string[] args) { BinomialCache = new double?[101, 51]; Console.WriteLine(Binomial(100, 50, 0.25)); Console.WriteLine(BinomialCalled); } public static double? Binomial(int N, int k, double p) { BinomialCalled++; if (N == 0 &amp;amp;&amp;amp; k == 0) return 1.</description></item><item><title>1.1.28</title><link>https://alg4.ikesnowy.com/1-1-28/</link><pubDate>Tue, 15 May 2018 19:42:53 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-28/</guid><description>1.1.28 # 解答 # 实现方法有很多，这里是使用一个 HashSet 做中转，删除所有的重复元素。
也可以使用 Linq 里的 Distinct() 方法，
也可以排序后直接遍历一遍，遇到相同的就删除，遇到不同的就保存起来用于之后的比较。
代码 # static void Main(string[] args) { //从largeW.txt中读取数据 //用 HashSet 的不可重复性去除重复 HashSet&amp;lt;string&amp;gt; h = new HashSet&amp;lt;string&amp;gt;(File.ReadAllLines(&amp;#34;largeW.txt&amp;#34;)); string[] whiteList = new string[h.Count]; h.CopyTo(whiteList); int[] WhiteList = new int[whiteList.Length]; for (int i = 0; i &amp;lt; whiteList.Length; ++i) { WhiteList[i] = int.Parse(whiteList[i]); } Array.</description></item><item><title>1.1.29</title><link>https://alg4.ikesnowy.com/1-1-29/</link><pubDate>Tue, 15 May 2018 19:46:21 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-29/</guid><description>1.1.29 # 解答 # 查找小于指定值的元素数量可以多次使用二分查找实现。
例如：
序号：0 1 2 3 4 5 6 7 8
元素：1 2 2 2 2 2 2 2 3
二分查找返回 4
再次在 0~3 之间查找
二分查找返回 1
再次在 0~1 之间查找
二分查找返回 -1，没有指定值了
因此小于该值的元素数量就是 1 – 0 = 1 个
用同样的方法可以找到大于指定值的元素个数，
从总数中减去这两个数值就是等于指定值的元素数量。
代码 # static void Main(string[] args) { int[] WhiteList = new int[] { 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6 }; Array.</description></item><item><title>1.1.30</title><link>https://alg4.ikesnowy.com/1-1-30/</link><pubDate>Tue, 15 May 2018 19:51:45 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-30/</guid><description>1.1.30 # 解答 # 互质可以用之前的 GCD 最大公因数算法判断，如果最大公因数是 1 则两数互质。
代码 # //互质 = 最大公约数为 1 = gcd(i, j) == 1 static void Main(string[] args) { int N = int.Parse(Console.ReadLine()); bool[,] a = new bool[N, N]; for (int i = 0; i &amp;lt; N; ++i) { for (int j = 0; j &amp;lt; N; ++j) { a[i, j] = (gcd(i, j) == 1); } } PrintArray2D(a, N, N); } static int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); } private static void PrintArray2D(bool[,] array, int rows, int columns) { for (int i = 0; i &amp;lt; rows; i++) { for (int j = 0; j &amp;lt; columns; j++) { Console.</description></item><item><title>1.1.31</title><link>https://alg4.ikesnowy.com/1-1-31/</link><pubDate>Tue, 15 May 2018 19:53:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-31/</guid><description>1.1.31 # 解答 # 概率的实现方法：
例如概率是 60 %，就在 [0, 100) 之间随机一个值，小于等于 60 则执行操作，反之不执行。
需要更精确的情况可以增大随机的范围，例如 [0, 1000)。
绘图结果
N = 10,p = 0.2, 0.5, 1
完整项目可以到 Github 上下载。
代码 # /// &amp;lt;summary&amp;gt; /// 主绘图函数 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;N&amp;#34;&amp;gt;点的总数目&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;p&amp;#34;&amp;gt;每对点之间连接的概率&amp;lt;/param&amp;gt; public static void StartDrawing(int N, double p) { int pointSize = 5;//每个点绘制的大小 int precious = 1000;//概率判断的精度 //新建一个绘图窗口 Form2 DrawPad = new Form2(); //显示绘图窗口 DrawPad.</description></item><item><title>1.1.32</title><link>https://alg4.ikesnowy.com/1-1-32/</link><pubDate>Tue, 15 May 2018 19:57:35 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-32/</guid><description>1.1.32 # 解答 # 绘图结果：
完整的项目代码可以去 Github 上下载。
代码 # public static void StartDrawing(double[] array, int N, double l, double r) { //创建并显示绘图窗口 Form2 DrawPad = new Form2(); DrawPad.Show(); //新建画布 Graphics graphics = DrawPad.CreateGraphics(); //翻转默认坐标系 graphics.TranslateTransform(0, DrawPad.Height); graphics.ScaleTransform(1, -1); //对原始数组排序 Array.Sort(array); //计算各区域的值 int[] counts = new int[N]; int index = 0; for (int i = 0; i &amp;lt; N; ++i) { for (int j = index; j &amp;lt; array.</description></item><item><title>1.1.33</title><link>https://alg4.ikesnowy.com/1-1-33/</link><pubDate>Tue, 15 May 2018 20:01:17 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-33/</guid><description>1.1.33 # 解答 # 这里矩阵使用交错数组实现（方便取行向量），不是普通的二维数组。
矩阵和矩阵、矩阵和向量、向量和矩阵都使用行向量点乘列向量的方式计算。
代码 # public class Matrix { /// &amp;lt;summary&amp;gt; /// 计算两个向量的点积 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;x&amp;#34;&amp;gt;需要点乘的向量&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;y&amp;#34;&amp;gt;需要点乘的另一个向量&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;返回点乘的结果&amp;lt;/returns&amp;gt; /// &amp;lt;exception cref=&amp;#34;FormatException&amp;#34;&amp;gt;&amp;lt;/exception&amp;gt; public static double Dot(double[] x, double[] y) { //确保两向量等长 if (x.Length != y.Length) { throw new FormatException(&amp;#34;the length of two vectors must be equal&amp;#34;); } //点乘 double result = 0; for (int i = 0; i &amp;lt; x.</description></item><item><title>1.1.34</title><link>https://alg4.ikesnowy.com/1-1-34/</link><pubDate>Tue, 15 May 2018 20:18:11 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-34/</guid><description>1.1.34 # 解答 # 第二个以及最后三个需要，其他都可以设计成过滤器的模式。
这里的 largeW.txt 只需要保留前 100 个数字就可以了，太多的话最后两个测试会刷屏。
代码 # static void Main(string[] args) { string[] AllNumbers = File.ReadAllLines(&amp;#34;largeW.txt&amp;#34;); int N = AllNumbers.Length; int[] input = new int[N]; for (int i = 0; i &amp;lt; N; ++i) { input[i] = int.Parse(AllNumbers[i]); } MinAndMax(input); Console.WriteLine(); MidNumber(input); Console.WriteLine(); NumberK(4, input); Console.</description></item><item><title>1.1.35</title><link>https://alg4.ikesnowy.com/1-1-35/</link><pubDate>Tue, 15 May 2018 21:04:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-35/</guid><description>1.1.35 # 解答 # 这里用 Random 类模拟掷骰子并计算概率，最后和程序得出的比较。
代码 # //程序运行大概需要十几秒时间（也可能更长，看运气） //我的数据： //24098 44448 37776 44401 32541 static void Main(string[] args) { //书中给出的程序 int SIDES = 6; double[] dist = new double[2 * SIDES + 1]; for (int i = 1; i &amp;lt;= SIDES; i++) for (int j = 1; j &amp;lt;= SIDES; j++) dist[i + j] += 1.0; for (int k = 2; k &amp;lt;= 2 * SIDES; k++) dist[k] /= 36.</description></item><item><title>1.1.36</title><link>https://alg4.ikesnowy.com/1-1-36/</link><pubDate>Tue, 15 May 2018 21:10:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-36/</guid><description>1.1.36 # 解答 # N 取到 1000 左右数据就比较明显了。
N = 1000， M = 10
代码 # static void Main(string[] args) { int M = 10;//数组大小 int N = 1000;//打乱次数 int[] a = new int[10]; int[,] result = new int[M, M]; for (int i = 0; i &amp;lt; N; ++i) { //初始化 for (int j = 0; j &amp;lt; a.</description></item><item><title>1.1.37</title><link>https://alg4.ikesnowy.com/1-1-37/</link><pubDate>Tue, 15 May 2018 21:13:18 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-37/</guid><description>1.1.37 # 解答 # 使用 0~N-1 的随机数会导致每次交换的数字可能相同。
例如：
原数组： 1 2 3 4。
第一次： 2 1 3 4
random = 1，第 0 个和第 1 个交换。
第二次： 1 2 3 4
random = 0，第 1 个和第 0 个交换。
代码 # static void Main(string[] args) { int M = 10;//数组大小 int N = 100000;//打乱次数 int[] a = new int[10]; int[,] result = new int[M, M]; for (int i = 0; i &amp;lt; N; ++i) { //初始化 for (int j = 0; j &amp;lt; a.</description></item><item><title>1.1.38</title><link>https://alg4.ikesnowy.com/1-1-38/</link><pubDate>Tue, 15 May 2018 21:15:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-38/</guid><description>1.1.38 # 解答 # 为了使差距比较明显，故意取了比较靠后的数字。
代码 # static void Main(string[] args) { string[] largeWString = File.ReadAllLines(&amp;#34;largeW.txt&amp;#34;); int[] largeW = new int[largeWString.Length]; for (int i = 0; i &amp;lt; largeW.Length; ++i) { largeW[i] = int.Parse(largeWString[i]); } Stopwatch timer = Stopwatch.StartNew(); BruteForceSearch(111111, largeW); Console.WriteLine($&amp;#34;BruteForceSearch: {timer.ElapsedMilliseconds} ms&amp;#34;); timer.Restart(); rank(111111, largeW); Console.WriteLine($&amp;#34;BinarySearch: {timer.ElapsedMilliseconds} ms&amp;#34;); string[] largeTString = File.</description></item><item><title>1.1.39</title><link>https://alg4.ikesnowy.com/1-1-39/</link><pubDate>Tue, 15 May 2018 21:16:12 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-39/</guid><description>1.1.39 # 解答 # 按照要求编程就好，视机器不同需要的时间也不同。
代码 # //需要 6 秒左右的运算时间 static void Main(string[] args) { Random r = new Random(); int baseNum = 10; int powNum = 3; int T = 10; int M = 4; double[,] Matrix = new double[M,2]; for (int i = 0; i &amp;lt; M; ++i) { int N = (int)Math.Pow(baseNum, powNum + i); double sum = 0; for (int j = 0; j &amp;lt; T; ++j) { sum += Test(N, r.</description></item><item><title>1.2.1</title><link>https://alg4.ikesnowy.com/1-2-1/</link><pubDate>Tue, 15 May 2018 21:38:25 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-1/</guid><description>1.2.1 # 解答 # 这里自己实现了一个 Point2D 类（包含在了 Geometry 库中）。
JAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Point2D.java.html。
求最近两点只需要反复调用 Point2D 类中的 DistTo() 方法就可以了。
代码 # Point2D 类 # /// &amp;lt;summary&amp;gt; /// Point2D 二维点类。 /// &amp;lt;/summary&amp;gt; public sealed class Point2D : IComparable&amp;lt;Point2D&amp;gt; { public readonly static Comparer&amp;lt;Point2D&amp;gt; X_Order = new XOrder(); public readonly static Comparer&amp;lt;Point2D&amp;gt; Y_Order = new YOrder(); public readonly static Comparer&amp;lt;Point2D&amp;gt; R_Order = new ROrder(); public double X { get; } public double Y { get; } public int Radius { get; set; } public Point2D(double x, double y) { if (double.</description></item><item><title>1.2.2</title><link>https://alg4.ikesnowy.com/1-2-2/</link><pubDate>Tue, 15 May 2018 21:47:24 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-2/</guid><description>1.2.2 # 解答 # 同样实现了一个 Interval1D 类（位于 Geometry 库）。
JAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Interval1D.java.html。
直接调用其中的 Intersect() 方法即可
代码 # Interval1D 类： # namespace Geometry { /// &amp;lt;summary&amp;gt; /// 一维闭区间。 /// &amp;lt;/summary&amp;gt; public class Interval1D { public static readonly Comparer&amp;lt;Interval1D&amp;gt; Min_Order = new MinEndpointComparer(); public static readonly Comparer&amp;lt;Interval1D&amp;gt; Max_Order = new MaxEndpointComparer(); public static readonly Comparer&amp;lt;Interval1D&amp;gt; Length_Order = new LengthComparer(); public double Min { get; } public double Max { get; } /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;lo&amp;#34;&amp;gt;一维区域的下界。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;hi&amp;#34;&amp;gt;一维区域的上界。&amp;lt;/param&amp;gt; public Interval1D(double lo, double hi) { if (double.</description></item><item><title>1.2.3</title><link>https://alg4.ikesnowy.com/1-2-3/</link><pubDate>Tue, 15 May 2018 21:49:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-3/</guid><description>1.2.3 # 解答 # 首先先实现一个 Interval2D 类（位于 Geometry 库），再使用窗体应用程序绘图。
JAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Interval2D.java.html。
代码 # Interval2D： # using System.Drawing; namespace Geometry { /// &amp;lt;summary&amp;gt; /// 二维闭合区间。 /// &amp;lt;/summary&amp;gt; public class Interval2D { private readonly Interval1D X; private readonly Interval1D Y; /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;x&amp;#34;&amp;gt;x 轴上的范围。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;y&amp;#34;&amp;gt;y 轴上的范围。&amp;lt;/param&amp;gt; public Interval2D(Interval1D x, Interval1D y) { this.</description></item><item><title>1.2.4</title><link>https://alg4.ikesnowy.com/1-2-4/</link><pubDate>Tue, 15 May 2018 21:51:16 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-4/</guid><description>1.2.4 # 解答 # 在 C# 中，这段代码能够完成交换的工作，输出为：
world hello 代码 # using System; namespace _1._2._4 { /* * 1.2.4 * * 以下这段代码会打印出什么？ * String string1 = &amp;#34;hello&amp;#34;; * String string2 = string1; * string1 = &amp;#34;world&amp;#34;; * StdOut.println(string1); * StdOut.println(string2); * */ class Program { static void Main(string[] args) { string string1 = &amp;#34;hello&amp;#34;; string string2 = string1; string1 = &amp;#34;world&amp;#34;; Console.</description></item><item><title>1.2.5</title><link>https://alg4.ikesnowy.com/1-2-5/</link><pubDate>Tue, 15 May 2018 21:52:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-5/</guid><description>1.2.5 # 解答 # string 类型中的 Uppercase() 以及 Substring() 都不会改变原有字符串，而是新建一个字符串。
因此输出仍然为 Hello World。
代码 # using System; namespace _1._2._5 { /* * 1.2.5 * * 以下这段代码会打印出什么？ * String s = &amp;#34;Hello World&amp;#34;; * s.toUpperCase(); * s.substring(6, 11); * StdOut.println(s); * */ class Program { static void Main(string[] args) { string s = &amp;#34;Hello World&amp;#34;; s.ToUpper(); s.Substring(6, 5);//C# 中两个参数分别代表子串起始下标和长度 Console.</description></item><item><title>1.2.6</title><link>https://alg4.ikesnowy.com/1-2-6/</link><pubDate>Tue, 15 May 2018 21:53:48 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-6/</guid><description>1.2.6 # 解答 # 对于任意字符串 s，将其拆分成 s = s1 + s2（s2长度即为循环移动的位数） 其回环变位则为 s' = s2 + s1
显然 s' + s' = s2 + s1 + s2 + s1
即 s' + s' = s2 + s + s1，其中必定包含 s
例如 ABC 和 BCA， BCABCA 显然包含 ABC
代码 # using System; namespace _1._2._6 { /* * 1.2.6 * * 如果字符串 s 中的字符循环移动任意位置之后能够得到另一个字符串 t， * 那么 s 就被称为 t 的回环变位（circular rotation）。 * 例如，ACTGACG 就是 TGACGAC 的一个回环变位，反之亦然。 * 判定这个条件在基因组序列的研究中是很重要的。 * 编写一个程序检查两个给定的字符串 s 和 t 是否互为回环变位。 * 提示：答案只需要一行用到 indexOf()、length() 和字符串连接的代码。 * */ class Program { static void Main(string[] args) { string s1 = &amp;#34;ACTGACG&amp;#34;; string s2 = &amp;#34;TGACGAC&amp;#34;; Console.</description></item><item><title>1.2.7</title><link>https://alg4.ikesnowy.com/1-2-7/</link><pubDate>Tue, 15 May 2018 21:55:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-7/</guid><description>1.2.7 # 解答 # 递归交换字符顺序，最后返回反序的字符串。
Mystery(ABCD)=
Mystery(CD) + Mystery(AB)=
Mystery(D) + Mystery(C) + Mystery(B) + Mystery(A)=
DCBA
代码 # using System; namespace _1._2._7 { /* * 1.2.7 * * 以下递归函数的返回值是什么？ * public static String mystery(String s) * { * int N = s.length(); * if (N &amp;lt;= 1) return s; * String a = s.substring(0, N/2); * String b = s.substring(N/2, N); * return mystery(b) + mystery(a); * } * */ class Program { static void Main(string[] args) { Console.</description></item><item><title>1.2.8</title><link>https://alg4.ikesnowy.com/1-2-8/</link><pubDate>Tue, 15 May 2018 21:56:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-8/</guid><description>1.2.8 # 解答 # 作用就是交换两个数组。
但在 C# 或 JAVA 中，数组变量实际是数组的一个引用（类似于指针），交换两个引用的效率与数组大小无关，都是常数时间的。
代码 # using System; using System.IO; namespace _1._2._8 { /* * 1.2.8 * * 设 a[] 和 b[] 均为长数百万的整型数组。以下代码的作用是什么？有效吗？ * int[] t = a; a = b; b = t; * */ class Program { static void Main(string[] args) { //读取 largeW.txt string[] allNums = File.ReadAllLines(&amp;#34;largeW.txt&amp;#34;); int N = allNums.</description></item><item><title>1.2.9</title><link>https://alg4.ikesnowy.com/1-2-9/</link><pubDate>Wed, 16 May 2018 07:32:17 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-9/</guid><description>1.2.9 # 解答 # 首先实现一个 Counter 类，随后使用非递归版本的 BinarySearch，每进行一次 While 循环就让 Counter 加一。
代码 # Counter 类
namespace _1._2._9 { /// &amp;lt;summary&amp;gt; /// 计数器类 /// &amp;lt;/summary&amp;gt; class Counter { private readonly string name; private int count; /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;id&amp;#34;&amp;gt;计数器的名称。&amp;lt;/param&amp;gt; public Counter(string id) { this.name = id; } /// &amp;lt;summary&amp;gt; /// 计数器加一。 /// &amp;lt;/summary&amp;gt; public void Increment() { count++; } /// &amp;lt;summary&amp;gt; /// 获取当前计数值。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int Tally() { return count; } /// &amp;lt;summary&amp;gt; /// 输出形如 “1 counter” 的字符串。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public override string ToString() { return count + &amp;#34; &amp;#34; + name; } } } Main 方法</description></item><item><title>1.2.10</title><link>https://alg4.ikesnowy.com/1-2-10/</link><pubDate>Wed, 16 May 2018 08:17:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-10/</guid><description>1.2.10 # 解答 # 在 Counter 类基础上修改即可。
代码 # VisualCounter 类
using System.Drawing; namespace _1._2._10 { /// &amp;lt;summary&amp;gt; /// 可视化计数器 /// &amp;lt;/summary&amp;gt; class VisualCounter { private readonly string name; private int count; private int max; private int operatorTimes; /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;id&amp;#34;&amp;gt;计数器的名称。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;max&amp;#34;&amp;gt;计数器的最大值。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;operatorTimes&amp;#34;&amp;gt;计数器的最大操作数。&amp;lt;/param&amp;gt; public VisualCounter(string id, int max, int operatorTimes) { this.</description></item><item><title>1.2.11</title><link>https://alg4.ikesnowy.com/1-2-11/</link><pubDate>Wed, 16 May 2018 08:25:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-11/</guid><description>1.2.11 # 解答 # 在构造函数开始时做一次判断，非法时抛出异常。
首先建立一个数组，数组的第 1 项至第 12 项的值就是每个月的天数。
再声明一个布尔类型的变量，用于标记是否是闰年。
代码 # using System; namespace _1._2._11 { class SmartDate { public int Month { get; }//月 public int Day { get; }//日 public int Year { get; }//年 //每个月对应的天数，第 0 位空出来 static private int[] dayOfMonth = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; public SmartDate(int m, int d, int y) { if (Vaildation(m, d, y) == false) throw new FormatException(&amp;#34;Invaild Date&amp;#34;); this.</description></item><item><title>1.2.12</title><link>https://alg4.ikesnowy.com/1-2-12/</link><pubDate>Wed, 16 May 2018 08:29:34 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-12/</guid><description>1.2.12 # 解答 # 这里使用蔡勒公式来推算星期。
参考：http://www.cnblogs.com/mq0036/p/3534314.html
代码 # /// &amp;lt;summary&amp;gt; /// 计算当前日期是星期几，返回对应的星期名称。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public string DayOfTheWeek() { int d = this.Day; int m = this.Month; int y = this.Year; if (m &amp;lt; 3) { m += 12; y--; } //使用蔡勒公式计算，参见 http://www.cnblogs.com/mq0036/p/3534314.html int w = (d + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400) % 7; return dayOfWeek[w]; } 另请参阅 # 蔡勒公式-维基百科</description></item><item><title>1.2.13</title><link>https://alg4.ikesnowy.com/1-2-13/</link><pubDate>Wed, 16 May 2018 08:33:09 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-13/</guid><description>1.2.13 # 解答 # 直接实现即可。
JAVA 版本可以参考：http://algs4.cs.princeton.edu/12oop/Transaction.java.html。
代码 # using System; using System.Collections.Generic; namespace Commercial { public class Transaction : IComparable&amp;lt;Transaction&amp;gt; { public string Who { get; } public Date When { get; } public double Amount { get; } /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;transaction&amp;#34;&amp;gt;用空格隔开的形如 “姓名 日期 金额” 的字符串。&amp;lt;/param&amp;gt; public Transaction(string transaction) { string[] a = transaction.</description></item><item><title>1.2.14</title><link>https://alg4.ikesnowy.com/1-2-14/</link><pubDate>Wed, 16 May 2018 08:36:34 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-14/</guid><description>1.2.14 # 解答 # 上一题中的代码已经包含了对 Equals() 方法的实现。
代码 # /// &amp;lt;summary&amp;gt; /// 比较两笔交易是否相同。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;obj&amp;#34;&amp;gt;另一个对象。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public override bool Equals(object obj) { if (obj == this) return true; if (obj == null) return false; if (obj.GetType() != this.GetType()) return false; Transaction that = (Transaction)obj; return (that.Amount == this.Amount) &amp;amp;&amp;amp; (that.When.Equals(this.When)) &amp;amp;&amp;amp; (that.</description></item><item><title>1.2.15</title><link>https://alg4.ikesnowy.com/1-2-15/</link><pubDate>Wed, 16 May 2018 08:38:12 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-15/</guid><description>1.2.15 # 解答 # 这里我们基于 File.ReadAllLines() 进行实现。
代码 # public static int[] ReadInts(string path) { string[] allLines = File.ReadAllLines(path); int[] result = new int[allLines.Length]; for (int i = 0; i &amp;lt; allLines.Length; ++i) { result[i] = int.Parse(allLines[i]); } return result; }</description></item><item><title>1.2.16</title><link>https://alg4.ikesnowy.com/1-2-16/</link><pubDate>Wed, 16 May 2018 08:39:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-16/</guid><description>1.2.16 # 解答 # JAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Rational.java.html
欧几里得算法仅适用于正整数，使用前需要注意。
用欧几里得算法找到公因子之后直接化简即可。
代码 # using System; namespace _1._2._16 { public class Rational { public long Numerator { get; } public long Denominator { get; } private bool isNagative; /// &amp;lt;summary&amp;gt; /// 构造一个有理数对象，自动变为最简形式。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;numerator&amp;#34;&amp;gt;分子。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;denominator&amp;#34;&amp;gt;分母。&amp;lt;/param&amp;gt; /// &amp;lt;exception cref=&amp;#34;ArgumentException&amp;#34;&amp;gt;分母为 0 时抛出&amp;lt;/exception&amp;gt; public Rational(long numerator, long denominator) { if (denominator == 0) throw new ArgumentException(&amp;#34;Denominator cannot be 0&amp;#34;); if (numerator &amp;lt; 0 &amp;amp;&amp;amp; denominator &amp;lt; 0) { isNagative = false; numerator = -numerator; denominator = -denominator; } else if (numerator &amp;lt; 0 || denominator &amp;lt; 0) { isNagative = true; } else { isNagative = false; } long gcd = GCD(Math.</description></item><item><title>1.2.17</title><link>https://alg4.ikesnowy.com/1-2-17/</link><pubDate>Wed, 16 May 2018 08:40:59 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-17/</guid><description>1.2.17 # 解答 # 在 C# 中使用 checked 关键字包裹整数运算的代码即可自动检查溢出。
在 JAVA 中可以考虑在运算前控制运算数的大小。
例如 a + b 之前保证 long.MaxValue – b &amp;gt;= a 等等。
代码 # using System; namespace _1._2._17 { public class Rational { public long Numerator { get; } public long Denominator { get; } private bool isNagative; /// &amp;lt;summary&amp;gt; /// 构造一个有理数对象，自动变为最简形式。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;numerator&amp;#34;&amp;gt;分子。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;denominator&amp;#34;&amp;gt;分母。&amp;lt;/param&amp;gt; /// &amp;lt;exception cref=&amp;#34;ArgumentException&amp;#34;&amp;gt;分母为 0 时抛出&amp;lt;/exception&amp;gt; public Rational(long numerator, long denominator) { if (denominator == 0) throw new ArgumentException(&amp;#34;Denominator cannot be 0&amp;#34;); if (numerator &amp;lt; 0 &amp;amp;&amp;amp; denominator &amp;lt; 0) { isNagative = false; numerator = -numerator; denominator = -denominator; } else if (numerator &amp;lt; 0 || denominator &amp;lt; 0) { isNagative = true; } else { isNagative = false; } long gcd = GCD(Math.</description></item><item><title>1.2.18</title><link>https://alg4.ikesnowy.com/1-2-18/</link><pubDate>Wed, 16 May 2018 08:44:03 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-18/</guid><description>1.2.18 # 解答 # 当数据比较大时—— 例如 10^9 加上随机小数组成的数列，这时 double 的小数精度将受限。
求和之后整数部分更大，小数部分将自动四舍五入，出现误差
这时再计算平均值时将会带来较大的误差。
因此采用另一个递推公式：
k 为下标。
$M_k = M_{k-1}+ (x_k – M_{k-1})/k$
$S_k = S_{k-1} + (x_k – M_{k-1})\times(x_k – M_k)$.
方差 $s^2 = S_k/(k – 1)$.
这种情况下并没有直接对所有输入值求和，小数精度不会过多受到整数部分长度的影响。
有关这两个公式的证明可以参考这篇论文，或者去查看我的知乎回答。
代码 # using System; namespace _1._2._18 { public class Accumulator { private double m; private double s; private int N; public void AddDataValue(double x) { N++; s = s + 1.</description></item><item><title>1.2.19</title><link>https://alg4.ikesnowy.com/1-2-19/</link><pubDate>Wed, 16 May 2018 08:48:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-19/</guid><description>1.2.19 # 解答 # 之前的 Date 和 Transaction 已经包含了这些实现。
代码 # Date # /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;date&amp;#34;&amp;gt;形如 &amp;#34;05/31/2017&amp;#34; 的字符串。&amp;lt;/param&amp;gt; public Date(string date) { string[] a = date.Split(&amp;#39;/&amp;#39;); if (a.Length != 3) throw new ArgumentException(&amp;#34;Illgal Date&amp;#34;); Month = int.Parse(a[0]); Day = int.Parse(a[1]); Year = int.Parse(a[2]); } Transaction # /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;transaction&amp;#34;&amp;gt;用空格隔开的形如 “姓名 日期 金额” 的字符串。&amp;lt;/param&amp;gt; public Transaction(string transaction) { string[] a = transaction.</description></item><item><title>1.3.1</title><link>https://alg4.ikesnowy.com/1-3-1/</link><pubDate>Wed, 16 May 2018 09:02:55 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-1/</guid><description>1.3.1 # 解答 # 首先是 FixedCapacityStackOfStrings 类，官方 JAVA 版本参考：FixedCapacityStackOfStrings.java
IsFull() 的实现比较简单，判断 N 与数组长度是否相等即可。
代码 # using System; using System.Collections; using System.Collections.Generic; namespace _1._3._1 { class FixedCapacityStackOfStrings : IEnumerable&amp;lt;string&amp;gt; { private string[] a; private int N; /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;capacity&amp;#34;&amp;gt;栈的大小。&amp;lt;/param&amp;gt; public FixedCapacityStackOfStrings(int capacity) { this.a = new string[capacity]; this.N = 0; } /// &amp;lt;summary&amp;gt; /// 检查栈是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return this.</description></item><item><title>1.3.2</title><link>https://alg4.ikesnowy.com/1-3-2/</link><pubDate>Wed, 16 May 2018 09:04:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-2/</guid><description>1.3.2 # 解答 # 首先是 Stack&amp;lt;&amp;gt; 类的实现，官方 JAVA 版本参考：Stack.java
输出内容：was best times of the was the it
代码 # using System; using System.Collections; using System.Collections.Generic; using System.Text; namespace Generics { public class Stack&amp;lt;Item&amp;gt; : IEnumerable&amp;lt;Item&amp;gt; { private Node&amp;lt;Item&amp;gt; first; private int count; /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; public Stack() { this.first = null; this.</description></item><item><title>1.3.3</title><link>https://alg4.ikesnowy.com/1-3-3/</link><pubDate>Wed, 16 May 2018 09:06:02 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-3/</guid><description>1.3.3 # 解答 # 这个问题的通用解法见习题 1.3.46 的解答。
第 2、6、7 个不可能产生，可以画个栈模拟一下。
第 2 个
​ 输出数 栈内数 4 0~3 6 0~3 + 5 8 0~3 + 5 + 7 7 0~3 + 5 5 0~3 3 0~2 2 0~1 9 0~1 0 Error 第 6 个
输出数 栈内数 0 null 4 1~3 6 1~3 + 5 5 1~3 3 1~2 8 1~2 + 7 1 Error 第 7 个</description></item><item><title>1.3.4</title><link>https://alg4.ikesnowy.com/1-3-4/</link><pubDate>Wed, 16 May 2018 09:07:30 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-4/</guid><description>1.3.4 # 解答 # 官方 JAVA 版本参考：Parentheses.java。
遇到左括号就入栈，遇到右括号就检查是否和栈顶的左括号匹配，如果匹配则弹栈，否则返回 false。
结束时如果栈不为空则返回 false，否则返回 true。
代码 # using System; using Generics; namespace _1._3._4 { /* * 1.3.4 * * 编写一个 Stack 的用例 Parentheses， * 从标准输入中读取一个文本流并使用栈判定其中的括号是否配对完整。 * 例如，对于 [()]{}{[()()]()} 程序应该打印 true， * 对于 [(]) 则打印 false。 * */ class Parentheses { static bool isBalanced(string input) { Stack&amp;lt;char&amp;gt; stack = new Stack&amp;lt;char&amp;gt;(); foreach (char i in input) { if (i == &amp;#39;(&amp;#39; || i == &amp;#39;[&amp;#39; || i == &amp;#39;{&amp;#39;) stack.</description></item><item><title>1.3.5</title><link>https://alg4.ikesnowy.com/1-3-5/</link><pubDate>Wed, 16 May 2018 09:09:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-5/</guid><description>1.3.5 # 解答 # 实际上是用除二取余法求一个十进制数的二进制形式。
代码 # using System; using Generics; namespace _1._3._5 { /* * 1.3.5 * * 当 N 为 50 时下面这段代码会打印什么？ * 从较高的抽象层次描述给定正整数 N 时这段代码的行为。 * */ class Program { //将十进制数 N 转换为二进制数。 static void Main(string[] args) { int N = 50; Stack&amp;lt;int&amp;gt; stack = new Stack&amp;lt;int&amp;gt;(); while (N &amp;gt; 0) { stack.</description></item><item><title>1.3.6</title><link>https://alg4.ikesnowy.com/1-3-6/</link><pubDate>Wed, 16 May 2018 09:10:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-6/</guid><description>1.3.6 # 解答 # 利用一个栈对队列元素进行反序操作。
先把队列中的元素全部入栈，再依次弹出并加入队列中。
代码 # using System; using Generics; namespace _1._3._6 { /* * 1.3.6 * * 下面这段代码对队列 q 进行了什么操作？ * */ class Program { //将队列反序 static void Main(string[] args) { Queue&amp;lt;string&amp;gt; q = new Queue&amp;lt;string&amp;gt;(); q.Enqueue(&amp;#34;first&amp;#34;); q.Enqueue(&amp;#34;second&amp;#34;); q.Enqueue(&amp;#34;third&amp;#34;); q.Enqueue(&amp;#34;fourth&amp;#34;); Stack&amp;lt;string&amp;gt; stack = new Stack&amp;lt;string&amp;gt;(); while (!q.IsEmpty()) stack.Push(q.Dequeue()); while (!</description></item><item><title>1.3.7</title><link>https://alg4.ikesnowy.com/1-3-7/</link><pubDate>Wed, 16 May 2018 09:11:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-7/</guid><description>1.3.7 # 解答 # 链表实现的话就是返回第一个结点 first 的 item 字段。
数组实现的话就是返回 first 对应的数组元素。
这里给出链表实现，完整实现见习题 1.3.2 的代码。
代码 # /// &amp;lt;summary&amp;gt; /// 返回栈顶元素（但不弹出它）。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public Item Peek() { if (IsEmpty()) throw new InvalidOperationException(&amp;#34;Stack Underflow&amp;#34;); return this.first.item; }</description></item><item><title>1.3.8</title><link>https://alg4.ikesnowy.com/1-3-8/</link><pubDate>Wed, 16 May 2018 09:12:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-8/</guid><description>1.3.8 # 解答 # 首先是 DoublingStackOfStrings 类，据我猜测应该是用数组实现的栈，扩容时长度增加一倍，缩短时长度减小一半。
官方 JAVA 代码参考：FixedCapacityStackOfString.java。
代码 # DoublingStackOfStrings 类
using System; using System.Collections; using System.Collections.Generic; namespace _1._3._8 { class DoublingStackOfStrings : IEnumerable&amp;lt;string&amp;gt; { private string[] items; private int count; /// &amp;lt;summary&amp;gt; /// 新建一个字符串栈。 /// &amp;lt;/summary&amp;gt; public DoublingStackOfStrings() { this.items = new string[2]; this.count = 0; } /// &amp;lt;summary&amp;gt; /// 检查栈是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return this.</description></item><item><title>1.3.9</title><link>https://alg4.ikesnowy.com/1-3-9/</link><pubDate>Wed, 16 May 2018 09:18:49 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-9/</guid><description>1.3.9 # 解答 # 在计算中序表达式算法的基础上做修改。
压入数字时将该数字所在的位置也一并压入。
弹出数字进行运算时在位置靠前的数字前加上左括号。
A + B ) * C + D ) ) 为例。
A 压入栈中并记录位置 。
&amp;lsquo;+&amp;rsquo; 压入栈中。
B 压入栈中并记录位置。
) 计算，在 A 之前加入左括号，结果 E 压入栈中，位置为 A 的位置。
&amp;lsquo;*&amp;rsquo; 压入栈中。
C 压入栈中并记录位置。
&amp;lsquo;+&amp;rsquo; 压入栈中。
D 压入栈中并记录位置。
) 计算，在 C 之前加入左括号，结果 F 压入栈中，位置为 C 的位置。
) 计算，在 E 之前加入左括号（也就是 A 之前），结果 G 压入栈中，位置为 E 的位置。
代码 # using System; using Generics; namespace _1.</description></item><item><title>1.3.10</title><link>https://alg4.ikesnowy.com/1-3-10/</link><pubDate>Thu, 17 May 2018 20:53:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-10/</guid><description>1.3.10 # 解答 # 官方 JAVA 代码：InfixToPostfix.java。
其实就是把右括号换成相应运算符
对于 (A + B)，忽略左括号，数字直接输出，运算符入栈，遇到右括号时再弹出
结果 A B +，变成后序表达式
代码 # using System; using Generics; namespace _1._3._10 { /* * 1.3.10 * * 编写一个过滤器 InfixToPostfix， * 将算术表达式由中序表达式转为后序表达式。 * */ class InfixToPostfix { //其实就是把右括号换成相应运算符 //对于 (A + B)，忽略左括号，数字直接输出，运算符入栈，遇到右括号时再弹出 //结果 A B +，变成后序表达式 static void Main(string[] args) { Stack&amp;lt;string&amp;gt; stack = new Stack&amp;lt;string&amp;gt;(); string[] input = &amp;#34;( 2 + ( ( 3 + 4 ) * ( 5 * 6 ) ) )&amp;#34;.</description></item><item><title>1.3.11</title><link>https://alg4.ikesnowy.com/1-3-11/</link><pubDate>Thu, 17 May 2018 20:57:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-11/</guid><description>1.3.11 # 解答 # 官方 JAVA 代码：EvaluatePostfix.java。
遇到数字就入栈，遇到运算符就弹出两个数字运算，再把结果入栈。
如果倒着读取的话也可以用递归做，当作前序表达式计算即可。
代码 # using System; using Generics; namespace _1._3._11 { /* * 1.3.11 * * 编写一段程序 EvaluatePostfix，从标准输入中得到一个后序表达式，求值并打印结果 * （将上一题的程序中得到的输出用管道传递给这一段程序可以得到和 Evaluate 相同的行为）。 * */ class EvaluatePostfix { static void Main(string[] args) { Stack&amp;lt;int&amp;gt; stack = new Stack&amp;lt;int&amp;gt;(); string[] input = &amp;#34;7 16 * 5 + 16 * 3 + 16 * 1 +&amp;#34;.</description></item><item><title>1.3.12</title><link>https://alg4.ikesnowy.com/1-3-12/</link><pubDate>Thu, 17 May 2018 21:00:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-12/</guid><description>1.3.12 # 解答 # 先用 foreach 语句遍历一遍栈，把所有元素都压入一个临时栈中。
此时临时栈变成了源栈的一个倒序副本。
再将临时栈中的元素依次压入目标栈中，就得到了源栈的一个副本。
代码 # using System; using Generics; namespace _1._3._12 { /* * 1.3.12 * * 编写一个可迭代的 Stack 用例，它含有一个静态的 CopyTo() 方法， * 接受一个字符串的栈作为参数并返回该栈的一个副本。 * 注意：这种能力是迭代器价值的一个重要体现， * 因为有了它我们无需改变基本 API 就能实现这种功能。 * */ class Program { static void Main(string[] args) { Stack&amp;lt;string&amp;gt; src = new Stack&amp;lt;string&amp;gt;(); src.Push(&amp;#34;first&amp;#34;); src.Push(&amp;#34;second&amp;#34;); src.Push(&amp;#34;third&amp;#34;); Stack&amp;lt;string&amp;gt; des = CopyTo(src); while (!</description></item><item><title>1.3.13</title><link>https://alg4.ikesnowy.com/1-3-13/</link><pubDate>Thu, 17 May 2018 21:03:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-13/</guid><description>1.3.13 # 解答 # 除了第一个以外都不可能。
根据题意，0 一定是最先入列的。
那么根据队列的特性，0 一定是最先出列的，因此除第一个以外其他几个序列都不可能。</description></item><item><title>1.3.14</title><link>https://alg4.ikesnowy.com/1-3-14/</link><pubDate>Thu, 17 May 2018 21:45:37 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-14/</guid><description>1.3.14 # 解答 # 对于 ResizingArrayQueueOfStrings 类，给出官方 JAVA 代码参考：ResizingArrayQueue.java。
代码 # ResizingArrayQueue 类 # using System; using System.Collections; using System.Collections.Generic; namespace _1._3._14 { class ResizingArrayQueueOfStrings&amp;lt;Item&amp;gt; : IEnumerable&amp;lt;Item&amp;gt; { private Item[] q; private int count; private int first; private int last; public ResizingArrayQueueOfStrings() { this.q = new Item[2]; this.count = 0; this.first = 0; } public bool IsEmpty() { return this.</description></item><item><title>1.3.15</title><link>https://alg4.ikesnowy.com/1-3-15/</link><pubDate>Thu, 17 May 2018 21:47:53 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-15/</guid><description>1.3.15 # 解答 # 方法有很多，只要把所有输入保存，之后算出倒数第 k 个是正数第几个就可以了。
这里先全部入队，之后算出是正数第几个，再把前面的元素全部出队，剩下的第一个就是要求的元素了。
代码 # using System; using Generics; namespace _1._3._15 { /* * 1.3.15 * * 编写一个 Queue 的用例，接受一个命令行参数 k 并打印出标准输入中的倒数第 k 个字符串 * （假设标准输入中至少有 k 个字符串）。 * */ class Program { static void Main(string[] args) { Queue&amp;lt;string&amp;gt; queue = new Queue&amp;lt;string&amp;gt;(); string[] input = &amp;#34;1 2 3 4 5 6 7 8 9 10&amp;#34;.</description></item><item><title>1.3.16</title><link>https://alg4.ikesnowy.com/1-3-16/</link><pubDate>Thu, 17 May 2018 21:49:22 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-16/</guid><description>1.3.16 # 解答 # 在习题 1.2.19 里已经写好了接受字符串作为参数构造函数
这里只要把所有字符串读入并调用相应构造函数就可以了。
代码 # /// &amp;lt;summary&amp;gt; /// 从标准输入按行读取所有日期，返回一个日期数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static Date[] ReadDates() { char[] split = new char[] { &amp;#39;\n&amp;#39; }; string[] input = Console.In.ReadToEnd().Split(split, StringSplitOptions.RemoveEmptyEntries); Date[] d = new Date[input.Length]; for (int i = 0; i &amp;lt; input.Length; ++i) { d[i] = new Date(input[i]); } return d; }</description></item><item><title>1.3.17</title><link>https://alg4.ikesnowy.com/1-3-17/</link><pubDate>Thu, 17 May 2018 21:50:46 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-17/</guid><description>1.3.17 # 解答 # 和前一题类似，按行读取输入再调用相应构造函数就可以了。
代码 # /// &amp;lt;summary&amp;gt; /// 从标准输入中按行读取所有交易信息，返回一个 Transaction 数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static Transaction[] ReadTransactions() { char[] split = new char[] { &amp;#39;\n&amp;#39; }; string[] input = Console.In.ReadToEnd().Split(split, StringSplitOptions.RemoveEmptyEntries); Transaction[] t = new Transaction[input.Length]; for (int i = 0; i &amp;lt; input.Length; ++i) { t[i] = new Transaction(input[i]); } return t; }</description></item><item><title>1.3.18</title><link>https://alg4.ikesnowy.com/1-3-18/</link><pubDate>Thu, 17 May 2018 21:51:41 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-18/</guid><description>1.3.18 # 解答 # 删除该结点的下一个结点。
如下图，没有任何结点指向 y 结点，失去了所有引用的 y 结点会被 GC 清理掉。
代码 # using System; using Generics; namespace _1._3._18 { /* * 1.3.18 * * 假设 x 是一条链表的某个结点且不是尾结点。 * 下面这条语句的效果是什么？ * x.next = x.next.next; * */ class Program { //删除 x 的后一个结点。 static void Main(string[] args) { Node&amp;lt;string&amp;gt; x = new Node&amp;lt;string&amp;gt;(); x.item = &amp;#34;first&amp;#34;; Node&amp;lt;string&amp;gt; y = new Node&amp;lt;string&amp;gt;(); y.</description></item><item><title>1.3.19</title><link>https://alg4.ikesnowy.com/1-3-19/</link><pubDate>Thu, 17 May 2018 21:53:54 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-19/</guid><description>1.3.19 # 解答 # 建立一个结点引用 Cur，让它移动到尾结点的前一个结点，让那个结点的 next 变为 null。
代码 # using System; using Generics; namespace _1._3._19 { /* * 1.3.19 * * 给出一段代码，删除链表的尾结点，其中链表的首结点为 first。 * */ class Program { static void Main(string[] args) { Node&amp;lt;string&amp;gt; first = new Node&amp;lt;string&amp;gt;() { item = &amp;#34;first&amp;#34; }; Node&amp;lt;string&amp;gt; second = new Node&amp;lt;string&amp;gt;() { item = &amp;#34;second&amp;#34; }; Node&amp;lt;string&amp;gt; third = new Node&amp;lt;string&amp;gt;() { item = &amp;#34;third&amp;#34; }; first.</description></item><item><title>1.3.20</title><link>https://alg4.ikesnowy.com/1-3-20/</link><pubDate>Fri, 18 May 2018 13:17:15 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-20/</guid><description>1.3.20 # 解答 # 和上一题类似，只不过这次让 Cur 移动 k – 1 次即可。
代码 # /// &amp;lt;summary&amp;gt; /// 删除指定位置的元素，返回该元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;index&amp;#34;&amp;gt;需要删除元素的位置。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public Item Delete(int index) { if (index &amp;gt;= this.count) { throw new IndexOutOfRangeException(); } Node&amp;lt;Item&amp;gt; front = this.first; Item temp = this.first.item; if (index == 0) { this.first = this.first.next; return temp; } for (int i = 1; i &amp;lt; index; ++i) { front = front.</description></item><item><title>1.3.21</title><link>https://alg4.ikesnowy.com/1-3-21/</link><pubDate>Fri, 18 May 2018 13:28:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-21/</guid><description>1.3.21 # 解答 # 遍历整条链表，方法和前两题类似，用一个结点引用 Cur 去访问就可以了。
代码 # using System; using Generics; namespace _1._3._21 { /* * 1.3.21 * * 编写一个方法 find()，接受一条链表和一个字符串 key 作为参数。 * 如果链表中的某个结点的 item 域的值为 key，则方法返回 true，否则返回 false。 * */ class Program { static void Main(string[] args) { LinkedList&amp;lt;string&amp;gt; link = new LinkedList&amp;lt;string&amp;gt;(); link.Insert(&amp;#34;first&amp;#34;, 0); link.Insert(&amp;#34;second&amp;#34;, 1); link.Insert(&amp;#34;third&amp;#34;, 2); Console.WriteLine(Find(link, &amp;#34;second&amp;#34;)); Console.</description></item><item><title>1.3.22</title><link>https://alg4.ikesnowy.com/1-3-22/</link><pubDate>Fri, 18 May 2018 13:30:20 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-22/</guid><description>1.3.22 # 解答 # 在 x 之后插入 t，如下图所示。
代码 # using System; using Generics; namespace _1._3._22 { /* * 1.3.22 * * 假设 x 是一条链表中的某个结点，下面这段代码做了什么？ * */ class Program { //将 t 插入到 x 之后 static void Main(string[] args) { Node&amp;lt;string&amp;gt; first = new Node&amp;lt;string&amp;gt;(); Node&amp;lt;string&amp;gt; second = new Node&amp;lt;string&amp;gt;(); Node&amp;lt;string&amp;gt; third = new Node&amp;lt;string&amp;gt;(); Node&amp;lt;string&amp;gt; fourth = new Node&amp;lt;string&amp;gt;(); first.</description></item><item><title>1.3.23</title><link>https://alg4.ikesnowy.com/1-3-23/</link><pubDate>Fri, 18 May 2018 13:32:39 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-23/</guid><description>1.3.23 # 解答 # 由于先后问题，y 在第一句代码执行完毕之后无法访问，t 的 next 会指向自己。
代码 # using System; using Generics; namespace _1._3._23 { /* * 1.3.23 * * 为什么下面这段代码和上一题中的代码效果不同？ * */ class Program { //x.next = t x 的下一个是 t //t.next = x.next t 的下一个和 x 的下一个相同（也就是 t） //于是 t.next = t, 遍历会出现死循环。 static void Main(string[] args) { Node&amp;lt;string&amp;gt; first = new Node&amp;lt;string&amp;gt;(); Node&amp;lt;string&amp;gt; second = new Node&amp;lt;string&amp;gt;(); Node&amp;lt;string&amp;gt; third = new Node&amp;lt;string&amp;gt;(); Node&amp;lt;string&amp;gt; fourth = new Node&amp;lt;string&amp;gt;(); first.</description></item><item><title>1.3.24</title><link>https://alg4.ikesnowy.com/1-3-24/</link><pubDate>Fri, 18 May 2018 13:34:29 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-24/</guid><description>1.3.24 # 解答 # 直接把该节点的 next 域设为 null，后续元素就会因无法访问而被清理掉。
代码 # using System; using Generics; namespace _1._3._24 { /* * 1.3.24 * * 编写一个方法 removeAfter()，接受一个链表结点作为参数并删除该结点的后续结点。 * （如果参数结点的后续结点为空则什么也不做） * */ class Program { static void Main(string[] args) { Node&amp;lt;string&amp;gt; first = new Node&amp;lt;string&amp;gt;(); Node&amp;lt;string&amp;gt; second = new Node&amp;lt;string&amp;gt;(); Node&amp;lt;string&amp;gt; third = new Node&amp;lt;string&amp;gt;(); Node&amp;lt;string&amp;gt; fourth = new Node&amp;lt;string&amp;gt;(); first.</description></item><item><title>1.3.25</title><link>https://alg4.ikesnowy.com/1-3-25/</link><pubDate>Fri, 18 May 2018 13:36:17 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-25/</guid><description>1.3.25 # 解答 # 见练习 1.3.22，加入一些对边界情况的处理即可。
代码 # using System; using Generics; namespace _1._3._25 { /* * 1.3.25 * * 编写一个方法 insertAfter()，接受两个链表结点作为参数， * 将第二个结点插入链表并使之成为第一个结点的后续结点 * （如果两个参数为空则什么也不做）。 * */ class Program { static void Main(string[] args) { Node&amp;lt;string&amp;gt; first = new Node&amp;lt;string&amp;gt;(); Node&amp;lt;string&amp;gt; second = new Node&amp;lt;string&amp;gt;(); Node&amp;lt;string&amp;gt; third = new Node&amp;lt;string&amp;gt;(); first.item = &amp;#34;first&amp;#34;; second.item = &amp;#34;second&amp;#34;; third.</description></item><item><title>1.3.26</title><link>https://alg4.ikesnowy.com/1-3-26/</link><pubDate>Fri, 18 May 2018 16:28:21 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-26/</guid><description>1.3.26 # 解答 # 之前已经写过了删除指定结点（习题 1.3.20）和查找指定结点（习题 1.3.21），结合使用即可。
代码 # using System; using Generics; namespace _1._3._26 { /* * 1.3.26 * * 编写一个方法 remove()，接受一条链表和一个字符串 key 作为参数， * 删除链表中所有 item 域为 key 的结点。 * */ class Program { static void Main(string[] args) { LinkedList&amp;lt;string&amp;gt; link = new LinkedList&amp;lt;string&amp;gt;(); link.Insert(&amp;#34;first&amp;#34;, 0); link.Insert(&amp;#34;second&amp;#34;, 1); link.Insert(&amp;#34;third&amp;#34;, 2); link.Insert(&amp;#34;third&amp;#34;, 3); link.Insert(&amp;#34;third&amp;#34;, 4); Console.</description></item><item><title>1.3.27</title><link>https://alg4.ikesnowy.com/1-3-27/</link><pubDate>Fri, 18 May 2018 16:31:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-27/</guid><description>1.3.27 # 解答 # 遍历一遍即可。
代码 # using System; using Generics; namespace _1._3._27 { /* * 1.3.27 * * 编写一个方法 max()，接受一条链表的首结点作为参数，返回链表中键最大的节点的值。 * 假设所有键均为正整数，如果链表为空则返回 0。 * */ class Program { static void Main(string[] args) { Node&amp;lt;int&amp;gt; first = new Node&amp;lt;int&amp;gt;(); Node&amp;lt;int&amp;gt; second = new Node&amp;lt;int&amp;gt;(); Node&amp;lt;int&amp;gt; third = new Node&amp;lt;int&amp;gt;(); Node&amp;lt;int&amp;gt; fourth = new Node&amp;lt;int&amp;gt;(); first.item = 1; second.</description></item><item><title>1.3.28</title><link>https://alg4.ikesnowy.com/1-3-28/</link><pubDate>Fri, 18 May 2018 16:32:46 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-28/</guid><description>1.3.28 # 解答 # 其实链表本身就是一个递归结构，链表的定义可以用递归的方式表示：
链表 = 头结点A + 链表B = 头结点A + 头结点B + 链表C……
所以 Max() 可以这么写：
Max(Node&amp;lt;Item&amp;gt; Cur, int nowmax) 如果 Cur 为空，则直接返回 nowmax。 否则检查 Cur 结点的值是否大于目前找到的最大值 nowmax。 如果不大于，继续查找下一个结点，返回 Max(Cur.next, nowmax) 否则，把 nowmax 修改为当前结点的值，继续查找，返回 Max(Cur.next, Cur.item) 代码 # using System; using Generics; namespace _1._3._28 { /* * 1.3.28 * * 用递归方法解答上一道练习。 * */ class Program { static void Main(string[] args) { Node&amp;lt;int&amp;gt; first = new Node&amp;lt;int&amp;gt;(); Node&amp;lt;int&amp;gt; second = new Node&amp;lt;int&amp;gt;(); Node&amp;lt;int&amp;gt; third = new Node&amp;lt;int&amp;gt;(); Node&amp;lt;int&amp;gt; fourth = new Node&amp;lt;int&amp;gt;(); first.</description></item><item><title>1.3.29</title><link>https://alg4.ikesnowy.com/1-3-29/</link><pubDate>Fri, 18 May 2018 16:35:56 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-29/</guid><description>1.3.29 # 解答 # 其实就是一个长这样的链表： 显然说 first 和最后一个节点的指针重复了，所以我们只需要保留 last 的指针就行了。
入队（注意顺序） 出队
代码 # Queue.cs # using System; using System.Collections; using System.Collections.Generic; using System.Text; namespace _1._3._29 { public class Queue&amp;lt;Item&amp;gt; : IEnumerable&amp;lt;Item&amp;gt; { private Node&amp;lt;Item&amp;gt; last; private int count; /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; public Queue() { this.last = null; this.count = 0; } /// &amp;lt;summary&amp;gt; /// 检查队列是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return this.</description></item><item><title>1.3.30</title><link>https://alg4.ikesnowy.com/1-3-30/</link><pubDate>Fri, 18 May 2018 16:42:54 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-30/</guid><description>1.3.30 # 解答 # 书中给出了代码，这里说一下递归的实现。
如果说一个链表除了第一个结点剩下的都已经反转了，那么我们就只要把该结点插入到最后就行了（也就是原先的第二个结点之后）。
像这样：
代码 # using System; using Generics; namespace _1._3._30 { /* * 1.3.30 * * 编写一个函数，接受一条链表的首结点作为参数， * （破坏性地）将链表反转并返回链表的首结点。 * */ class Program { static void Main(string[] args) { Node&amp;lt;string&amp;gt; first = new Node&amp;lt;string&amp;gt;(); Node&amp;lt;string&amp;gt; second = new Node&amp;lt;string&amp;gt;(); Node&amp;lt;string&amp;gt; third = new Node&amp;lt;string&amp;gt;(); Node&amp;lt;string&amp;gt; fourth = new Node&amp;lt;string&amp;gt;(); first.item = &amp;#34;first&amp;#34;; second.</description></item><item><title>1.3.31</title><link>https://alg4.ikesnowy.com/1-3-31/</link><pubDate>Fri, 18 May 2018 16:56:58 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-31/</guid><description>1.3.31 # 解答 # 双向链表的插入有顺序，务必当心。
双向链表长这样（似乎有一种画法是把空指针画成“接地”的样子）：
删除中间那个： 再插回去：
原则是不要让有用的结点变得无法访问。
代码 # DoubleNode&amp;lt;&amp;gt; # using System; using System.Collections; using System.Collections.Generic; using System.Text; namespace _1._3._31 { /* * 1.3.31 * * 实现一个嵌套类 DoubleNode 用来构造双向链表， * 其中每个结点都含有一个指向前驱元素的应用和一项指向后续元素的引用（如果不存在则为 null）。 * 为以下任务实现若干静态方法： * 在表头插入结点。 * 在表尾插入结点。 * 从表头删除结点。 * 从表尾删除结点。 * 在指定结点之前插入新结点。 * 在指定结点之后插入新结点。 * 删除指定结点。 * */ public class DoubleLinkList&amp;lt;Item&amp;gt; : IEnumerable&amp;lt;Item&amp;gt; { private class DoubleNode&amp;lt;T&amp;gt; { public T item; public DoubleNode&amp;lt;T&amp;gt; prev; public DoubleNode&amp;lt;T&amp;gt; next; } DoubleNode&amp;lt;Item&amp;gt; first; DoubleNode&amp;lt;Item&amp;gt; last; int count; /// &amp;lt;summary&amp;gt; /// 建立一条双向链表。 /// &amp;lt;/summary&amp;gt; public DoubleLinkList() { this.</description></item><item><title>1.3.32</title><link>https://alg4.ikesnowy.com/1-3-32/</link><pubDate>Fri, 18 May 2018 17:00:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-32/</guid><description>1.3.32 # 解答 # 在队列的基础上增加一个在队首插入元素的方法即可。
代码 # Steque.cs # using System; using System.Collections; using System.Collections.Generic; using System.Text; namespace _1._3._32 { //API: //public class Steque&amp;lt;Item&amp;gt; : Ienumerable&amp;lt;Item&amp;gt; // public Steque(); 默认构造函数。 // public bool IsEmpty(); 检查 Steque 是否为空。 // public int Size(); 返回 Steque 中的元素数量。 // public void Push(Item item); 向 Steque 中压入一个元素。 // public Item Pop(); 从 Steque 中弹出一个元素。 // public void Peek(); 返回栈顶元素（但不弹出它）。 // public void Enqueue(Item item); 将一个元素添加入 Steque 中。 public class Steque&amp;lt;Item&amp;gt; : IEnumerable&amp;lt;Item&amp;gt; { private Node&amp;lt;Item&amp;gt; first; private Node&amp;lt;Item&amp;gt; last; private int count; private class Node&amp;lt;T&amp;gt; { public T item; public Node&amp;lt;T&amp;gt; next; } /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; public Steque() { this.</description></item><item><title>1.3.33</title><link>https://alg4.ikesnowy.com/1-3-33/</link><pubDate>Fri, 18 May 2018 17:03:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-33/</guid><description>1.3.33 # 解答 # 动态数组这里要注意 first 不要小于零。
代码 # Deque 类 # using System; using System.Collections; using System.Collections.Generic; namespace _1._3._33 { public class Deque&amp;lt;Item&amp;gt; : IEnumerable&amp;lt;Item&amp;gt; { private class DoubleNode&amp;lt;T&amp;gt; { public T item; public DoubleNode&amp;lt;T&amp;gt; next; public DoubleNode&amp;lt;T&amp;gt; prev; } DoubleNode&amp;lt;Item&amp;gt; first; DoubleNode&amp;lt;Item&amp;gt; last; int count; /// &amp;lt;summary&amp;gt; /// 默认构造函数，建立一个双端队列。 /// &amp;lt;/summary&amp;gt; public Deque() { this.</description></item><item><title>1.3.34</title><link>https://alg4.ikesnowy.com/1-3-34/</link><pubDate>Fri, 18 May 2018 17:06:58 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-34/</guid><description>1.3.34 # 解答 # 在初始化迭代器的时候随机生成一个访问序列，
之后按照这个访问序列进行迭代即可。
代码 # RandomBag.cs # using System; using System.Collections; using System.Collections.Generic; namespace _1._3._34 { public class RandomBag&amp;lt;Item&amp;gt; : IEnumerable&amp;lt;Item&amp;gt; { private Item[] bag; private int count; /// &amp;lt;summary&amp;gt; /// 建立一个随机背包。 /// &amp;lt;/summary&amp;gt; public RandomBag() { this.bag = new Item[2]; this.count = 0; } /// &amp;lt;summary&amp;gt; /// 检查背包是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return this.</description></item><item><title>1.3.35</title><link>https://alg4.ikesnowy.com/1-3-35/</link><pubDate>Fri, 18 May 2018 17:15:02 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-35/</guid><description>1.3.35 # 解答 # 事实上只需要在普通队列的基础上稍作修改就可以了。
出队时先随机选择一个元素，之后让它和最开始的元素做交换，之后正常出队即可。
代码 # RandomQueue.cs # using System; namespace _1._3._35 { public class RandomQueue&amp;lt;Item&amp;gt; { private Item[] queue; private int count; /// &amp;lt;summary&amp;gt; /// 新建一个随机队列。 /// &amp;lt;/summary&amp;gt; public RandomQueue() { this.queue = new Item[2]; this.count = 0; } /// &amp;lt;summary&amp;gt; /// 判断队列是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return this.</description></item><item><title>1.3.36</title><link>https://alg4.ikesnowy.com/1-3-36/</link><pubDate>Fri, 18 May 2018 17:16:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-36/</guid><description>1.3.36 # 解答 # 实现方法和 1.3.34 类似，初始化迭代器的时候同时初始化一个随机访问序列。
代码 # RandomQueue.cs # using System; using System.Collections; using System.Collections.Generic; namespace _1._3._36 { public class RandomQueue&amp;lt;Item&amp;gt; : IEnumerable&amp;lt;Item&amp;gt; { private Item[] queue; private int count; /// &amp;lt;summary&amp;gt; /// 新建一个随机队列。 /// &amp;lt;/summary&amp;gt; public RandomQueue() { this.queue = new Item[2]; this.count = 0; } /// &amp;lt;summary&amp;gt; /// 判断队列是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return this.</description></item><item><title>1.3.37</title><link>https://alg4.ikesnowy.com/1-3-37/</link><pubDate>Fri, 18 May 2018 17:17:26 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-37/</guid><description>1.3.37 # 解答 # 也就是约瑟夫问题，官方给出的 JAVA 版答案：Josephus.java。
报数时将一个人出队然后入队来模拟一个环。
报到 M 个后将那个人出队但不入队（删除）
随后继续循环。
代码 # using System; using Generics; namespace _1._3._37 { /* * 1.3.37 * * Josephus 问题。 * 在这个古老的问题中，N 个身陷绝境的人一致同意通过以下方式减少生存人数。 * 他们围坐成一圈（位置记作 0 到 N-1）并从第一个人开始报数， * 报到 M 的人会被杀死，直到最后一个人留下来。 * 传说中 Josephus 找到了不会被杀死的位置。 * 编写一个 Queue 的用例 Josephus，从命令行接受 N 和 M 并打印出人们被杀死的顺序 * （这也将显示 Josephus 在圈中的位置）。 * */ class Program { static void Main(string[] args) { int numOfPeople = 7; int callForDeath = 2; Queue&amp;lt;int&amp;gt; queue = new Queue&amp;lt;int&amp;gt;(); for (int i = 0; i &amp;lt; numOfPeople; ++i) { queue.</description></item><item><title>1.3.38</title><link>https://alg4.ikesnowy.com/1-3-38/</link><pubDate>Fri, 18 May 2018 17:22:20 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-38/</guid><description>1.3.38 # 解答 # 这里采用“假删除”的方式，对要删除的元素不直接删除而是打上标记，这样就可以维持插入的顺序。
代码 # 数组实现 # using System; namespace _1._3._38 { class ArrayBasedGeneralizeQueue&amp;lt;Item&amp;gt; { private Item[] queue; private bool[] IsVisited; private int count; private int first; private int last; /// &amp;lt;summary&amp;gt; /// 建立一个队列。 /// &amp;lt;/summary&amp;gt; public ArrayBasedGeneralizeQueue() { this.queue = new Item[2]; this.IsVisited = new bool[2]; this.</description></item><item><title>1.3.39</title><link>https://alg4.ikesnowy.com/1-3-39/</link><pubDate>Fri, 18 May 2018 17:24:29 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-39/</guid><description>1.3.39 # 解答 # 可以直接套用队列的实现方式，在满或空时抛出相应异常。
代码 # using System; namespace _1._3._39 { class RingBuffer&amp;lt;Item&amp;gt; { private Item[] buffer; private int count; private int first; //读指针 private int last; //写指针 /// &amp;lt;summary&amp;gt; /// 建立一个缓冲区。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;N&amp;#34;&amp;gt;缓冲区的大小。&amp;lt;/param&amp;gt; public RingBuffer(int N) { this.buffer = new Item[N]; this.count = 0; this.first = 0; this.</description></item><item><title>1.3.40</title><link>https://alg4.ikesnowy.com/1-3-40/</link><pubDate>Fri, 18 May 2018 17:29:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-40/</guid><description>1.3.40 # 解答 # 每次插入时都先搜索一遍链表，再判定相应动作。
代码 # using System; using System.Text; namespace _1._3._40 { class MoveToFront&amp;lt;Item&amp;gt; { private class Node&amp;lt;T&amp;gt; { public T item; public Node&amp;lt;T&amp;gt; next; } private Node&amp;lt;Item&amp;gt; first; private int count; /// &amp;lt;summary&amp;gt; /// 检查编码组是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return this.first == null; } /// &amp;lt;summary&amp;gt; /// 建立一个前移编码组。 /// &amp;lt;/summary&amp;gt; public MoveToFront() { this.</description></item><item><title>1.3.41</title><link>https://alg4.ikesnowy.com/1-3-41/</link><pubDate>Mon, 21 May 2018 21:17:41 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-41/</guid><description>1.3.41 # 解答 # 可以按照书上的提示出队再入队，也可以直接用迭代器访问一遍进行复制。
代码 # /// &amp;lt;summary&amp;gt; /// 复制构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;r&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; public Queue(Queue&amp;lt;Item&amp;gt; r) { foreach (Item i in r) { Enqueue(i); } }</description></item><item><title>1.3.42</title><link>https://alg4.ikesnowy.com/1-3-42/</link><pubDate>Mon, 21 May 2018 21:19:12 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-42/</guid><description>1.3.42 # 解答 # 直接把链栈的整个链表复制一份即可。
代码 # /// &amp;lt;summary&amp;gt; /// 复制构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;s&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; public Stack(Stack&amp;lt;Item&amp;gt; s) { if (s.first != null) { this.first = new Node&amp;lt;Item&amp;gt;(s.first); for (Node&amp;lt;Item&amp;gt; x = this.first; x.next != null; x = x.next) { x.next = new Node&amp;lt;Item&amp;gt;(x.next); } } this.count = s.count; }</description></item><item><title>1.3.43</title><link>https://alg4.ikesnowy.com/1-3-43/</link><pubDate>Mon, 21 May 2018 21:20:19 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-43/</guid><description>1.3.43 # 解答 # C# 中可以用 Directory 类里面的几个方法来获得文件路径和文件名。
代码 # using System; using System.IO; using System.Linq; namespace _1._3._43 { /* * 1.3.43 * * 文件列表。 * 文件夹就是一列文件和文件夹的列表。 * 编写一个程序，从命令行接受一个文件夹名作为参数， * 打印出该文件夹下的所有文件并用递归的方式在所有子文件夹的名下（缩进）列出其下的所有文件。 * */ class Program { static void Main(string[] args) { //获取当前目录 string path = Directory.GetCurrentDirectory(); path = Directory.GetParent(path).FullName; path = Directory.GetParent(path).FullName; //获取文件 Console.WriteLine(path + &amp;#34;中的所有文件&amp;#34;); Search(path, 0); } static void Search(string path, int tabs) { string[] dirs = Directory.</description></item><item><title>1.3.44</title><link>https://alg4.ikesnowy.com/1-3-44/</link><pubDate>Mon, 21 May 2018 21:21:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-44/</guid><description>1.3.44 # 解答 # 这里我们使用两个栈来模拟缓冲区。
向左/向右移动 = 从左/右栈弹出相应数量的元素并压入另外一个栈。
插入/删除 = 左栈压入/弹出一个元素。
字符数量 = 左栈数量 + 右栈数量。
代码 # using Generics; namespace _1._3._44 { class Buffer { private Stack&amp;lt;char&amp;gt; leftside; private Stack&amp;lt;char&amp;gt; rightside; /// &amp;lt;summary&amp;gt; /// 建立一个文本缓冲区。 /// &amp;lt;/summary&amp;gt; public Buffer() { this.leftside = new Stack&amp;lt;char&amp;gt;(); this.rightside = new Stack&amp;lt;char&amp;gt;(); } /// &amp;lt;summary&amp;gt; /// 在光标位置插入字符 c。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;c&amp;#34;&amp;gt;要插入的字符。&amp;lt;/param&amp;gt; public void Insert(char c) { this.</description></item><item><title>1.3.45</title><link>https://alg4.ikesnowy.com/1-3-45/</link><pubDate>Tue, 22 May 2018 13:39:19 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-45/</guid><description>1.3.45 # 解答 # 书上已经给出了思路，简单说明一下。
第一问是给定输入判断是否会下溢出，只要记录栈中元素的数量即可，一旦为负数则返回 true。
第二问是给定输出判断是否可能。
对于输出序列中的每一个数，如果栈顶为空或者栈顶数字小于当前输出序列的数，那么就从输入序列中输入数字，直到栈顶数字和当前输出序列中的数字相等。
如果当前输出序列中的数字和栈顶元素相等，从栈中弹出相应元素。
最后如果栈为空则可能，否则不可能。
可以结合习题 1.3.3 的解答查看。
通用解法见下一题。
代码 # using System; using Generics; namespace _1._3._45 { /* * 1.3.45 * * 栈的可生成性。 * 假设我们的栈测试用例会进行一系列的入栈和出栈操作， * 序列中的整数 0, 1, ... , N - 1 （按此先后顺序排列）表示入栈操作，N个减号表示出栈操作。 * 设计一个算法，判定给定的混合序列是否会使数组向下溢出 * （你使用的空间量与 N 无关，即不能用某种数据结构存储所有整数）。 * 设计一个线性时间算法判定我们的测试用例能否产生某个给定的排列 * （这取决于出栈操作指令的出现位置）。 * */ class Program { static void Main(string[] args) { //给定输入序列，判断是否会出现下溢出。 string input = &amp;#34;- 0 1 2 3 4 5 6 7 8 9 - - - - - - - - -&amp;#34;; Console.</description></item><item><title>1.3.46</title><link>https://alg4.ikesnowy.com/1-3-46/</link><pubDate>Tue, 22 May 2018 13:41:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-46/</guid><description>1.3.46 # 解答 # 这道题的解答参考了这篇博文：http://ceeji.net/blog/forbidden-triple-for-stack-generability/。
显然书中的解答已经十分明确，这里简单说明一下：
首先有结论：对于栈顶元素 Sn，栈中所有小于 Sn 的值都以递减形式保存（已经输出的不算）。
表现在输出序列中，Sn 输出之后，如果有小于 Sn 的值输出，其顺序必定是递减的。
例如序列 4 3 2 1 0 9 8 7 6 5
4 输出之后，3 2 1 0 递减输出；9 输出之后，8 7 6 5 递减输出。
依次验证其中的每个值都能满足结论。
而对于序列 4 6 8 7 5 3 2 9 0 1
对于 4，之后的 3 2 1 0 并不是以递减顺序输出的，因此这个序列是不合法的。</description></item><item><title>1.3.47</title><link>https://alg4.ikesnowy.com/1-3-47/</link><pubDate>Tue, 22 May 2018 13:42:37 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-47/</guid><description>1.3.47 # 解答 # 这里用的都是链式结构，头尾相接即可。
代码 # Queue # /// &amp;lt;summary&amp;gt; /// 在当前队列之后附加一个队列。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;q1&amp;#34;&amp;gt;需要被附加的队列。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;q2&amp;#34;&amp;gt;需要附加的队列（将被删除）。&amp;lt;/param&amp;gt; public static Queue&amp;lt;Item&amp;gt; Catenation(Queue&amp;lt;Item&amp;gt; q1, Queue&amp;lt;Item&amp;gt; q2) { if (q1.IsEmpty()) { q1.first = q2.first; q1.last = q2.last; q1.count = q2.count; } else { q1.last.next = q2.first; q1.last = q2.last; q1.count += q2.count; } q2 = null; return q1; } Stack # /// &amp;lt;summary&amp;gt; /// 将两个栈连接。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;s1&amp;#34;&amp;gt;第一个栈。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;s2&amp;#34;&amp;gt;第二个栈（将被删除）。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static Stack&amp;lt;Item&amp;gt; Catenation(Stack&amp;lt;Item&amp;gt; s1, Stack&amp;lt;Item&amp;gt; s2) { if (s1.</description></item><item><title>1.3.48</title><link>https://alg4.ikesnowy.com/1-3-48/</link><pubDate>Wed, 23 May 2018 09:06:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-48/</guid><description>1.3.48 # 解答 # 按照双向队列原本的操作就可以实现，需要维护两个栈的长度以防越界。（左侧栈弹出了右侧栈栈底的内容）
代码 # using System; using System.Collections; using System.Collections.Generic; namespace _1._3._48 { public class DeStack&amp;lt;Item&amp;gt; : IEnumerable&amp;lt;Item&amp;gt; { private class DoubleNode&amp;lt;T&amp;gt; { public T item; public DoubleNode&amp;lt;T&amp;gt; next; public DoubleNode&amp;lt;T&amp;gt; prev; } DoubleNode&amp;lt;Item&amp;gt; first; DoubleNode&amp;lt;Item&amp;gt; last; int leftcount; int rightcount; /// &amp;lt;summary&amp;gt; /// 默认构造函数，建立一个双端栈。 /// &amp;lt;/summary&amp;gt; public DeStack() { this.</description></item><item><title>1.3.49</title><link>https://alg4.ikesnowy.com/1-3-49/</link><pubDate>Wed, 23 May 2018 09:17:09 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-49/</guid><description>1.3.49 # 解答 # 那么这里就使用六个栈来解决这个问题。 这个算法来自于这篇论文。
原文里用的是 Pure Lisp，不过语法很简单，还是很容易看懂的。
先导知识——用两个栈模拟一个队列 # 如何使用两个栈来模拟一个队列操作？
这是一道很经典的题目，答案也有很多种，这里只介绍之后会用到的一种方法。
首先我们有两个栈，H 和 T，分别用作出队和入队用。
这样，入队操作等同于向 T 添加元素，T 的入栈操作只需要 O(1) 时间。
如果 H 不为空，出队操作等同于 H 弹栈，H 的弹栈操作也只需要 O(1) 时间。
但如果 H 为空，则需要将 T 中的元素依次弹出并压入到 H 中，这是一个 O(n) 的操作。
显然，这种方式中，出队操作的最坏时间复杂度是 O(n)，并不满足题目要求。
分摊 O(n) # 那么，怎么解决这个问题呢？
一个很自然的想法是，如果在栈 H 变为空之前，我们就能逐步将栈 T 的内容弹出并压入到另一个栈 H&amp;rsquo; 中，等到栈 H 为空时，直接交换 H 和 H&amp;rsquo; 即可。
假设目前的队列状态是这样，有三个元素等待出队，还有三个元素等待入队。
现在依次让三个元素出队，与此同时我们让栈 T 中的元素依次进入 H&amp;rsquo; 中。
每一次出队都执行两个操作，元素出队和元素复制（Pop &amp;amp; Push），时间复杂度 O(1) + O(1) + O(1) = O(1)。</description></item><item><title>1.3.50</title><link>https://alg4.ikesnowy.com/1-3-50/</link><pubDate>Wed, 23 May 2018 16:52:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-50/</guid><description>1.3.50 # 解答 # 初始化迭代器的时候记录栈已经进行过的 Pop 和 Push 数，迭代的时候检查这两个值是否改变，一旦改变就抛出异常。
代码 # private class StackEnumerator : IEnumerator&amp;lt;Item&amp;gt; { private Stack&amp;lt;Item&amp;gt; s; private int popcount; private int pushcount; private Node&amp;lt;Item&amp;gt; current; public StackEnumerator(Stack&amp;lt;Item&amp;gt; s) { this.s = s; this.current = s.first; this.popcount = s.popcount; this.pushcount = s.pushcount; } Item IEnumerator&amp;lt;Item&amp;gt;.Current =&amp;gt; current.item; object IEnumerator.</description></item><item><title>1.4.1</title><link>https://alg4.ikesnowy.com/1-4-1/</link><pubDate>Wed, 23 May 2018 18:21:11 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-1/</guid><description>1.4.1 # 解答 # 即为证明组合计算公式：
$C(N, 3)$
$= N! / [(N - 3)! × 3!]$
$= [(N - 2) * (N - 1) * N] / 3!$
$= N(N - 1)(N - 2) / 6$
显然 N 必须大于等于 3。
$N = 3$ 时公式正确，只有一种组合。
$N = 4$ 时公式正确，只有四种组合。
扩展到 $N+1$ 个数，将 $N = N + 1$ 代入，可得：
$(N + 1)N(N - 1) / 6$
$N + 1$ 个数能组成的三位数组合可以这样理解
前 N 个数中取三个数的所有组合 +多出的一个数和前 N 个数中的任意取两个数的所有组合</description></item><item><title>1.4.2</title><link>https://alg4.ikesnowy.com/1-4-2/</link><pubDate>Wed, 23 May 2018 18:35:38 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-2/</guid><description>1.4.2 # 解答 # 将 a[i] + a[j] + a[k] 改为 (long)a[i] + a[j] + a[k] 即可。
此时整个式子将按照精度最高（也就是 long）的标准计算。
long.MaxValue = 9223372036854775807 &amp;gt; int.MaxValue * 3 = 6442450941 代码 # namespace Measurement { /// &amp;lt;summary&amp;gt; /// 用暴力方法寻找数组中和为零的三元组。 /// &amp;lt;/summary&amp;gt; public static class ThreeSum { /// &amp;lt;summary&amp;gt; /// 输出所有和为零的三元组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;输入数组。&amp;lt;/param&amp;gt; public static void PrintAll(int[] a) { int n = a.</description></item><item><title>1.4.3</title><link>https://alg4.ikesnowy.com/1-4-3/</link><pubDate>Wed, 23 May 2018 18:37:54 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-3/</guid><description>1.4.3 # 解答 # 见代码，这里贴出绘图函数，窗体只是在得到测试结果之后简单调用以下这两个函数。
代码 # public static void PaintLinear(double[] testResult) { //新建一个绘图窗口 Form2 linear = new Form2(); linear.Show(); //新建画布 Graphics canvas = linear.CreateGraphics(); //获取窗口区域 Rectangle rect = linear.ClientRectangle; //计算单位长度（十等分） int unitY = rect.Height / 10; int unitX = rect.Width / 10; //获取中心区域（上下左右增加 10% 的内补） Rectangle center = new Rectangle(rect.X + unitX, rect.Y + unitY, unitX * 8, unitY * 8); //绘制坐标系 canvas.</description></item><item><title>1.4.4</title><link>https://alg4.ikesnowy.com/1-4-4/</link><pubDate>Wed, 23 May 2018 18:39:06 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-4/</guid><description>1.4.4 # 解答 #</description></item><item><title>1.4.5</title><link>https://alg4.ikesnowy.com/1-4-5/</link><pubDate>Wed, 23 May 2018 18:41:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-5/</guid><description>1.4.5 # 解答 # 类似于取极限的做法。
a. $N$
b. $1$
c. $1$
d. $2N^3$
e. $1$
f. $2$
g. $\frac{N^{100}}{2^n}$</description></item><item><title>1.4.6</title><link>https://alg4.ikesnowy.com/1-4-6/</link><pubDate>Wed, 23 May 2018 20:49:24 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-6/</guid><description>1.4.6 # 解答 # a. N + N/2 + N/4 + … = ~2N，线性。
b. 1 + 2 + 4 + … = ~2N，线性。
c. NlogN，线性对数。</description></item><item><title>1.4.7</title><link>https://alg4.ikesnowy.com/1-4-7/</link><pubDate>Wed, 23 May 2018 21:11:35 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-7/</guid><description>1.4.7 # 解答 # 最外层循环进行了 N 次比较。
次外层循环进行了 N^2 次比较。
最里层循环进行了 N^3 次比较。
内部 if 语句进行了 N^3 次比较。
if 内部进行了 N(N-1) 次加法。
加起来，~2N^3。</description></item><item><title>1.4.8</title><link>https://alg4.ikesnowy.com/1-4-8/</link><pubDate>Wed, 23 May 2018 21:12:41 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-8/</guid><description>1.4.8 # 解答 # 平方级别：直接二层循环遍历一遍。
线性对数：
先对数组排序，然后遍历一遍数组，在遍历过程中计算重复元素的数量，
然后用公式 $1+2+\cdots+n-1=n(n-1)/2$ 计算重复整数对的数量。
代码 # /// &amp;lt;summary&amp;gt; /// 暴力查找数组中相等的整数对。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要查找的数组。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; static int CountEqual(int[] a) { int n = a.Length; int count = 0; for (int i = 0; i &amp;lt; n; i++) { for (int j = i + 1; j &amp;lt; n; j++) { if (a[i] == a[j]) count++; } } return count; } /// &amp;lt;summary&amp;gt; /// 利用 Array.</description></item><item><title>1.4.9</title><link>https://alg4.ikesnowy.com/1-4-9/</link><pubDate>Wed, 23 May 2018 21:14:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-9/</guid><description>1.4.9 # 解答 # 由题意可得：
$$ T(2N_0)=2^bT\newline T(4N_0)=2^b(2^bT)=2^{2b}T\newline &amp;hellip;&amp;hellip;\newline T(2^rN_0)=2^{rb}T $$
设：
$$ N=2^rN_0 $$
则：
$$ r=log_2(\frac{N}{N_0}) $$
所以：
$$ T(N) = 2^{log_2(\frac{N}{N_0})b}T $$</description></item><item><title>1.4.10</title><link>https://alg4.ikesnowy.com/1-4-10/</link><pubDate>Wed, 23 May 2018 21:19:21 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-10/</guid><description>1.4.10 # 解答 # 修改二分查找的结束条件，找到后仍然向左侧寻找，如果还能找到更小的，则返回较小的下标；否则返回当前下标。
代码 # namespace _1._4._10 { /// &amp;lt;summary&amp;gt; /// 二分查找。 /// &amp;lt;/summary&amp;gt; public class BinarySearch { /// &amp;lt;summary&amp;gt; /// 用递归方法进行二分查找。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;关键字。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;查找范围。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;lo&amp;#34;&amp;gt;查找的起始下标。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;hi&amp;#34;&amp;gt;查找的结束下标。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;返回下标，如果没有找到则返回 -1。&amp;lt;/returns&amp;gt; public static int Rank(int key, int[] a, int lo, int hi) { if (hi &amp;lt; lo) return -1; int mid = (hi - lo) / 2 + lo; if (a[mid] == key) { int mini = Rank(key, a, lo, mid - 1); if (mini !</description></item><item><title>1.4.11</title><link>https://alg4.ikesnowy.com/1-4-11/</link><pubDate>Wed, 23 May 2018 21:21:05 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-11/</guid><description>1.4.11 # 解答 # 这里给出官网上的 Java 实现：StaticSETofInts.java。
howMany() 可以用二分查找实现，在找到一个值后继续向两侧查找，最后返回找到的次数。
代码 # using System; namespace Measurement { /// &amp;lt;summary&amp;gt; /// 有序数组，能够快速查找并自动维护其中的顺序。 /// &amp;lt;/summary&amp;gt; public class StaticSETofInts { private int[] a; /// &amp;lt;summary&amp;gt; /// 用一个数组初始化有序数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;keys&amp;#34;&amp;gt;源数组。&amp;lt;/param&amp;gt; public StaticSETofInts(int[] keys) { this.a = new int[keys.Length]; for (int i = 0; i &amp;lt; keys.</description></item><item><title>1.4.12</title><link>https://alg4.ikesnowy.com/1-4-12/</link><pubDate>Wed, 23 May 2018 21:23:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-12/</guid><description>1.4.12 # 解答 # 由于两个数组都是有序的，可以同时进行比较。
设 i, j 分别为两个数组的下标。
如果 a[i] == a[j]，i 和 j 都向后移动一位。
如果 a[i] != a[j]，比较小的那个向后移动一位。
循环直到某个数组遍历完毕。
这样最后的时间复杂度 ~2N
代码 # using System; namespace _1._4._12 { /* * 1.4.12 * * 编写一个程序，有序打印给定的两个有序数组（含有 N 个 int 值） 中的所有公共元素， * 程序在最坏情况下所需的运行时间应该和 N 成正比。 * */ class Program { static void Main(string[] args) { int[] a = new int[4] { 2, 3, 4, 10 }; int[] b = new int[6] { 1, 3, 3, 5, 10, 11 }; //2N 次数组访问，数组 a 和数组 b 各遍历一遍 for (int i = 0, j = 0; i &amp;lt; a.</description></item><item><title>1.4.13</title><link>https://alg4.ikesnowy.com/1-4-13/</link><pubDate>Wed, 23 May 2018 21:25:06 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-13/</guid><description>1.4.13 # 解答 # 对象的固定开销用 Object 表示。
a. Accumulator 使用 1.2.4.3 节给出的实现。
= int * 1 + double + Object * 1 = 4 * 1 + 8 + 16 * 1 = 32 b. Transaction
= string * 1 + Date * 1 + double * 1 + Object * 1 = (40 + 16 + 4 + 4 + 2N) * 1 + (8 + 32) * 1 + 8 * 1 + 16 * 1 = 128 + 2N c.</description></item><item><title>1.4.14</title><link>https://alg4.ikesnowy.com/1-4-14/</link><pubDate>Wed, 23 May 2018 21:27:17 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-14/</guid><description>1.4.14 # 解答 # 这里给出暴力方法，将最内侧循环换成二分查找即为优化版本。
代码 # using System; namespace Measurement { /// &amp;lt;summary&amp;gt; /// 用暴力方法查找数组中和为零的四元组。 /// &amp;lt;/summary&amp;gt; public static class FourSum { /// &amp;lt;summary&amp;gt; /// 输出数组中所有和为 0 的四元组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;包含所有元素的数组。&amp;lt;/param&amp;gt; public static void PrintAll(long[] a) { int N = a.Length; for (int i = 0; i &amp;lt; N; ++i) { for (int j = i + 1; j &amp;lt; N; ++j) { for (int k = j + 1; k &amp;lt; N; ++k) { for (int l = k + 1; l &amp;lt; N; ++l) { if (a[i] + a[j] + a[k] + a[l] == 0) { Console.</description></item><item><title>1.4.15</title><link>https://alg4.ikesnowy.com/1-4-15/</link><pubDate>Wed, 23 May 2018 21:28:16 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-15/</guid><description>1.4.15 # 解答 # 由于数组已经排序（从小到大），负数在左侧，正数在右侧。
TwoSumFaster
设最左侧下标为 lo，最右侧下标为 hi。
如果 a[lo] + a[hi] &amp;gt; 0, 说明正数太大，hi&amp;ndash;。
如果 a[lo] + a[hi] &amp;lt; 0，说明负数太小，lo++。
否则就找到了一对和为零的整数对，lo++, hi&amp;ndash;。
ThreeSumFaster
对于数组中的每一个数 a，ThreeSum 问题就等于求剩余数组中所有和为 -a 的 TwoSum 问题。
只要在 TwoSumFaster 外层再套一个循环即可。
代码 # /// &amp;lt;summary&amp;gt; /// TwoSum 的快速实现。（线性级别） /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要查找的数组范围。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;数组中和为零的整数对数量。&amp;lt;/returns&amp;gt; static int TwoSumFaster(int[] a) { int lo = 0; int hi = a.Length - 1; int count = 0; while (lo &amp;lt; hi) { if (a[lo] + a[hi] == 0) { count++; lo++; hi--; } else if (a[lo] + a[hi] &amp;lt; 0) { lo++; } else { hi--; } } return count; } /// &amp;lt;summary&amp;gt; /// ThreeSum 的快速实现。（平方级别） /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要查找的数组范围。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;数组中和为零的三元组数量。&amp;lt;/returns&amp;gt; static int ThreeSumFaster(int[] a) { int count = 0; for (int i = 0; i &amp;lt; a.</description></item><item><title>1.4.16</title><link>https://alg4.ikesnowy.com/1-4-16/</link><pubDate>Wed, 23 May 2018 21:29:44 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-16/</guid><description>1.4.16 # 解答 # 先将数组从小到大排序，再遍历一遍即可得到差距最小的两个数。
排序算法需要消耗 NlogN，具体见 MSDN：Array.Sort 方法 (Array)。
代码 # using System; namespace _1._4._16 { /* * 1.4.16 * * 最接近一对（一维）。 * 编写一个程序，给定一个含有 N 个 double 值的数组 a[]， * 在其中找到一对最接近的值：两者之差（绝对值）最小的两个数。 * 程序在最坏情况下所需的运行时间应该是线性对数级别的。 * */ class Program { //总运行时间： NlogN + N = NlogN static void Main(string[] args) { double[] a = new double[5] { 0.1, 0.3, 0.</description></item><item><title>1.4.17</title><link>https://alg4.ikesnowy.com/1-4-17/</link><pubDate>Wed, 23 May 2018 21:31:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-17/</guid><description>1.4.17 # 解答 # 遍历找到最小值和最大值即可。
代码 # using System; namespace _1._4._17 { /* * 1.4.17 * * 最遥远的一对（一维）。 * 编写一个程序，给定一个含有 N 个 double 值的数组 a[]， * 在其中找到一对最遥远的值：两者之差（绝对值）最大的两个数。 * 程序在最坏情况下所需的运行时间应该是线性级别的。 * */ class Program { static void Main(string[] args) { double[] a = new double[5] { 0.1, 0.3, 0.6, 0.8, 0 }; double min = int.MaxValue; double max = int.</description></item><item><title>1.4.18</title><link>https://alg4.ikesnowy.com/1-4-18/</link><pubDate>Wed, 23 May 2018 21:38:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-18/</guid><description>1.4.18 # 解答 # 和二分查找的方式类似，先确认中间的值是否是局部最小，如果不是，则向较小的一侧二分查找。
在三个数中比较得到最小值需要两次比较，因此最坏情况下为 $~2\lg N$ 次比较。
代码 # using System; namespace _1._4._18 { class Program { static void Main(string[] args) { var a = new int[5] { 1, 2, 5, 3, 5 }; Console.WriteLine(LocalMinimum(a)); } /// &amp;lt;summary&amp;gt; /// 寻找数组的局部最小元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;寻找范围。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;局部最小元素的值。&amp;lt;/returns&amp;gt; static int LocalMinimum(int[] a) { int lo = 0; int hi = a.</description></item><item><title>1.4.19</title><link>https://alg4.ikesnowy.com/1-4-19/</link><pubDate>Wed, 23 May 2018 21:42:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-19/</guid><description>1.4.19 # 解答 # 问题类似于 POJ 上的一道题「滑雪」，从数值较高的一侧向周围数值较小的一侧移动，直到到达「山谷」（局部最小）。
首先在中间行搜索最小值，再将最小值与其上下两个元素比较，如果不满足题意，则“滑向”较小的一侧，矩阵被分为了两半（上下两侧）。
在较小的一侧，找到中间列的最小值，再将最小值与其左右两个元素比较，如果不满足题意，类似的移动到较小的一侧（左右两侧）。
现在查找范围缩小到了原来矩阵的四分之一，递归的进行上述操作，最后可以得到答案。
每次查找最小值都是对行/列进行遍历，遍历耗时和 N 成正比。
代码 # using System; namespace _1._4._19 { /* * 1.4.19 * * 矩阵的局部最小元素。 * 给定一个含有 N^2 个不同整数的 N×N 数组 a[]。 * 设计一个运行时间和 N 成正比的算法来找出一个局部最小元素： * 满足 a[i][j] &amp;lt; a[i+1][j]、a[i][j] &amp;lt; a[i][j+1]、a[i][j] &amp;lt; a[i-1][j] 以及 a[i][j] &amp;lt; a[i][j-1] 的索引 i 和 j。 * 程序运行时间在最坏情况下应该和 N 成正比。 * */ class Program { // 先查找 N/2 行中的最小元素，并令其与上下元素比较， // 如果不满足题意，则向相邻的最小元素靠近再次查找 static void Main(string[] args) { int[,] matrix = new int[5, 5] { { 26, 3, 4 , 10, 11 }, { 5, 1, 6, 12, 13 }, { 7, 8, 9 , 14, 15 }, { 16, 17, 18, 27, 20 }, { 21, 22, 23, 24, 25 } }; Console.</description></item><item><title>1.4.20</title><link>https://alg4.ikesnowy.com/1-4-20/</link><pubDate>Wed, 23 May 2018 21:57:46 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-20/</guid><description>1.4.20 # 解答 # 首先给出 BitMax 类的官方 Java 实现：BitonicMax.java。
我们使用这个类生成双调数组，并使用其中的 Max() 方法找到双调数组的最大值。
找到最大值之后分别对左右两侧进行二分查找，注意对于升序和降序的数组二分查找的实现有所不同。
代码 # BitonicMax 类 # using System; namespace _1._4._20 { /// &amp;lt;summary&amp;gt; /// 双调查找类。 /// &amp;lt;/summary&amp;gt; public class BitonicMax { /// &amp;lt;summary&amp;gt; /// 生成双调数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;N&amp;#34;&amp;gt;数组的大小。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static int[] Bitonic(int N) { Random random = new Random(); int mid = random.</description></item><item><title>1.4.21</title><link>https://alg4.ikesnowy.com/1-4-21/</link><pubDate>Wed, 23 May 2018 21:59:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-21/</guid><description>1.4.21 # 解答 # 直接将 Contains() 实现为二分查找即可。
代码 # /// &amp;lt;summary&amp;gt; /// 检查数组中是否存在指定元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;要查找的值。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;存在则返回 true，否则返回 false。&amp;lt;/returns&amp;gt; public bool Contains(int key) { return Rank(key, 0, this.a.Length - 1) != -1; } /// &amp;lt;summary&amp;gt; /// 二分查找。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;关键值。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;lo&amp;#34;&amp;gt;查找的起始下标。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;hi&amp;#34;&amp;gt;查找的结束下标。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;返回关键值的下标，如果不存在则返回 -1。&amp;lt;/returns&amp;gt; public int Rank(int key, int lo, int hi) { while (lo &amp;lt;= hi) { int mid = (hi - lo) / 2 + lo; if (key &amp;lt; this.</description></item><item><title>1.4.22</title><link>https://alg4.ikesnowy.com/1-4-22/</link><pubDate>Wed, 23 May 2018 22:00:52 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-22/</guid><description>1.4.22 # 解答 # 普通二分查找是通过除法不断减半缩小搜索范围。
这里我们用斐波那契数列来缩小范围。
举个例子，例如数组大小是 100，比它大的最小斐波那契数是 144。
斐波那契数列如下：0 1 1 2 3 5 8 13 21 34 55 89 144
我们记 F(n) = 144,F(n-1) = 89, F(n-2) = 55。
我们先查看第 0 + F(n-2) 个数，如果比关键值小则直接将范围缩小到 [55, 100]；否则则在[0, 55]之间查找。
之后我们令 n = n-1。
递归上述过程即可完成查找。
代码 # /// &amp;lt;summary&amp;gt; /// 使用斐波那契数列进行的查找。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;查找范围。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;关键字。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;返回查找到的关键值下标，没有结果则返回 -1。&amp;lt;/returns&amp;gt; static int rank(int[] a, int key) { // 使用斐波那契数列作为缩减范围的依据 int Fk = 1; int Fk_1 = 1; int Fk_2 = 0; // 获得 Fk，Fk需要大于等于数组的大小，复杂度 lgN while (Fk &amp;lt; a.</description></item><item><title>1.4.23</title><link>https://alg4.ikesnowy.com/1-4-23/</link><pubDate>Wed, 23 May 2018 22:02:30 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-23/</guid><description>1.4.23 # 解答 # 根据书中的提示，将二分查找中判断相等的条件改为两个数的差小于等于 $1/N^2$。
代码 # // 将二分查找中的相等判定条件修改为差值小于 x，其中 x = 1/N^2。 /// &amp;lt;summary&amp;gt; /// 二分查找。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;查找范围。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;关键字。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;结果的下标，没有结果时返回 -1。&amp;lt;/returns&amp;gt; static int BinarySearch(double[] a, double key) { int lo = 0; int hi = a.Length - 1; double threshold = 1.0 / (a.Length * a.Length); while (lo &amp;lt;= hi) { int mid = lo + (hi - lo) / 2; if (Math.</description></item><item><title>1.4.24</title><link>https://alg4.ikesnowy.com/1-4-24/</link><pubDate>Wed, 23 May 2018 22:03:52 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-24/</guid><description>1.4.24 # 解答 # 第一问：二分查找即可。
第二问： 按照第 1, 2, 4, 8,&amp;hellip;, 2^k 层顺序查找，一直到 2^k &amp;gt; F， 随后在 [2^(k - 1), 2^k] 范围中二分查找。
代码 # 这里建立了一个结构体用于返回测试结果：
struct testResult { public int F;// 找到的 F 值。 public int BrokenEggs;// 打碎的鸡蛋数。 } 用于测试的方法：
/// &amp;lt;summary&amp;gt; /// 扔鸡蛋，没碎返回 true，碎了返回 false。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;floor&amp;#34;&amp;gt;扔鸡蛋的高度。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; static bool ThrowEgg(int floor) { return floor &amp;lt;= F; } /// &amp;lt;summary&amp;gt; /// 第一种方案。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;大楼。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; static testResult PlanA(int[] a) { int lo = 0; int hi = a.</description></item><item><title>1.4.25</title><link>https://alg4.ikesnowy.com/1-4-25/</link><pubDate>Wed, 23 May 2018 22:07:51 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-25/</guid><description>1.4.25 # 解答 # 第一问：
第一个蛋按照 √(N), 2√(N), 3√(N), 4√(N),&amp;hellip;, √(N) * √(N) 顺序查找直至碎掉。这里扔了 k 次，k &amp;lt;= √(N)。
k-1√(N) ~ k√(N) 顺序查找直至碎掉，F 值就找到了。这里最多扔 √(N) 次。
第二问：
按照第 1, 3, 6, 10,&amp;hellip;, 1/2k^2 层顺序查找，一直到 1/2k^2 &amp;gt; F，
随后在 [1/2k^2 - k, 1/2k^2] 范围中顺序查找。
代码 # 这里我们同样定义了一个结构体：
struct testResult { public int F;// 测试得出的 F 值 public int BrokenEggs;// 碎掉的鸡蛋数。 public int ThrowTimes;// 扔鸡蛋的次数。 } 之后是测试用的方法：</description></item><item><title>1.4.26</title><link>https://alg4.ikesnowy.com/1-4-26/</link><pubDate>Wed, 23 May 2018 22:09:43 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-26/</guid><description>1.4.26 # 解答 # 首先，我们将问题转化为证明三点
$$ A(a,a^3),B(b,b^3),C(c,c^3) $$
共线，当且仅当满足
$$ a+b+c=0 $$
证明： 若 $A,B,C$ 三点共线，则直线 $AB$ 和 $BC$ 的斜率必定相等，有方程：
$$ \frac{b^3-a^3}{b-a}=\frac{c^3-b^3}{c-b} $$
由立方差公式：
$$ \frac{(b-a)(b^2+ba+a^2)}{b-a}=\frac{(c-b)(c^2+cb+b^2)}{c-b} $$
化简有：
$$ b^2+ba+a^2=c^2+cb+b^2\newline ba+a^2=c^2+cb $$
移项，将 $c$ 视为未知数：
$$ c^2+cb-ba-a^2=0 $$
利用十字相乘法进行因式分解：
$$ (a+b+c)(c-a)=0 $$
解得：
$$ c_1=-a-b,c_2=a $$
显然 $c\ne a$ ，因此当且仅当 $a+b+c=0$ 时 $A,B,C$ 三点共线。 证毕。</description></item><item><title>1.4.27</title><link>https://alg4.ikesnowy.com/1-4-27/</link><pubDate>Wed, 23 May 2018 22:20:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-27/</guid><description>1.4.27 # 解答 # 实现比较简单，想象两个栈背靠背接在一起，左侧栈负责出队，右侧栈负责入队。
当左侧栈为空时就把右侧栈中的元素倒到左侧栈，这个过程是 O(n) 的。
但在这个过程之前必然有 n 个元素入栈，均摊后即为 O(1)。
代码 # namespace _1._4._27 { /// &amp;lt;summary&amp;gt; /// 用两个栈模拟的队列。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;Item&amp;#34;&amp;gt;队列中的元素。&amp;lt;/typeparam&amp;gt; class StackQueue&amp;lt;Item&amp;gt; { Stack&amp;lt;Item&amp;gt; H;//用于保存出队元素 Stack&amp;lt;Item&amp;gt; T;//用于保存入队元素 /// &amp;lt;summary&amp;gt; /// 构造一个队列。 /// &amp;lt;/summary&amp;gt; public StackQueue() { this.H = new Stack&amp;lt;Item&amp;gt;(); this.T = new Stack&amp;lt;Item&amp;gt;(); } /// &amp;lt;summary&amp;gt; /// 将栈 T 中的元素依次弹出并压入栈 H 中。 /// &amp;lt;/summary&amp;gt; private void Reverse() { while (!</description></item><item><title>1.4.28</title><link>https://alg4.ikesnowy.com/1-4-28/</link><pubDate>Thu, 31 May 2018 09:12:15 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-28/</guid><description>1.4.28 # 解答 # 每次入队的时候将队列倒转，这样入队的元素就是第一个了。
代码 # namespace _1._4._28 { /// &amp;lt;summary&amp;gt; /// 用一条队列模拟的栈。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;Item&amp;#34;&amp;gt;栈中保存的元素。&amp;lt;/typeparam&amp;gt; class QueueStack&amp;lt;Item&amp;gt; { Queue&amp;lt;Item&amp;gt; queue; /// &amp;lt;summary&amp;gt; /// 初始化一个栈。 /// &amp;lt;/summary&amp;gt; public QueueStack() { this.queue = new Queue&amp;lt;Item&amp;gt;(); } /// &amp;lt;summary&amp;gt; /// 向栈中添加一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; public void Push(Item item) { this.</description></item><item><title>1.4.29</title><link>https://alg4.ikesnowy.com/1-4-29/</link><pubDate>Thu, 31 May 2018 09:13:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-29/</guid><description>1.4.29 # 解答 # 和用两个栈实现队列的方法类似。
push 的时候把右侧栈内容倒到左侧栈，之后再入栈。
pop 的时候也做相同操作，右侧栈内容进左侧栈，之后再出栈。
enqueue 的时候则将左侧栈内容倒到右侧栈，之后再入队。
代码 # namespace _1._4._29 { /// &amp;lt;summary&amp;gt; /// 用两个栈模拟的 Steque。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;Item&amp;#34;&amp;gt;Steque 中的元素类型。&amp;lt;/typeparam&amp;gt; class StackSteque&amp;lt;Item&amp;gt; { Stack&amp;lt;Item&amp;gt; H; Stack&amp;lt;Item&amp;gt; T; /// &amp;lt;summary&amp;gt; /// 初始化一个 Steque /// &amp;lt;/summary&amp;gt; public StackSteque() { this.H = new Stack&amp;lt;Item&amp;gt;(); this.T = new Stack&amp;lt;Item&amp;gt;(); } /// &amp;lt;summary&amp;gt; /// 向栈中添加一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; public void Push(Item item) { ReverseT(); this.</description></item><item><title>1.4.30</title><link>https://alg4.ikesnowy.com/1-4-30/</link><pubDate>Thu, 31 May 2018 09:14:03 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-30/</guid><description>1.4.30 # 解答 # steque 作为队列的头部，stack 作为队列的尾部。
pushLeft：直接 push 到 steque 中即可。
pushRight：如果 stack 为空，则直接 enqueue 到 steque 中，否则就 push 到 stack 中。
popLeft：如果 steque 为空，则将 stack 中的元素倒到 steque 中去（steque.push(stack.pop())），然后再从 steque 中 pop。
popRight：如果 stack 为空，则将 steque 中的元素倒到 stack 中去，然后再从 stack 中 pop。
代码 # namespace _1._4._30 { /// &amp;lt;summary&amp;gt; /// 用一个栈和一个 Steque 模拟的双向队列。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;Item&amp;#34;&amp;gt;双向队列中保存的元素类型。&amp;lt;/typeparam&amp;gt; class Deque&amp;lt;Item&amp;gt; { Stack&amp;lt;Item&amp;gt; stack;//代表队列尾部 Steque&amp;lt;Item&amp;gt; steque;//代表队列头部 /// &amp;lt;summary&amp;gt; /// 创建一条空的双向队列。 /// &amp;lt;/summary&amp;gt; public Deque() { this.</description></item><item><title>1.4.31</title><link>https://alg4.ikesnowy.com/1-4-31/</link><pubDate>Thu, 31 May 2018 09:15:11 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-31/</guid><description>1.4.31 # 解答 # 三个栈分别命名为左中右。
左侧栈和右侧栈负责模拟队列，和用两个栈模拟队列的方法类似。
由于是双向队列，左栈和右栈会频繁的倒来倒去，因此每次都只倒一半的元素可以有效减少开销。
有一侧栈为空时，另一侧栈中上半部分先移动到中间栈中，下半部分倒到另一侧栈里，再从中间栈拿回上半部分元素。
这样可以确保接下来的 pop 操作一定是常数级别的。
代码 # namespace _1._4._31 { /// &amp;lt;summary&amp;gt; /// 用三个栈模拟的双向队列。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;Item&amp;#34;&amp;gt;双向队列中的元素。&amp;lt;/typeparam&amp;gt; class Deque&amp;lt;Item&amp;gt; { Stack&amp;lt;Item&amp;gt; left; Stack&amp;lt;Item&amp;gt; middle; Stack&amp;lt;Item&amp;gt; right; /// &amp;lt;summary&amp;gt; /// 构造一条新的双向队列。 /// &amp;lt;/summary&amp;gt; public Deque() { this.left = new Stack&amp;lt;Item&amp;gt;(); this.middle = new Stack&amp;lt;Item&amp;gt;(); this.</description></item><item><title>1.4.32</title><link>https://alg4.ikesnowy.com/1-4-32/</link><pubDate>Thu, 31 May 2018 09:16:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-32/</guid><description>1.4.32 # 解答 # 首先，不需要扩容数组的的操作都只需访问数组一次，$M$ 次操作就是 $M$ 次访问。
随后我们有性质， $M$ 次栈操作后额外复制访问数组的次数小于 $2M$。
这里简单证明，设 $M$ 次操作之后栈的大小为 $n$，那么额外访问数组的次数为：
$S = \frac{n}{2} + \frac{n}{4} + \frac{n}{8} +&amp;hellip;+ 2 &amp;lt; n$
为了能使栈大小达到 $n$，$M$ 必须大于等于 $\frac{n}{2}$
因此 $2M \ge n &amp;gt; S$，得证。
因此我们可以得到 $M$ 次操作后访问数组次数的总和 $S&amp;rsquo; = S + M &amp;lt; 3M$。</description></item><item><title>1.4.33</title><link>https://alg4.ikesnowy.com/1-4-33/</link><pubDate>Thu, 31 May 2018 09:21:08 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-33/</guid><description>1.4.33 # 解答 # Integer = 4(int) + 8(对象开销) = 12
Date = 3 * 4(int * 3) + 8(对象开销) = 20
Counter = 4(String 的引用) + 4(int) + 8(对象开销) = 16
int[] = 8(对象开销) + 4(数组长度) + 4N = 12 + 4N
double[] = 8(对象开销) + 4(数组长度) + 8N = 12 + 8N
double[][] = 8(对象开销) + 4(数组长度) + 4M(引用) + M(12 + 8N)(M 个一维数组) = 12 + 16M + 8MN</description></item><item><title>1.4.34</title><link>https://alg4.ikesnowy.com/1-4-34/</link><pubDate>Thu, 31 May 2018 09:22:21 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-34/</guid><description>1.4.34 # 解答 # 第一种方案，类似于二分查找，先猜测左边界(lo)，再猜测右边界(hi)，如果边界值猜中的话直接返回，否则：
如果右边界比较热，那么左边界向右边界靠，lo=mid；否则，右边界向左边界靠，hi=mid。其中，mid = lo + (hi – lo)/2。
每次二分查找都要猜测两次，~2lgN。
第二种方案，假设上次猜测值为 $lastGuess$，本次即将要猜测的值为 $nowGuess$，通过方程：
$(lastGuess + nowGuess)/2 = (lo + hi)/2$
可以求得 $nowGuess$，具体可以查看示意图：
数字是猜测顺序，黑色范围是猜测值的范围（$lastGuess$ 和 $nowGuess$），绿色的是实际查找的范围（lo 和 hi）。
代码 # 首先是 Game 类
using System; namespace _1._4._34 { /// &amp;lt;summary&amp;gt; /// 某次猜测的结果。 /// &amp;lt;/summary&amp;gt; enum GuessResult { Hot = 1, // 比上次猜测更接近目标。 Equal = 0, // 猜中目标。 Cold = -1, // 比上次猜测更远离目标。 FirstGuess = -2 // 第一次猜测。 } /// &amp;lt;summary&amp;gt; /// 游戏类。 /// &amp;lt;/summary&amp;gt; class Game { public int N { get; } // 目标值的最大范围。 public int SecretNumber { get; } // 目标值。 public int LastGuess { get; private set; } // 上次猜测的值 /// &amp;lt;summary&amp;gt; /// 构造函数，新开一局游戏。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;N&amp;#34;&amp;gt;目标值的最大范围。&amp;lt;/param&amp;gt; public Game(int N) { Random random = new Random(); this.</description></item><item><title>1.4.35</title><link>https://alg4.ikesnowy.com/1-4-35/</link><pubDate>Thu, 31 May 2018 09:27:15 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-35/</guid><description>1.4.35 # 解答 # 1. 一个 Node 对象包含一个 int(泛型 Item) 的引用和下一个 Node 对象的引用。push 操作创建新 Node 对象时会创建一个引用。
因此对于第一种情况，压入 n 个 int 类型的元素创建了 N 个 Node 对象，创建了 2N 个引用。
2. 比起上一种情况，每个 Node 对象多包含了一个指向 Integer 的引用。
因此对于第二种情况，压入 n 个 int 类型的元素创建了 N 个 Node 对象和 N 个 Integer 对象，比起第一种情况多创建了 N 个引用。
3. 对于数组来说，创建对象只有扩容时重新创建数组对象一种情况，对于 N 次 push 操作只需要 lgN 次扩容，因此创建的对象为 lgN 个。
每次扩容都需要重新创建引用，(4 + 8 +&amp;hellip;+ 2N)(扩容) + N(每次 push 操作) = 5N - 4 = ~5N</description></item><item><title>1.4.36</title><link>https://alg4.ikesnowy.com/1-4-36/</link><pubDate>Thu, 31 May 2018 18:17:17 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-36/</guid><description>1.4.36 # 解答 # 1. N 个 Node对象的空间开销 = N * (16(对象开销) + 4(int) + 8(下一个 Node 的引用) + 4(填充字节)) = 32N
2. 比起上一题来说，空间开销变为
= N * (16(Node 对象开销) + 8(Integer 对象引用) + (16(Integer 对象开销) + 4(int) + 4(填充字节)) + 8(下一个对象的引用) = 32N + 24N = 56N。
3. 如果不扩容则是 4N，N 个元素最多可以维持 4N 的栈空间（少于四分之一将缩小）。
4. 比起上一题，数组元素变成了引用每个占用 8 字节，还要额外加上 Integer 对象的每个 24 字节。
= (8 + 24)N ~ (8 * 4 + 24)N</description></item><item><title>1.4.37</title><link>https://alg4.ikesnowy.com/1-4-37/</link><pubDate>Thu, 31 May 2018 18:19:59 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-37/</guid><description>1.4.37 # 解答 # 数据量比较大时才会有比较明显的差距。 代码 # FixedCapacityStackOfInts
using System; using System.Collections; using System.Collections.Generic; namespace _1._4._37 { /// &amp;lt;summary&amp;gt; /// 固定大小的整型数据栈。 /// &amp;lt;/summary&amp;gt; class FixedCapacityStackOfInts : IEnumerable&amp;lt;int&amp;gt; { private int[] a; private int N; /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;capacity&amp;#34;&amp;gt;栈的大小。&amp;lt;/param&amp;gt; public FixedCapacityStackOfInts(int capacity) { this.a = new int[capacity]; this.</description></item><item><title>1.4.38</title><link>https://alg4.ikesnowy.com/1-4-38/</link><pubDate>Thu, 31 May 2018 18:29:45 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-38/</guid><description>1.4.38 # 解答 # 把 DoublingTest 中调用的函数稍作修改即可。 代码 # ThreeSum 测试类
using System; namespace _1._4._38 { /// &amp;lt;summary&amp;gt; /// ThreeSum 测试类。 /// &amp;lt;/summary&amp;gt; public static class DoubleTest { private static readonly int MAXIMUM_INTEGER = 1000000; /// &amp;lt;summary&amp;gt; /// 返回对 n 个随机整数的数组进行一次 ThreeSum 所需的时间。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;随机数组的长度。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static double TimeTrial(int n) { int[] a = new int[n]; Random random = new Random(DateTime.</description></item><item><title>1.4.39</title><link>https://alg4.ikesnowy.com/1-4-39/</link><pubDate>Thu, 31 May 2018 18:33:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-39/</guid><description>1.4.39 # 解答 # 执行 N 次后取平均即可。 代码 # 修改后的 DoublingTest：
using System; using Measurement; namespace _1._4._39 { /// &amp;lt;summary&amp;gt; /// ThreeSum 测试类。 /// &amp;lt;/summary&amp;gt; public static class DoubleTest { private static readonly int MAXIMUM_INTEGER = 1000000; /// &amp;lt;summary&amp;gt; /// 返回对 n 个随机整数的数组进行一次 ThreeSum 所需的时间。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;随机数组的长度。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;repeatTimes&amp;#34;&amp;gt;重复测试的次数。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static double TimeTrial(int n, int repeatTimes) { int[] a = new int[n]; double sum = 0; Random random = new Random(DateTime.</description></item><item><title>1.4.40</title><link>https://alg4.ikesnowy.com/1-4-40/</link><pubDate>Thu, 31 May 2018 18:36:18 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-40/</guid><description>1.4.40 # 解答 # N 个数可组成的三元组的总数为：
$C(N, 3) = N(N-1)(N-2)/3! = ~ (N^3)/6​$ （组合数公式）
$[-M, M]​$ 中随机 $N​$ 次，有 $(2M+1)^N​$ 种随机序列（每次随机都有 $2M+1​$ 种可能）
按照分步计数方法，将随机序列分为和为零的三元组和其余 $N-3​$ 个数
这些序列中，和为零的三元组有 $3M^2 + 3M + 1​$ 种可能。
其他不为零的 $N-3​$ 个位置有 $(2M+1)^{(N-3)}​$ 种可能。
总共有 $((N^3)/6) \times (3M^2 + 3M + 1) \times (2M+1)^{(N-3)}​$ 种可能性
平均值为：
$[((N^3)/6) \times (3M^2 + 3M + 1) \times (2M+1)^{(N-3)}] / (2M+1)^N​$ $=N^3/16M​$
$3M^2 + 3M + 1$ 的推导：</description></item><item><title>1.4.41</title><link>https://alg4.ikesnowy.com/1-4-41/</link><pubDate>Thu, 31 May 2018 19:58:51 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-41/</guid><description>1.4.41 # 解答 # 代码 # 这里使用了委托来简化代码。
DoublingRatio
using System; using Measurement; namespace _1._4._41 { public delegate int Count(int[] a); static class DoublingRatio { /// &amp;lt;summary&amp;gt; /// 从指定字符串中读入按行分割的整型数据。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;inputString&amp;#34;&amp;gt;源字符串。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;读入的整型数组&amp;lt;/returns&amp;gt; private static int[] ReadAllInts(string inputString) { char[] split = new char[1] { &amp;#39;\n&amp;#39; }; string[] input = inputString.Split(split, StringSplitOptions.RemoveEmptyEntries); int[] a = new int[input.</description></item><item><title>1.4.42</title><link>https://alg4.ikesnowy.com/1-4-42/</link><pubDate>Thu, 31 May 2018 20:20:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-42/</guid><description>1.4.42 # 解答 # 这里我们把时限设置为一小时，使用上一题的数据估计。
1.ThreeSum 暴力方法在输入倍增时耗时增加 2^3 = 8 倍。
1K 数据耗费了 1.15 秒，在一小时内（3600 秒）可以完成 2^3 = 8K 数据。
2.ThreeSumFast 方法在输入倍增时耗时增加 2^2 = 4 倍。
1K 数据耗费了 0.05 秒，在一小时内（3600 秒）可以完成 2^8 = 256K 数据。
3.TwoSum 暴力方法在输入倍增时耗时增加 2^2 = 4 倍。
8K 数据耗费了 0.14 秒，在一小时内（3600 秒）可以完成 2^10 = 1024K 数据。
4.TwoSumFast 在输入倍增时耗时增加 2^1 = 2 倍。
32K 数据耗费了 0.008 秒，在一小时内（3600 秒）可以完成 2^16 = 65536K 数据。</description></item><item><title>1.4.43</title><link>https://alg4.ikesnowy.com/1-4-43/</link><pubDate>Thu, 31 May 2018 20:22:02 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-43/</guid><description>1.4.43 # 解答 # 代码 # 修改后的 DoublingRatio
using System; using Measurement; namespace _1._4._43 { static class DoublingRatio { /// &amp;lt;summary&amp;gt; /// 从指定字符串中读入按行分割的整型数据。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;inputString&amp;#34;&amp;gt;源字符串。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;读入的整型数组&amp;lt;/returns&amp;gt; private static int[] ReadAllInts(string inputString) { char[] split = new char[1] { &amp;#39;\n&amp;#39; }; string[] input = inputString.Split(split, StringSplitOptions.RemoveEmptyEntries); int[] a = new int[input.</description></item><item><title>1.4.44</title><link>https://alg4.ikesnowy.com/1-4-44/</link><pubDate>Thu, 31 May 2018 20:25:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-44/</guid><description>1.4.44 # 解答 # 每生成一个随机数都和之前生成过的随机数相比较。 代码 # using System; namespace _1._4._44 { /* * 1.4.44 * * 生日问题。 * 编写一个程序， * 从命令行接受一个整数 N 作为参数并使用 StdRandom.uniform() 生成一系列 0 到 N-1 之间的随机整数。 * 通过实验验证产生第一个重复的随机数之前生成的整数数量为 ~√(πN/2)。 * */ class Program { static void Main(string[] args) { Random random = new Random(); int N = 10000; int[] a = new int[N]; int dupNum = 0; int times = 0; for (times = 0; times &amp;lt; 500; ++times) { for (int i = 0; i &amp;lt; N; ++i) { a[i] = random.</description></item><item><title>1.4.45</title><link>https://alg4.ikesnowy.com/1-4-45/</link><pubDate>Thu, 31 May 2018 20:26:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-45/</guid><description>1.4.45 # 解答 # 建立一个布尔数组，将每次随机出来的数作为下标，将相应位置的布尔值改为 true，每次随机都检查一遍这个数组是否都是 true。
代码 # using System; namespace _1._4._45 { /* * 1.4.45 * * 优惠券收集问题。 * 用和上一题相同的方式生成随机整数。 * 通过实验验证生成所有可能的整数值所需生成的随机数总量为 ~NHN。 * （这里的 HN 中 N 是下标） * */ class Program { // HN 指的是调和级数 static void Main(string[] args) { Random random = new Random(); int N = 10000; bool[] a = new bool[N]; int randomSize = 0; int times = 0; for (times = 0; times &amp;lt; 20; ++times) { for (int i = 0; i &amp;lt; N; ++i) { a[i] = false; } for(int i = 0; true; ++i) { int now = random.</description></item><item><title>1.5.1</title><link>https://alg4.ikesnowy.com/1-5-1/</link><pubDate>Fri, 22 Jun 2018 19:35:43 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-1/</guid><description>1.5.1 # 解答 # quick-find 的官方实现：QuickFindUF.java。
只要实现相应并查集，然后输入内容即可。
增加一个记录访问数组次数的类成员变量，在每次访问数组的语句执行后自增即可。
样例输出：
1 2 3 4 5 6 7 8 0 数组访问：13 1 2 4 4 5 6 7 8 0 数组访问：13 1 2 4 4 8 6 7 8 0 数组访问：13 1 2 4 4 8 6 2 8 0 数组访问：13 1 1 4 4 8 6 1 8 0 数组访问：14 1 1 4 4 1 6 1 1 0 数组访问：14 1 1 4 4 1 6 1 1 4 数组访问：14 1 1 1 1 1 6 1 1 1 数组访问：16 代码 # QuickFindUF.</description></item><item><title>1.5.2</title><link>https://alg4.ikesnowy.com/1-5-2/</link><pubDate>Fri, 22 Jun 2018 19:39:25 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-2/</guid><description>1.5.2 # 解答 # quick-union 的官方实现：QuickUnionUF.java。
和上题一样的方式，增加一个记录访问数组次数的类成员变量，在每次访问数组的语句执行后自增即可。
程序输出的森林，用缩进表示子树：
|---- 0 |---- 9 |---- 1 |---- 2 |---- 3 |---- 4 |---- 5 |---- 6 |---- 7 |---- 8 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 4 |---- 3 |---- 5 |---- 6 |---- 7 |---- 8 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 4 |---- 3 |---- 6 |---- 7 |---- 8 |---- 5 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 7 |---- 4 |---- 3 |---- 6 |---- 8 |---- 5 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 7 |---- 4 |---- 3 |---- 6 |---- 8 |---- 5 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 7 |---- 8 |---- 5 |---- 4 |---- 3 |---- 6 数组访问：7 |---- 1 |---- 2 |---- 7 |---- 8 |---- 5 |---- 4 |---- 0 |---- 9 |---- 3 |---- 6 数组访问：3 |---- 1 |---- 2 |---- 7 |---- 4 |---- 0 |---- 9 |---- 3 |---- 8 |---- 5 |---- 6 数组访问：3 代码 # QuickUnionUF.</description></item><item><title>1.5.3</title><link>https://alg4.ikesnowy.com/1-5-3/</link><pubDate>Fri, 22 Jun 2018 19:41:22 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-3/</guid><description>1.5.3 # 解答 # 加权 quick-union 的官方实现：WeightedQuickUnionUF.java。
样例输出：
1 2 3 4 5 6 7 8 9 数组访问：3 1 2 3 3 5 6 7 8 9 数组访问：3 1 2 3 3 5 6 7 5 9 数组访问：3 1 7 3 3 5 6 7 5 9 数组访问：3 7 7 3 3 5 6 7 5 9 数组访问：5 7 7 3 3 7 6 7 5 9 数组访问：3 7 7 9 3 7 6 7 5 9 数组访问：5 7 7 9 3 7 6 7 5 7 数组访问：9 代码 # WeightedQuickUnionUF.</description></item><item><title>1.5.4</title><link>https://alg4.ikesnowy.com/1-5-4/</link><pubDate>Fri, 22 Jun 2018 19:42:54 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-4/</guid><description>1.5.4 # 解答 # 对照输入和最坏输入均在书中出现，中文版见：P146，英文版见：P229。
样例输出：
3 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 5 6 7 8 9 size: 1 1 1 1 2 1 1 1 1 1 parent visit count:3 size visit count:4 8 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 5 6 7 4 9 size: 1 1 1 1 3 1 1 1 1 1 parent visit count:5 size visit count:4 5 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 6 6 7 4 9 size: 1 1 1 1 3 1 2 1 1 1 parent visit count:3 size visit count:4 4 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 6 6 7 4 4 size: 1 1 1 1 4 1 2 1 1 1 parent visit count:3 size visit count:4 1 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 2 2 4 4 6 6 7 4 4 size: 1 1 2 1 4 1 2 1 1 1 parent visit count:3 size visit count:4 9 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 2 2 4 4 6 6 7 4 4 size: 1 1 2 1 4 1 2 1 1 1 parent visit count:6 size visit count:0 0 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 2 4 4 6 6 7 4 4 size: 1 1 2 1 4 1 3 1 1 1 parent visit count:5 size visit count:4 2 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 2 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 3 1 1 1 parent visit count:3 size visit count:4 1 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 6 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 6 1 1 1 parent visit count:5 size visit count:4 0 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 6 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 6 1 1 1 parent visit count:8 size visit count:0 7 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 6 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 6 1 1 1 parent visit count:6 size visit count:0 ------------------------------------- 1 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 2 3 4 5 6 7 8 9 size: 2 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 2 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 3 4 5 6 7 8 9 size: 3 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 3 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 4 5 6 7 8 9 size: 4 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 4 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 5 6 7 8 9 size: 5 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 5 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 6 7 8 9 size: 6 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 6 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 7 8 9 size: 7 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 7 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 0 8 9 size: 8 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 8 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 0 0 9 size: 9 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 9 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 0 0 0 size: 10 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 代码 # Main 方法：</description></item><item><title>1.5.5</title><link>https://alg4.ikesnowy.com/1-5-5/</link><pubDate>Fri, 22 Jun 2018 19:44:20 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-5/</guid><description>1.5.5 # 解答 # $10^6$ 条连接 = $10^6$ 组输入。
对于 quick-find 算法，每次 union() 都要遍历整个数组。
因此总共进行了 $10^9 \times 10^6 = 10^{15}$ 次 for 循环迭代。
每次 for 循环迭代都需要 $10$ 条机器指令，
因此总共执行了 $10 \times10^{15} = 10^{16}$ 条机器指令。
已知计算机每秒能够执行 $10^9$ 条机器指令，
因此执行完所有指令需要 $10^{16} / 10^9 = 10^7$ 秒 = $115.74$ 天。</description></item><item><title>1.5.6</title><link>https://alg4.ikesnowy.com/1-5-6/</link><pubDate>Fri, 22 Jun 2018 19:47:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-6/</guid><description>1.5.6 # 解答 # 加权 quick-union 算法最多只需要 $lgN $次迭代就可以完成一次 union()。
因此按照上题思路，总共需要 $(lg(10^9) \times 10^6 \times 10) / 10^9 = 0.299$ 秒。</description></item><item><title>1.5.7</title><link>https://alg4.ikesnowy.com/1-5-7/</link><pubDate>Fri, 22 Jun 2018 19:50:21 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-7/</guid><description>1.5.7 # 解答 # 见 1.5.1 和 1.5.2 的解答。</description></item><item><title>1.5.8</title><link>https://alg4.ikesnowy.com/1-5-8/</link><pubDate>Fri, 22 Jun 2018 19:51:02 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-8/</guid><description>1.5.8 # 解答 # 当有多个元素需要修改的时候，这个直观算法可能会出现错误。
例如如下情况：
index 0 1 2 3 4 5 6 7 8 9 id 0 0 0 0 0 5 5 5 5 5 输入 0, 5
i = 0 时，id[i] == id[p]，此时 id[i] = id[q]。
数组变为 5 0 0 0 0 5 5 5 5 5
i = 1 时，id[i] != id[p]，算法出现错误。
只要在 id[p] 之后还有需要修改的元素，那么这个算法就会出现错误。</description></item><item><title>1.5.9</title><link>https://alg4.ikesnowy.com/1-5-9/</link><pubDate>Fri, 22 Jun 2018 19:52:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-9/</guid><description>1.5.9 # 解答 # 不可能。 树如下所示。
由于加权 quick-union 算法任意节点的最大深度为 lgN （节点总数为 N）。
（这个结论可以在中文版 P146，或者英文版 P228 找到）
上面这个树的最大深度为 4 &amp;gt; lg10
因此这棵树不可能是通过加权 quick-union 算法得到的。</description></item><item><title>1.5.10</title><link>https://alg4.ikesnowy.com/1-5-10/</link><pubDate>Fri, 22 Jun 2018 19:54:46 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-10/</guid><description>1.5.10 # 解答 # 本题答案已经给出，也很好理解。
如果合并时只是把子树挂到结点 q 上而非其根节点，
树的高度会明显增加，进而增加每次 Find() 操作的开销。</description></item><item><title>1.5.11</title><link>https://alg4.ikesnowy.com/1-5-11/</link><pubDate>Fri, 22 Jun 2018 19:55:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-11/</guid><description>1.5.11 # 解答 # 类似于加权 quick-union 的做法，新增一个 size[] 数组以记录各个根节点的大小。
每次合并时先比较一下两棵树的大小，再进行合并。
这样会略微减少赋值语句的执行次数，提升性能。
代码 # WeightedQuickFindUF.cs
using System; namespace _1._5._11 { /// &amp;lt;summary&amp;gt; /// 用加权 QuickFind 算法实现的并查集。 /// &amp;lt;/summary&amp;gt; public class WeightedQuickFindUF { private int[] size; // 记录每个连通分量的大小。 private int[] id; // 记录每个结点的连通分量。 private int count;// 连通分量总数。 public int ArrayVisitCount { get; private set; } //记录数组访问的次数。 /// &amp;lt;summary&amp;gt; /// 新建一个使用加权 quick-find 实现的并查集。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;并查集的大小。&amp;lt;/param&amp;gt; public WeightedQuickFindUF(int n) { this.</description></item><item><title>1.5.12</title><link>https://alg4.ikesnowy.com/1-5-12/</link><pubDate>Fri, 22 Jun 2018 19:57:05 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-12/</guid><description>1.5.12 # 解答 # QuickUnionPathCompression 的官方实现：QuickUnionPathCompressionUF.java
在找到根节点之后，再访问一遍 p 到根节点这条路径上的所有结点，将它们直接和根节点相连。
重写过后的 Find() 方法：
/// &amp;lt;summary&amp;gt; /// 寻找结点所属的连通分量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;p&amp;#34;&amp;gt;需要寻找的结点。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;结点所属的连通分量。&amp;lt;/returns&amp;gt; public override int Find(int p) { int root = p; while (root != this.parent[root]) { root = this.parent[root]; } while (p != root) { int newp = this.parent[p]; this.parent[p] = root; p = newp; } return p; } 由于路径压缩是在 Find() 方法中实现的，</description></item><item><title>1.5.13</title><link>https://alg4.ikesnowy.com/1-5-13/</link><pubDate>Fri, 22 Jun 2018 19:59:26 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-13/</guid><description>1.5.13 # 解答 # 官方实现：WeightedQuickUnionPathCompressionUF。
加权 quick-union 中，两个大小相等的树合并可以有效增加高度，同时输入必须保证是根节点以规避路径压缩。
代码 # WeightedQuickUnionPathCompressionUF.cs 从 WeightedQuickUnionUF.cs 继承，详情参见 1.5.3 的解答。
namespace UnionFind { /// &amp;lt;summary&amp;gt; /// 使用路径压缩的加权 quick-union 并查集。 /// &amp;lt;/summary&amp;gt; public class WeightedQuickUnionPathCompressionUF : WeightedQuickUnionUF { /// &amp;lt;summary&amp;gt; /// 新建一个大小为 n 的并查集。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;新建并查集的大小。&amp;lt;/param&amp;gt; public WeightedQuickUnionPathCompressionUF(int n) : base(n) { this.size = new int[n]; for (int i = 0; i &amp;lt; n; ++i) { this.</description></item><item><title>1.5.14</title><link>https://alg4.ikesnowy.com/1-5-14/</link><pubDate>Fri, 22 Jun 2018 20:04:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-14/</guid><description>1.5.14 # 解答 # WeightedQuickUnionByHeight 的官方实现：WeightedQuickUnionByHeightUF.java。
证明： 一次 Union 操作只可能发生如下两种情况。
两棵树的高度相同，这样合并后的新树的高度等于较大那棵树的高度 + 1。
两棵树的高度不同，这样合并后的新树高度等于较大那棵树的高度。
现在证明通过加权 quick-union 算法构造的高度为 h 的树至少包含 2h 个结点。
基础情况，高度 h = 0, 结点数 k = 1。
为了使高度增加，必须用一棵高度相同的树合并，而 h = 0 时结点数一定是 1，则：
h = 1, k = 2
由于两棵大小不同的树合并，最大高度不会增加，只会增加结点数。
因此，每次都使用相同高度的最小树进行合并，有：
h = 2, k = 4 h = 3, k = 8 h = 4, k = 16 ...... 递推即可得到结论，k ≥ 2^h</description></item><item><title>1.5.15</title><link>https://alg4.ikesnowy.com/1-5-15/</link><pubDate>Fri, 22 Jun 2018 20:05:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-15/</guid><description>1.5.15 # 解答 # 首先证明在最坏情况下加权 quick-union 算法生成的树中的每一层结点数均为二项式系数。
最坏情况下，每次 union 操作都是合并相同大小的树，如下图所示：
设第 i 层的结点数为 ki，那么最坏情况下每次合并后的 ki’ = ki + ki-1 。
这符合二项式系数的构造特点（详情可以搜索杨辉三角），
第一个结论证明完毕。
接下来求平均深度，首先根据二项式的求和公式，一棵深度为 n 的树（根结点的深度为零）结点总数为：
$$ \sum_{k=0}^{n} \begin{pmatrix} n \newline k \end{pmatrix} =2^n $$
每层结点数 × 该层深度后的和为：
$$ \sum_{k=0}^{n}k \cdot \begin{pmatrix} n \newline k \end{pmatrix}=n\sum_{k=1}^{n} \begin{pmatrix} n-1 \newline k-1 \end{pmatrix}=n\sum_{s=0}^{n-1} \begin{pmatrix} n-1 \newline s \end{pmatrix}=n2^{n-1} $$
这里用到了这个公式化简：
$$ \begin{pmatrix} n \newline k \end{pmatrix}=\frac{n}{k} \begin{pmatrix} n-1 \newline k-1 \end{pmatrix} $$</description></item><item><title>1.5.16</title><link>https://alg4.ikesnowy.com/1-5-16/</link><pubDate>Fri, 22 Jun 2018 20:44:09 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-16/</guid><description>1.5.16 # 解答 # 给出绘图结果样例： 代码 # 仅给出绘图相关的代码，窗体部分见 github 上的代码：
using System; using System.Linq; using System.Windows.Forms; using System.Drawing; using UnionFind; namespace _1._5._16 { /* * 1.5.16 * * 均摊成本的图像。 * 修改你为练习 1.5.7 给出的实现， * 绘出如正文所示的均摊成本的图像。 * */ static class Program { [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Compute(); Application.Run(new Form1()); } static void Compute() { char[] split = { &amp;#39;\n&amp;#39;, &amp;#39;\r&amp;#39; }; string[] input = TestCase.</description></item><item><title>1.5.17</title><link>https://alg4.ikesnowy.com/1-5-17/</link><pubDate>Fri, 22 Jun 2018 20:46:19 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-17/</guid><description>1.5.17 # 解答 # 官方给出的 ErdosRenyi：ErdosRenyi.java。
为了方便之后做题，除了 Count() 之外，这个类还包含其他方法，具体可以查看注释。
代码 # ErdosRenyi.cs
using System; using System.Collections.Generic; namespace UnionFind { /// &amp;lt;summary&amp;gt; /// 提供一系列对并查集进行随机测试的静态方法。 /// &amp;lt;/summary&amp;gt; public class ErdosRenyi { /// &amp;lt;summary&amp;gt; /// 随机生成一组能让并查集只剩一个连通分量的连接。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;并查集大小。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;一组能让并查集只剩一个连通分量的连接。&amp;lt;/returns&amp;gt; public static Connection[] Generate(int n) { Random random = new Random(); List&amp;lt;Connection&amp;gt; connections = new List&amp;lt;Connection&amp;gt;(); WeightedQuickUnionPathCompressionUF uf = new WeightedQuickUnionPathCompressionUF(n); while (uf.</description></item><item><title>1.5.18</title><link>https://alg4.ikesnowy.com/1-5-18/</link><pubDate>Fri, 22 Jun 2018 20:48:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-18/</guid><description>1.5.18 # 解答 # 具体生成的连接样式见下题，这里给出 RandomGrid 的实现，需要使用 1.3 节中的随机背包辅助。
代码 # RandomGrid.cs
using System; using System.Collections.Generic; namespace UnionFind { public class RandomGrid { /// &amp;lt;summary&amp;gt; /// 随机生成 n × n 网格中的所有连接。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;网格边长。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;随机排序的连接。&amp;lt;/returns&amp;gt; public static RandomBag&amp;lt;Connection&amp;gt; Generate(int n) { var result = new RandomBag&amp;lt;Connection&amp;gt;(); var random = new Random(); // 建立横向连接 for (int i = 0; i &amp;lt; n; ++i) { for (int j = 0; j &amp;lt; n - 1; ++j) { if (random.</description></item><item><title>1.5.19</title><link>https://alg4.ikesnowy.com/1-5-19/</link><pubDate>Fri, 22 Jun 2018 20:55:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-19/</guid><description>1.5.19 # 解答 # 最后绘出的图像： 代码 # 给出绘图部分的代码，窗体部分见 GitHub。
using System; using System.Drawing; using System.Collections.Generic; using System.Windows.Forms; using UnionFind; namespace _1._5._19 { /* * 1.5.19 * * 动画。 * 编写一个 RandomGrid（请见练习 1.5.18）的用例， * 和我们开发用例一样使用 UnionFind 来检查触点的连通性并在处理时用 StdDraw 将它们绘出。 * */ static class Program { static RandomBag&amp;lt;Connection&amp;gt; bag; static Graphics graphics; static TextBox logBox; static PointF[] points; static Timer timer; static List&amp;lt;Connection&amp;gt; connections; static int count = 0; /// &amp;lt;summary&amp;gt; /// 应用程序的主入口点。 /// &amp;lt;/summary&amp;gt; [STAThread] static void Main() { Application.</description></item><item><title>1.5.20</title><link>https://alg4.ikesnowy.com/1-5-20/</link><pubDate>Thu, 28 Jun 2018 13:34:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-20/</guid><description>1.5.20 # 解答 # 将 parent 数组和 size 数组用链表代替即可，很容易实现。
代码 # 修改后的 WeightedQuickUnionUF.cs
using System; namespace _1._5._20 { /// &amp;lt;summary&amp;gt; /// 使用加权 quick-union 算法的并查集。 /// &amp;lt;/summary&amp;gt; public class WeightedQuickUnionUF { protected LinkedList&amp;lt;int&amp;gt; parent; // 记录各个结点的父级。 protected LinkedList&amp;lt;int&amp;gt; size; // 记录各个树的大小。 protected int count; // 分量数目。 /// &amp;lt;summary&amp;gt; /// 建立使用加权 quick-union 的并查集。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;并查集的大小。&amp;lt;/param&amp;gt; public WeightedQuickUnionUF() { this.</description></item><item><title>1.5.21</title><link>https://alg4.ikesnowy.com/1-5-21/</link><pubDate>Thu, 28 Jun 2018 13:37:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-21/</guid><description>1.5.21 # 解答 # 给出我电脑上的结果：
实验结果：10 1/2NlnN：11.5129254649702 实验结果：29 1/2NlnN：29.9573227355399 实验结果：132 1/2NlnN：73.7775890822787 实验结果：164 1/2NlnN：175.281065386955 实验结果：418 1/2NlnN：406.013905218706 实验结果：1143 1/2NlnN：922.931359327004 实验结果：2004 1/2NlnN：2067.66981643319 实验结果：4769 1/2NlnN：4578.95382842474 实验结果：10422 1/2NlnN：10045.1360479662 实验结果：21980 1/2NlnN：21864.7288781659 代码 # using System; using UnionFind; namespace _1._5._21 { /* * 1.5.21 * * Erdös-Renyi 模型。 * 使用练习 1.5.17 的用例验证这个猜想： * 得到单个连通分量所需生成的整数对数量为 ~1/2NlnN。 * */ class Program { static void Main(string[] args) { for (int n = 10; n &amp;lt; 10000; n *= 2) { int total = 0; for (int i = 0; i &amp;lt; 100; ++i) { UF uf = new UF(n); total += ErdosRenyi.</description></item><item><title>1.5.22</title><link>https://alg4.ikesnowy.com/1-5-22/</link><pubDate>Thu, 28 Jun 2018 13:39:41 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-22/</guid><description>1.5.22 # 解答 # 平方级别算法在输入加倍后耗时应该增加四倍，线性则是两倍。
下面给出我电脑上的结果，数据量较大时比较明显：
N:16000 quick-find 平均次数：8452 用时：143 比值：4.46875 quick-union 平均次数：7325 用时：202 比值：3.25806451612903 weighted-quick-union 平均次数：6889 用时：1 N:32000 quick-find 平均次数：15747 用时：510 比值：3.56643356643357 quick-union 平均次数：15108 用时：801 比值：3.96534653465347 weighted-quick-union 平均次数：17575 用时：3 比值：3 N:64000 quick-find 平均次数：33116 用时：2069 比值：4.05686274509804 quick-union 平均次数：38608 用时：4635 比值：5.78651685393258 weighted-quick-union 平均次数：34850 用时：6 比值：2 代码 # using System; using System.Diagnostics; using UnionFind; namespace _1._5._22 { /* * 1.5.22 * * Erdös-Renyi 的倍率实验。 * 开发一个性能测试用例， * 从命令行接受一个 int 值 T 并进行 T 次以下实验： * 使用练习 1.</description></item><item><title>1.5.23</title><link>https://alg4.ikesnowy.com/1-5-23/</link><pubDate>Thu, 28 Jun 2018 13:41:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-23/</guid><description>1.5.23 # 解答 # 先用速度最快的 WeightedQuickUnionUF 生成一系列连接，
保存后用这些连接进行测试，生成连接的方法见 1.5.17 的解答。
下面给出我电脑上的结果：
N:2000 quick-find 耗时（毫秒）：4 quick-union 耗时（毫秒）：5 比值：0.8 N:4000 quick-find 耗时（毫秒）：19 quick-union 耗时（毫秒）：24 比值：0.791666666666667 N:8000 quick-find 耗时（毫秒）：57 quick-union 耗时（毫秒）：74 比值：0.77027027027027 N:16000 quick-find 耗时（毫秒）：204 quick-union 耗时（毫秒）：307 比值：0.664495114006515 N:32000 quick-find 耗时（毫秒）：1127 quick-union 耗时（毫秒）：1609 比值：0.700435052827843 代码 # using System; using System.Diagnostics; using UnionFind; namespace _1._5._23 { /* * 1.5.23 * * 在 Erdös-Renyi 模型下比较 quick-find 算法和 quick-union 算法。 * 开发一个性能测试用例，从命令行接受一个 int 值 T 并进行 T 次以下实验： * 使用练习 1.</description></item><item><title>1.5.24</title><link>https://alg4.ikesnowy.com/1-5-24/</link><pubDate>Thu, 28 Jun 2018 13:47:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-24/</guid><description>1.5.24 # 解答 # 根据上题的代码略作修改即可，路径压缩大概可以快 1/3。
N:10000 加权 quick-find 耗时（毫秒）：9 带路径压缩的加权 quick-union 耗时（毫秒）：6 比值：1.5 N:20000 加权 quick-find 耗时（毫秒）：12 带路径压缩的加权 quick-union 耗时（毫秒）：8 比值：1.5 N:40000 加权 quick-find 耗时（毫秒）：18 带路径压缩的加权 quick-union 耗时（毫秒）：12 比值：1.5 N:80000 加权 quick-find 耗时（毫秒）：36 带路径压缩的加权 quick-union 耗时（毫秒）：30 比值：1.2 N:160000 加权 quick-find 耗时（毫秒）：67 带路径压缩的加权 quick-union 耗时（毫秒）：41 比值：1.63414634146341 代码 # using System; using UnionFind; using System.Diagnostics; namespace _1._5._24 { /* * 1.5.24 * * 适用于 Erdös-Renyi 模型的快速算法。 * 在练习1.</description></item><item><title>1.5.25</title><link>https://alg4.ikesnowy.com/1-5-25/</link><pubDate>Thu, 28 Jun 2018 13:48:55 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-25/</guid><description>1.5.25 # 解答 # 略微修改 1.5.22 的代码即可。 我电脑上的结果：
Quick-Find N:1600 平均用时（毫秒）：4 N:6400 平均用时（毫秒）：67 比值：16.75 N:25600 平均用时（毫秒）：1268 比值：18.9253731343284 N:102400 平均用时（毫秒）：20554 比值：16.2097791798107 Quick-Union N:1600 平均用时（毫秒）：5 比值：0.000243261652233142 N:6400 平均用时（毫秒）：66 比值：13.2 N:25600 平均用时（毫秒）：1067 比值：16.1666666666667 N:102400 平均用时（毫秒）：18637 比值：17.4667291471415 Weighted Quick-Union N:1600 平均用时（毫秒）：0 比值：0 N:6400 平均用时（毫秒）：2 N:25600 平均用时（毫秒）：12 比值：6 N:102400 平均用时（毫秒）：64 比值：5.33333333333333 代码 # using System; using System.Diagnostics; using UnionFind; namespace _1._5._25 { /* * 1.5.25 * * 随机网格的倍率测试。 * 开发一个性能测试用例， * 从命令行接受一个 int 值 T 并进行 T 次以下实验： * 使用练习 1.</description></item><item><title>1.5.26</title><link>https://alg4.ikesnowy.com/1-5-26/</link><pubDate>Thu, 28 Jun 2018 13:50:42 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-26/</guid><description>1.5.26 # 解答 # 和 1.5.16 的程序类似，将测试的内容改为 Erdos-Renyi 即可。
样例输出：
代码 # using System; using System.Linq; using System.Windows.Forms; using System.Drawing; using UnionFind; namespace _1._5._26 { /* * 1.5.26 * * Erdös-Renyi 模型的均摊成本图像。 * 开发一个用例， * 从命令行接受一个 int 值 N，在 0 到 N-1 之间产生随机整数对， * 调用 connected() 判断它们是否相连， * 如果不是则用 union() 方法（和我们的开发用例一样）。 * 不断循环直到所有触点互通。 * 按照正文的样式将所有操作的均摊成本绘制成图像。 * */ static class Program { /// &amp;lt;summary&amp;gt; /// 应用程序的主入口点。 /// &amp;lt;/summary&amp;gt; [STAThread] static void Main() { Application.</description></item></channel></rss>